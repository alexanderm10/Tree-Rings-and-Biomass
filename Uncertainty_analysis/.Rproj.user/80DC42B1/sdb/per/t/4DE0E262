{
    "contents" : "##################################################################################\n## Basic Components necessary for data management for doing dendro modelling\n##################################################################################\n\n# clear memory\nrm(list=ls())\n\n# importing libraries\nlibrary(dplR)\nlibrary(lattice)\n\n# Getting Libraries\nlibrary(reshape)\nlibrary(car)\nlibrary(mgcv)\nlibrary(nlme)\nlibrary(lmeSplines)\n#library(lme4)\nlibrary(splines)\nlibrary(MASS)\nlibrary(MuMIn)\nlibrary(ggplot2)\nlibrary(grid)\nse <- function(x){\n\tsd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}\n\nq.blank <- theme(axis.line=element_line(color=\"black\", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color=\"black\", size=14, face=\"bold\"), axis.text.y=element_text(color=\"black\", size=12, face=\"bold\"), axis.title.x=element_text(face=\"bold\", size=14),  axis.title.y=element_text(face=\"bold\", size=14))\n\n\n#################################################################################################\n# STEP 1: Gap-filling measured trees\n# STEP 1b: Pith-correction in measured trees (useful for stand dynamics; won't do unless you ask for it)\n# STEP 2: Gap-filling missing trees\n#\n# BIG SELLING POINT OF THIS APPROACH: we can quantify different levels of uncertainty & variability\n# Caveats: fitting the initial GAMM is very time-intensive (it may take hours with your full data) because current form fits a spline to each tree in a mixed model framework\n\n#################################################################################################\n# Previous workflow\n# 1) Read in RWL, QA/QC\n# 3) Aggregate to tree (factoring in whether cores were dated) level & decide if an entire tree is dated or not -- WRITE THIS AS A FILE!\n# 4) Stack RWL & Merge with metadata (becomes \"ring.data\" or named equivalent)\n\n\n# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns\nring.data <- read.csv(\"TreeRWL_Valles_stacked.csv\")\nring.data$tree <- as.factor(ring.data$tree) \nsummary(ring.data)\n\ntree.data <- read.csv(\"TreeData.csv\")\nsummary(tree.data)\n\n# We're going to run 2 sets of fillin models:\n# 1) Model based on only DATED trees (m1d)\n# 2) Model based on both DATED and UNDATED trees (m1u)\n\ntrees.dated <- ring.data[ring.data$Dated==\"Y\",\"TreeID\"]\n\n# using the gamm allows us to fit a smoothing spline to each tree, which allows us to basically gapfill taking into account unique tree temporal trends\n#\tcurrent spline parameter: shrinkage version of cubic spline with 3 knots (stiff CR spline)\n#\twhen we fit a generalized version for missing trees, we'll have to decide what to fit it to instead of TreeID; I think probably species|plot\n# m1 <- gamm(RW ~ s(Year, bs=\"cs\", k=3) + species + dbh, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)\n\n# ----------------------------------------------------------------\n# IDEAL MODEL FORM (it won't work for many reasons)\n#\t-- won't predict outside range of years observed on each core\n#\t-- end up with singularity issues\n#\t-- would take FOREVER to fit even if it did work\n# m1d <- gamm(RW ~ s(Year, bs=\"cs\", k=3, by=TreeID) + species*dbh*canopy.class, random=list(site=~1, PlotID=~1, TreeID=~1), data=trees.dated.full, na.action=na.omit)\n# ----------------------------------------------------------------\n\n\n\n# ----------------------------------------------------------------\n# The spline doesn't fit outside the range of observed values, so we need to give it a \"null\" guess\n# As a very very rough guess right now, filling missing with the measurement from the oldest ring\n# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)\n# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?\n\n# ---------------------------------------\n# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)\n# ---------------------------------------\n# What we need: core summary data (DBH, estimated pith date)\n\n# ---------------------------------------\n\n# ---------------------------------------\n# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?\n# ---------------------------------------\nring.data$RW0 <- ring.data$RW\nfor(i in unique(ring.data$TreeID)){\n\tyr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), \"Year\"])\n  #fill.first # The first (e.g. X number years past where you measured) ring to add a dummy measurement\n  #fill.RW # the value we stick in the years we want to dummy-fill (e.g. the mean for the last decade)\n\tring.data[ring.data$TreeID==i & is.na(ring.data$RW), \"RW0\"] <- ring.data[ring.data$TreeID==i & ring.data$Year==yr, \"RW\"]\n}\nsummary(ring.data)\n# ---------------------------------------\n# ----------------------------------------------------------------\n\n# A generalized additive mixed model (gamm) allows us to fit splines in a mixed model context\n# we can let these splines vary by tree which essentially detrends the core\n# here's we're using our dummy-filled ring widths as a response so that the spline will fit over the whole time period of interest\n# NOTE: for this to work with canopy class, we'll need to figure out what to do about dead trees \nm1 <- gamm(RW0 ~ s(Year, bs=\"cs\", k=3, by=TreeID) + spp + dbh, random=list(site=~1, PlotID=~1), data=ring.data, na.action=na.omit)\n\n# Saving the GAMM From above so we can load it without having to refit it\nsave(m1, file=\"GapFilling_gamm_valles_02.2015.rData\")\n\n# This isn't a great way of doing it, but it'll let you see the splines for each of the cores\npar(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)\nplot(m1$gam)\n\nring.data$RW.modeled <- predict(m1, ring.data)\nsummary(ring.data)\n\n# Getting rid of negative ring width because they're impossible --> replacing with 0 to help with later\nring.data$RW.modeled <- ifelse(ring.data$RW.modeled < 0, 0, ring.data$RW.modeled)\nsummary(ring.data)\n\n# VERY rough graphing of the modeled rings we will use to fill the data\npar(new=F, mfrow=c(1,1), mar=c(5,5,0,0)+0.1)\nfor(i in unique(ring.data$TreeID)){\n\tplot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type=\"l\", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))\n\tpar(new=T)\n}\nfor(i in unique(ring.data$TreeID)){\n\tplot(RW.modeled ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type=\"p\", cex=0.4, pch=19, col=\"red\", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T), ylab=\"\")\n\tpar(new=T)\n}\n# for(i in unique(ring.data$TreeID)){\n\t# plot(RW.m1b ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type=\"p\", cex=0.5, pch=19, col=\"blue\", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))\n\t# par(new=T)\n# }\npar(new=F)\n\nplot(RW.modeled ~ RW, pch=19, xlim=c(0,1), ylim=c(0,1), data=ring.data)\nabline(a=0, b=1, col=\"red\")\n\n\n############\n# Creating a data frame with just predicted\npredict0 <- ring.data[,c(\"TreeID\", \"Year\", \"RW.modeled\")]\npredict0$Year <- as.factor(predict0$Year)\nsummary(predict0)\n\ntrees.predict <- recast(predict0, Year ~ TreeID)\n#summary(trees.predict)\ntrees.predict [1:10,1:10]\ntrees.predict [(length(trees.predict [,1])-10):length(trees.predict[,1]),1:10]\n\nwrite.csv(trees.predict, \"Trees_RW_modeled.csv\", row.names=F)\n\n############\n# Creating a data frame with just observed\ntrees.obs <- ring.data[,c(\"TreeID\", \"Year\", \"RW\")]\ntrees.obs $Year <- as.factor(trees.obs $Year)\nsummary(trees.obs)\n\ntrees.obs <- recast(trees.obs, Year ~ TreeID)\n#summary(trees.obs)\nhead(trees.obs[,1:10])\ntrees.obs[(length(trees.obs[,1])-10):length(trees.obs[,1]),1:10]\n\nsummary(trees.obs)\nwrite.csv(trees.obs, \"Trees_RW_measured.csv\", row.names=F)\n\n####################################################\n# replacing missing ring widths with predicted values (positive or 0)\n####################################################\ntrees.obs <- read.csv(\"Trees_RW_measured.csv\", row.names=1)\ntrees.predict <- read.csv(\"Trees_RW_modeled.csv\", row.names=1)\n\n# replacing observed with predicted where I don't have ring measurements\ntrees.gapfill <- trees.obs\n\nfor(j in 1:ncol(trees.gapfill)){\n\ttrees.gapfill[is.na(trees.gapfill[,j]),j] <- trees.predict[is.na(trees.gapfill[,j]),j]\n\t}\n\n#min(trees.gapfill[,2:ncol(trees.gapfill)])\ntrees.gapfill[1:10,1:10]\ntrees.gapfill[(length(trees.gapfill[,1])-20):length(trees.gapfill[,1]),1:10]\nmin(trees.gapfill)\n\n# checking dimensions, adding year row names\ndim(trees.gapfill)\n\nwrite.csv(trees.gapfill, \"Trees_RW_gapfilled.csv\", row.names=T)\n\n\n\n\n\n\n\n\n\n# --------------------------------------------------------------------------------\n# --------------------------------------------------------------------------------\n# Haven't been through the rest of this script yet!\n# --------------------------------------------------------------------------------\n# --------------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n###################################\n# Reconstructing Basal Area working from the outside in\n###################################\n\n# Reading in core data\ncores.data <- read.csv(\"Cores_Data_Measured.csv\")\ncores.data$Plot <- as.factor(cores.data$Plot)\ncores.data$Tree <- as.factor(cores.data$Tree)\nsummary(cores.data)\n\n\n\n##############\n# Actual BA reconstruction\ncores.ba.cum <- as.data.frame(array(dim=dim(trees.gapfill)))\nnames(cores.ba.cum) <- names(trees.gapfill)\nrownames(cores.ba.cum) <- rownames(trees.gapfill)\n\n# original to try to do without resorting\n#for(j in seq_along(trees.gapfill)){\n#\ttest[length(trees.gapfill[,j]),j] <- pi*((cores.data[cores.data$TreeID==names(trees.gapfill[j]),\"DBH\"]*10)^2)\n#\tfor(i in 1:(length(test[,j])-1)){\n#\ttest[i,j] <- test[i-1,j] - trees.gapfill[i,j]\n#}\n#}\n\nfor(j in 1:ncol(trees.gapfill)){\n\t# inserting 2013 BA (pi*(DBH/2)^2) for FLT (sampled in 2013) & NA for everthing else\n\tcores.ba.cum[1,j] <- ifelse(substr(names(trees.gapfill[j]), 1, 3)==\"FLT\", \n\tpi*(((cores.data[cores.data$TreeID==names(trees.gapfill[j]),\"DBH\"]*10)/2)^2), NA)\n\t\n\t# calculating 2012 BA for FLT only\n\tcores.ba.cum[2,j] <- ifelse(substr(names(trees.gapfill[j]), 1, 3)==\"FLT\", \n\t cores.ba.cum[1,j] - trees.gapfill[1,j], # For FLT calculate BA by subtracting 2013\n\tpi*(((cores.data[cores.data$TreeID==names(trees.gapfill[j]),\"DBH\"]*10)/2)^2)) # for non-FLT, insert 2012 BA\n\t\n\t# subtracting BAI measurement from diamBAeter of previous year to get end-of-season BA \n\tfor(i in 3:(length(cores.ba.cum[,j]))){\n\tcores.ba.cum[i,j] <- ifelse(trees.gapfill[i,j]>0, cores.ba.cum[i-1,j] - trees.gapfill[i-1,j], 0) \n\t}\n\t}\n\n# checking the data frame: check to make sure numbers get smaller through time\n#summary(cores.ba.cum)\n#head(cores.ba.cum)\ndim(cores.ba.cum)\ncores.ba.cum[1:10,1:10]\ncores.ba.cum[103:113,1:10]\ncores.ba.cum[(length(cores.ba.cum[,1])-10):length(cores.ba.cum[,1]),1:10]\n\nmin(cores.ba.cum, na.rm=T)\n\n# Removing negative Basal Areas (become 0)\nfor(j in 1:ncol(cores.ba.cum)){\n\tfor(i in 1:(length(cores.ba.cum[,j]))){\n\tcores.ba.cum[i,j] <- ifelse(cores.ba.cum[i,j]>0, cores.ba.cum[i,j], 0)\n}\n}\n\ncores.ba.cum[1:10,1:10]\ncores.ba.cum[103:113,1:10]\n\nmin(cores.ba.cum, na.rm=T)\n\n\n#summary(cores.ba.cum)\nrow.names(cores.ba.cum)\n\nwrite.csv(cores.ba.cum, \"AllCores_BA_Cumulative_NoCorrection.csv\", row.names=T)\n\n########################################################################################################\n########################################################################################################\n# Calculating Pith\n########################################################################################################\n########################################################################################################\ncores.ba.cum <- read.csv(\"AllCores_BA_Cumulative_NoCorrection.csv\", row.names=1)\ncores.ba.cum[1:10,1:10]\ncores.ba.cum[103:113,1:10]\ncores.ba.cum[(length(cores.ba.cum[,1])-10):length(cores.ba.cum[,1]),1:10]\n\n# Reading in core data\ncores.data <- read.csv(\"Cores_Data_Measured.csv\")\ncores.data$Plot <- as.factor(cores.data$Plot)\ncores.data$Tree <- as.factor(cores.data$Tree)\nsummary(cores.data)\ndim(cores.data)\n\n# Extract last non-0 year (calculated Pith)\ncores.pith <- as.data.frame(array(dim=c(ncol(cores.ba.cum),2)))\ndim(cores.pith)\nnames(cores.pith) <- c(\"TreeID\", \"pith.calc\")\nsummary(cores.pith)\n\ncores.pith$TreeID <- as.factor(colnames(cores.ba.cum))\nsummary(cores.pith)\n\n# BAI-calculated pith year = outer year + 1 - number of non-NA values\n# NOTE: will need to change this when FLT gets added in\nfor(j in 1:ncol(cores.ba.cum)){\n\tcores.pith[cores.pith$TreeID==names(cores.ba.cum[j]),\"pith.calc\"] <- ifelse(substr(names(cores.ba.cum[j]), 1, 3)==\"FLT\",\n\t2014-sum(cores.ba.cum[,j]>0, na.rm=T), \n\t2013-sum(cores.ba.cum[,j]>0, na.rm=T))\n\t}\n\n# Finding the Basal Area at the innermost year\nfor(j in 1:ncol(cores.ba.cum)){\n\tcores.pith[cores.pith$TreeID==names(cores.ba.cum[j]),\"Inner.BA\"] <- cores.ba.cum[2014-cores.data[cores.data$TreeID==names(cores.ba.cum[j]),\"Inner\"],j]\n}\n\n\nsummary(cores.pith)\ncores.pith[is.na(cores.pith$Inner.BA),]\nhead(cores.pith)\nhead(data.cores)\ndim(cores.pith)\ndim(data.cores)\n\ncores.pith[,4:27] <- cores.data[,c(3:8,10:27)]\nsummary(cores.pith)\n\ncores.pith[1:10,]\ncores.pith[(length(cores.pith[,1])-10):length(cores.pith[,1]),]\n\nsummary(cores.pith)\n\n########################################################################################################\n# Acutal Pith Model\n########################################################################################################\ncores.ba.cum <- read.csv(\"AllCores_BA_Cumulative_NoCorrection.csv\", row.names=1)\ncores.ba.cum[1:10,1:10]\ncores.ba.cum[103:113,1:10]\ncores.ba.cum[(length(cores.ba.cum[,1])-10):length(cores.ba.cum[,1]),1:10]\n\ncores.pith <- read.csv(\"Establishment_AllCores.csv\")\ncores.pith$est.calc <- cores.pith$Pith.Yr - cores.pith$pith.calc\nsummary(cores.pith)\nhist(cores.pith$est.calc)\n\n\n# Visulalizing estimated (BA reconstruction) & observed pith\nplot(pith.calc ~ Pith.Yr, data=cores.pith, main=\"Modeled vs. Estmiated Pith\", pch=19)\n\n# Modeling pith year based on the 2012/2013 year DBH and the BA at the inner most year\nm.pith <- lme(Pith.Yr ~ pith.calc + DBH, data=cores.pith[!is.na(cores.pith$Inner.BA),], random=list(Site=~1, Trans=~1, PlotID=~1), na.action=na.omit)\nsummary(m.pith)\nm.pith.R2 <- r.squaredGLMM(m.pith)\nm.pith.R2 # R2m = 0.804291, R2c = 0.8357807\n\n# Modeling Pith based on above equation\ncores.pith$pith.modeled <- predict(m.pith, newdata=cores.pith)\nsummary(cores.pith)\n\n# Finding the Basal Area at the modeled pith\nfor(j in 1:ncol(cores.ba.cum)){\n\tcores.pith[cores.pith$TreeID==names(cores.ba.cum[j]),\"Pith.Mod.BA\"] <- cores.ba.cum[2014-cores.pith[cores.pith$TreeID==names(cores.ba.cum[j]),\"pith.modeled\"],j]\n}\nsummary(cores.pith)\n\n# looking at estimated - modeled \ncores.pith$est.mod <- cores.pith$Pith.Yr - cores.pith$pith.modeled\nsummary(cores.pith) # range of visual estimate & model: -15 - 5\n\nplot(Pith.Yr ~ pith.modeled, data=cores.pith, subset=Pith.Yr>1900)\n\n# double checking how model compares to Pith\nm.pith0 <- lm(Pith.Yr ~ pith.modeled, data=cores.pith, subset=Pith.Yr>1900)\nsummary(m.pith0) #0.8419\n\n\n\nsummary(cores.pith)\nhist(cores.pith$Pith.offset)\nhist(cores.pith$est.mod)\nhist(cores.pith$Inner.BA)\nhist(cores.pith[cores.pith$Inner.BA<10000, \"Inner.BA\"])\nhist(cores.pith[cores.pith$Inner.BA<1000, \"Inner.BA\"])\nhist(cores.pith$Pith.Mod.BA)\nhist(cores.pith[cores.pith$Pith.Mod.BA<10000, \"Pith.Mod.BA\"])\nplot(cores.pith$est.mod ~ cores.pith$Pith.offset)\nplot(cores.pith$Pith.Yr ~ cores.pith$pith.modeled)\n\nhist(cores.pith$Pith.offset)\n\n# NOTE: COULD ADD LAYER HERE WHERE WE ONLY USE PITH DATES FROM DATED TREES OR ALL TREES\n# If there's a pith estimate & offset is <= 10 OR modeled > inner, use core pith est\n# If there's a pith estimate AND ((offset is >10 years AND modeled !< inner) OR inner Basal Area > 5,000), average core & modeled\n# If no pith estimate AND modeled < inner, use modeled \n# IF no pith estimate AND modeled > inner, use inner\nfor(i in 1:length(cores.pith$Pith.Yr)){\ncores.pith$pith.use[i] <- ifelse(!is.na(cores.pith$Pith.Yr[i]) & (cores.pith$Pith.offset[i]<=10 |  cores.pith$Inner<cores.pith$pith.modeled), cores.pith$Pith.Yr[i], \n                                 ifelse(!is.na(cores.pith$Pith.Yr[i]) & cores.pith$Pith.offset[i]>10 & cores.pith$Inner[i] > cores.pith$pith.modeled[i], mean(cores.pith$Pith.Yr[i], cores.pith$pith.modeled[i]), \n                                 ifelse(is.na(cores.pith$Pith.Yr[i]) & cores.pith$Inner[i] >= cores.pith$pith.modeled[i], cores.pith$pith.modeled[i], cores.pith$Inner[i])))\n}\n\nsummary(cores.pith)\nsummary(cores.pith$pith.use)\n\nsum(!is.na(cores.pith$Pith.Yr) & (cores.pith$Pith.offset<=10 | cores.pith$Inner < cores.pith$pith.modeled)) # number of visual estimates used: 913\nsum(!is.na(cores.pith$Pith.Yr) & cores.pith$Pith.offset>10 & cores.pith$Inner > cores.pith$pith.modeled) # number of averaged used: 28\nsum(is.na(cores.pith$Pith.Yr) & cores.pith$Inner>=cores.pith$pith.modeled) # number of modeled pith used: 202\nsum(is.na(cores.pith$Pith.Yr) & cores.pith$Inner<cores.pith$pith.modeled) # had to go with inner year as best guess: 45\n\ndim(cores.pith)\n913 + 28 + 202 + 45\n\n\n# Finding the Basal Area at the Pith I'm using\nfor(j in 1:ncol(cores.ba.cum)){\n\tcores.pith[cores.pith$TreeID==names(cores.ba.cum[j]),\"Pith.Use.BA\"] <- cores.ba.cum[2014-cores.pith[cores.pith$TreeID==names(cores.ba.cum[j]),\"pith.use\"],j]\n}\n\n# converting BA to DBH\ncores.pith$pith.dbh <- sqrt(cores.pith$Pith.Use.BA/pi)*.1\n\nsummary(cores.pith$pith.dbh) # note, despite the range, most of the data goes to 0\nsummary(cores.pith[cores.pith$Pith==\"Y\", \"pith.dbh\"])\n\nhist(cores.pith$pith.dbh)\n\nwrite.csv(cores.pith, \"Establishment_AllCores.csv\", row.names=F)\n\n##################################################################################\n##################################################################################\n# Plotting establishment --> see separate script\n##################################################################################\n##################################################################################\n\n\n##################################################################################\n##################################################################################\n\n##################################################################################\n# Removing bai earlier than predicted pith date & replacing with 0 (important to ensure no decreases in average basal area through time)\n##################################################################################\n# reading in establishment data\ncores.pith <- read.csv(\"Establishment_AllCores.csv\")\nsummary(cores.pith)\n## Make sure no cores have missing Pith Estimates\n\n# if need to get rid of missing pith estimates\n#cores.pith2 <- cores.pith[!is.na(cores.pith$pith.use),]\n#summary(cores.pith2)\n#dim(cores.pith)\n\n# reading in calculated core data\ntrees.obs.mix <- read.csv(\"AllCores_BAI_meas_predicted.csv\", row.names=1)\n#summary(trees.obs.mix)\ntrees.obs.mix[1:10, 1:10]\ntrees.obs.mix[100:110, 1:10]\ntrees.obs.mix[200:210, 1:10]\ndim(trees.obs.mix)\n\nnames1 <- names(trees.obs.mix)\nnames2 <- unique(cores.pith$TreeID)\nlength(names1)\nlength(names2)\n\n\ncores.pith[cores.pith$TreeID==colnames(trees.obs.mix[\"BLDA101\"]),\"pith.use\"]\n\n\ndim(trees.obs.mix)\n\n# creating an object with the range of years\nyears <- row.names(trees.obs.mix)\n\n# trees.obs.filled = filled data with Pith Correction\n# A faster version with help from John\ntrees.obs.filled <- trees.obs.mix\nnrow(trees.obs.filled)\nnrow(trees.obs.mix)\n\ntrees.obs.filled[1:10, 1:10]\ntrees.obs.filled[100:110, 1:10]\ntrees.obs.filled[233:243, 1:10]\ntrees.obs.filled[(nrow(trees.obs.filled)-10):nrow(trees.obs.filled), 1:10]\n\n\nsummary(cores.pith)\n\nfor(j in 1:ncol(trees.obs.filled)){\n\t# create a value with pith year for each core (j)\n\ttemp.row <- 2015 - cores.pith[cores.pith$TreeID==colnames(trees.obs.filled[j]),\"pith.use\"]\n\tif(temp.row < nrow(trees.obs.filled)) \n\ttrees.obs.filled[temp.row:nrow(trees.obs.filled), j] <- 0 # 2015 means keep pith year)\n\t}\n\ntrees.obs.filled[1:10, 1:10]\ntrees.obs.filled[100:110, 1:10]\ntrees.obs.filled[(nrow(trees.obs.filled)-10):nrow(trees.obs.filled), 1:10]\nmin(trees.obs.filled, na.rm=T)\nsum(is.na(trees.obs.filled))\nsum(is.na(trees.obs.mix))\ndim(trees.obs.mix)\n\n#summary(trees.obs.filled)\nrow.names(trees.obs.filled)\n\nwrite.csv(trees.obs.filled, \"AllCores_BAI_filledtopith.csv\", row.names=T)\n\n#par(new=F)\n#for(j in seq_along(trees.obs.filled)){\n#\t\tplot(trees.obs.filled[,j] ~ as.numeric(row.names(trees.obs.filled[1])), xlim=range(as.numeric(row.names(trees.obs.filled[1]))), ylim=range(trees.obs.filled, na.rm=T), xlab=\"Year\", ylab=\"mm2\", type=\"l\", lwd=0.1)\n#\tpar(new=T)\n#}\n\n##################################################################################\n# Correcting BA calcuations\n##################################################################################\ncores.pith <- read.csv(\"Establishment_AllCores.csv\")\nsummary(cores.pith)\n## Make sure no cores have missing Pith Estimates\n\n# reading in calculated core data\ncores.ba.cum <- read.csv(\"AllCores_BA_Cumulative_NoCorrection.csv\", row.names=1)\n\ncores.ba.cum[1:10,1:10]\ncores.ba.cum[103:113,1:10]\ncores.ba.cum[(length(cores.ba.cum[,1])-10):length(cores.ba.cum[,1]),1:10]\n\n\nnames1 <- names(cores.ba.cum)\nnames2 <- unique(cores.pith$TreeID)\nlength(names1)\nlength(names2)\n\ndim(cores.ba.cum)\n\n# creating an object with the range of years\nyears <- row.names(cores.ba.cum)\n\n# cores.ba.corr = basal area data with Pith Correction\ncores.ba.corr <- cores.ba.cum\nfor(j in 1:ncol(cores.ba.corr)){\n\t# create a value with pith year for each core (j)\n\ttemp.row <- 2015 - cores.pith[cores.pith$TreeID==colnames(cores.ba.corr[j]),\"pith.use\"]\n\tif(temp.row < nrow(cores.ba.corr)) cores.ba.corr[temp.row:nrow(cores.ba.corr), j] <- 0 # 2015 means keep pith year)\n\t}\n\ncores.ba.corr[1:10, 1:10]\ncores.ba.corr[100:110, 1:10]\ncores.ba.corr[200:210, 1:10]\nmin(cores.ba.corr, na.rm=T)\nsum(is.na(cores.ba.corr))\nsum(is.na(cores.ba.cum))\ndim(cores.ba.corr)\n\n#summary(trees.obs.filled)\nrow.names(cores.ba.corr)\n\nwrite.csv(cores.ba.corr, \"AllCores_BA_Cumulative_PithCorrected1.csv\", row.names=T)\n\n# Plotting Basal Area through time\npar(new=F)\nfor(j in seq_along(cores.ba.corr)){\n\t\tplot(cores.ba.corr[,j] ~ as.numeric(row.names(cores.ba.corr[1])), xlim=range(as.numeric(row.names(cores.ba.corr[1]))), ylim=range(cores.ba.corr, na.rm=T), xlab=\"Year\", ylab=\"m2/Ha\", type=\"l\", lwd=0.1)\n\tpar(new=T)\n}\n\n##########################\n\n####################################################\n# Smoothing out cumulative Basal Area at Pith by averaging in-out and out-in calculations of BA\n####################################################\ncores.pith <- read.csv(\"Establishment_AllCores.csv\")\ncores.pith$est.calc <- cores.pith$Pith.Yr - cores.pith$pith.calc\nsummary(cores.pith$pith.dbh)\ncores.pith[is.na(cores.pith$pith.dbh),]\nhist(cores.pith$pith.use)\nhist(cores.pith$pith.dbh)\n\n# Subsetting all cores >2 cm DBH at pith\ncores.check <- cores.pith[cores.pith$pith.dbh>2,c (\"TreeID\",  \"Spp\", \"DBH\",  \"Inner\", \"Pith.Yr\", \"pith.calc\", \"est.calc\", \"pith.modeled\", \"pith.use\", \"pith.dbh\")]\ncores.check <- cores.check[!is.na(cores.check$pith.dbh),]\nsummary(cores.check)\ndim(cores.check)\ndim(cores.pith)\nnrow(cores.check)/nrow(cores.pith) # Proportion of cores with pith >2 CM DBH\nlength(cores.check[!is.na(cores.check$Pith.Yr),1]) # 188 trees have a pith estimate; only 85 are missing pith est\n\n##################\n# Looking at the distributions\npar(new=F)\nhist(cores.pith$pith.dbh, main=\"Basal Area at Pith, All Trees\")\nhist(cores.pith[cores.pith$pith.dbh>2, \"pith.dbh\"], main=\"\", xlab=\"DBH (cm)\")\nhist(cores.pith[cores.pith$pith.dbh<2, \"pith.dbh\"], main=\"\", xlab=\"DBH (cm)\")\n\nggplot(data=cores.pith) + q.blank + facet_grid(Site ~ .) + geom_histogram(aes(x=pith.dbh), binwidth=.5) + ggtitle(\"DBH at pith, all trees\") \nggplot(data=cores.pith[cores.pith$pith.dbh>=2 & !is.na(cores.pith$pith.dbh),]) + q.blank + facet_grid(Site ~ .) + geom_histogram(aes(x=pith.dbh), binwidth=.5) + ggtitle(\"DBH at pith, trees >= 2 cm dbh at pith\") \nggplot(data=cores.pith[cores.pith$pith.dbh<2 & !is.na(cores.pith$pith.dbh),]) + q.blank + facet_grid(Site ~ .) + geom_histogram(aes(x=pith.dbh), binwidth=.5) + ggtitle(\"DBH at pith, trees < 2 cm dbh at pith\") \n##################\ncores.ba.corr <- read.csv(\"AllCores_BA_Cumulative_PithCorrected1.csv\", row.names=1)\ncores.ba.corr[1:10, 1:10]\ncores.ba.corr[100:110, 1:10]\ncores.ba.corr[200:210, 1:10]\nmin(cores.ba.corr, na.rm=T)\n\n# Reading in BAI file that will be necessary for corrections\ntrees.obs.filled <- read.csv(\"AllCores_BAI_filledtopith.csv\", row.names=1)\ntrees.obs.filled[1:10, 1:10]\ntrees.obs.filled[100:110, 1:10]\ntrees.obs.filled[(nrow(trees.obs.filled)-10):nrow(trees.obs.filled), 1:10]\nmin(trees.obs.filled, na.rm=T)\nsum(is.na(trees.obs.filled))\n\n\n########################\n# Making data frame for new corrected data\n#cores.ba.corr2 <- as.data.frame(array(dim=dim(cores.ba.corr)))\n#row.names(cores.ba.corr2) <- cores.ba.corr$Year\n#names(cores.ba.corr2) <- names(cores.ba.corr)\n\n# making a data frame with only the trees that need to be fixed\ncores.ba.corr2 <- as.data.frame(array(dim=c(nrow(cores.ba.corr), nrow(cores.check))))\nrow.names(cores.ba.corr2) <- row.names(cores.ba.corr)\nnames(cores.ba.corr2) <- unique(cores.check$TreeID)\ndim(cores.ba.corr2)\ndim(cores.ba.corr)\n\ncores.ba.corr2[1:10, 1:10]\ncores.ba.corr2[100:110, 1:10]\ncores.ba.corr2[200:210, 1:10]\nnames(cores.ba.corr2)\n#for(j in 1:ncol(cores.ba.corr2)){\n\t# if the core is not in the list that needs to be fixed, just punk it into the data frame\n#\tifelse(!(names(cores.ba.corr2[j]) %in% cores.check$TreeID),  cores.ba.corr2[,j] <- cores.ba.corr[,j], \n\nfor(j in unique(cores.check$TreeID)){\t\n\tpith.row <- ifelse(2014 - cores.check[cores.check$TreeID==j, \"pith.use\"] < nrow(cores.ba.corr2), 2014 - cores.check[cores.check$TreeID==j, \"pith.use\"], nrow(cores.ba.corr2))\n\n\tcores.ba.corr2[pith.row,j] <- trees.obs.filled[pith.row, j]\n\tcores.ba.corr2[(pith.row+1):nrow(cores.ba.corr2),j] <- 0\n\n\tfor(i in (pith.row-1):1){\n\t\tcores.ba.corr2[i,j] <- cores.ba.corr2[i+1, j] + trees.obs.filled[i,j]\n\t\t}\n\t}\n\ncores.ba.corr2[1:10, 1:10]\ncores.ba.corr2[100:110, 1:10]\ncores.ba.corr2[200:210, 1:10]\n\n######################\ncores.ba.corr3 <- as.data.frame(array(dim=dim(cores.ba.corr)))\nrow.names(cores.ba.corr3) <- row.names(cores.ba.corr)\nnames(cores.ba.corr3) <- names(cores.ba.corr)\n\ncores.ba.corr3[1:10, 1:10]\ncores.ba.corr3[100:110, 1:10]\ncores.ba.corr3[(nrow(cores.ba.corr3)-10):nrow(cores.ba.corr3), 1:10]\n\ndim(cores.ba.corr)\ndim(cores.ba.corr2)\n\n# Writing BA reconstructions that were fine\nfor(j in unique(names(cores.ba.corr))){\n\tif(!(j %in% cores.check$TreeID)) \n\tcores.ba.corr3[,j] <- cores.ba.corr[,j]\n\n# taking mean of in-out and original BA reconstructions\t\nfor(j in unique(names(cores.ba.corr2))){\n\tif(j %in% cores.check$TreeID)\n\ttemp.ba <- as.data.frame(cores.ba.corr[,j])\n\ttemp.ba[,2] <- cores.ba.corr2[,j]\n\tcores.ba.corr3[,j] <- rowMeans(temp.ba)\n}\n\n\ncores.ba.corr3[1:10, 1:10]\ncores.ba.corr3[100:110, 1:10]\ncores.ba.corr3[200:210, 1:10]\n\nwrite.csv(cores.ba.corr3, \"AllCores_BA_Cumulative_PithCorrected_Final.csv\", row.names=T)\n\n# Plotting Basal Area through time\npar(new=F)\nfor(j in seq_along(cores.ba.corr3)){\n\t\tplot(cores.ba.corr3[,j] ~ as.numeric(row.names(cores.ba.corr3[1])), xlim=range(as.numeric(row.names(cores.ba.corr3[1]))), ylim=range(cores.ba.corr3, na.rm=T), xlab=\"Year\", ylab=\"m2/Ha\", type=\"l\", lwd=0.1)\n\tpar(new=T)\n}\n\n\nfor(j in unique(cores.pith$TreeID)){\n\tcores.pith[cores.pith$TreeID==j, \"pith.ba.corr\"] <- cores.ba.corr3[2014-cores.pith[cores.pith$TreeID==j, \"pith.use\"], j]\n\t}\ncores.pith$pith.dbh.corr <- sqrt(cores.pith$pith.ba.corr/pi)*.1 \nsummary(cores.pith)\nhist(cores.pith$pith.dbh.corr)\nhist(cores.pith$pith.dbh)\n\ncores.check2 <- cores.pith[cores.pith$pith.dbh.corr>2,c (\"TreeID\",  \"Spp\", \"DBH\",  \"Inner\", \"Pith.Yr\", \"pith.calc\", \"est.calc\", \"pith.modeled\", \"pith.use\", \"pith.dbh.corr\")]\ndim(cores.check2)\ndim(cores.check)\nsummary(cores.check2)\nsummary(cores.check)\n\n## NOTE: Some cores still have relatively large DBH at pith, but it's a lot better; worst offenders are all pre-1900\n\n\n\n\n\n##################################################################################\n##################################################################################\n\n\n\n################################\n# Adjusting Tree BA to a per hectare basis\n# To do this: multiple tree BA by stand density (for each tree)\ncores.data <- read.csv(\"Cores_Data_Measured.csv\")\ncores.data$Plot <- as.factor(cores.data$Plot)\ncores.data$Tree <- as.factor(cores.data$Tree)\nsummary(cores.data)\n\ncores.ba.corr <- read.csv(\"AllCores_BA_Cumulative_PithCorrected_Final.csv\", row.names=1)\ncores.ba.corr[1:10, 1:10]\ncores.ba.corr[100:110, 1:10]\ncores.ba.corr[(nrow(cores.ba.corr)-10):nrow(cores.ba.corr), 1:10]\n\ncores.ba.ha <- cores.ba.corr\n# *.01 mm2 to cm2 *.0001\nfor(j in unique(names(cores.ba.ha))){\n\tdensity <- cores.data[cores.data$TreeID==j, \"Density.ha\"]\n\tcores.ba.ha[,j] <- cores.ba.ha[,j] * density * .000001 # coverts mm2 to m2/ha\n}\n\ncores.ba.ha[1:10,1:10]\n\nmin(cores.ba.ha, na.rm=T)\n\nwrite.csv(cores.ba.ha, \"AllCores_BA_Cumulative_PithCorrected_perHA.csv\", row.names=T)\n\n\n\n########################\ncores.ba.ha <- read.csv(\"AllCores_BA_Cumulative_PithCorrected_perHA.csv\", row.names=1)\ncores.ba.ha[1:10,1:10]\nmin(cores.ba.ha, na.rm=T)\n\n# Plotting Basal Area through time\npar(new=F)\nfor(j in seq_along(cores.ba.ha)){\n\t\tplot(cores.ba.ha[,j] ~ as.numeric(row.names(cores.ba.ha[1])), xlim=range(as.numeric(row.names(cores.ba.ha[1]))), ylim=range(cores.ba.ha, na.rm=T), xlab=\"Year\", ylab=\"m2/Ha\", type=\"l\", lwd=0.1)\n\tpar(new=T)\n}\n\n\n##################################################################################\n##################################################################################\n# Adjusting Tree BA to a per hectare basis\n# To do this: multiple tree BA by stand density (for each tree)\ncores.pith <- read.csv(\"Establishment_AllCores.csv\")\nsummary(cores.pith)\n\ncores.ba.corr <- read.csv(\"AllCores_BA_Cumulative_PithCorrected_Final.csv\", row.names=1)\ncores.ba.corr[1:10, 1:10]\ncores.ba.corr[100:110, 1:10]\ncores.ba.corr[(nrow(cores.ba.corr)-10):nrow(cores.ba.corr), 1:10]\n\n\nage.df <- data.frame(array(dim=dim(cores.ba.corr)))\nrow.names(age.df) <- row.names(cores.ba.corr)\nnames(age.df) <- names(cores.ba.corr)\n\nage.df[1:10, 1:10]\nage.df[100:110, 1:10]\nage.df[(nrow(age.df)-10):nrow(age.df), 1:10]\n\nfor(j in unique(names(age.df))){\n\tpith.row <- 2014-cores.pith[cores.pith$TreeID==j, \"pith.use\"]\n\t\n\tfor(i in pith.row:1){\n\t\tage.df[i,j] <- pith.row - i \n\t}\n\t}\n\n# replacing 2013 for non-FLT with NA\nfor(j in unique(names(age.df))){\n\tage.df[1,j] <- ifelse(substr(j, 1, 3)==\"FLT\", age.df[1,j], NA)\n\t}\n\n\n\nage.df[1:10, 1:10]\nage.df[100:110, 1:10]\nage.df[(nrow(age.df)-10):nrow(age.df), 1:10]\n\n\nwrite.csv(age.df, \"AllCores_Age.csv\", row.names=T)\n\n##################################################################################\n##################################################################################\n# Merging BAI & cumulative BA data sets\n\nring.data <- read.csv(\"Cores_FullData_AllYrs.csv\")\nring.data$Plot <- as.factor(ring.data$Plot)\nring.data$Tree <- as.factor(ring.data$Tree)\nsummary(ring.data)\ndim(ring.data)\n\nring.data <- ring.data[,c(1:21)]\nsummary(ring.data)\ndim(ring.data)\n\nage <- read.csv(\"AllCores_Age.csv\", row.names=1)\nage[1:10, 1:10]\nage.stack <- stack(age)\nnames(age.stack) <- c(\"Age\", \"TreeID\")\nage.stack$Year <- as.numeric(row.names(age))\nsummary(age.stack)\n\ncores.ba.ha <- read.csv(\"AllCores_BA_Cumulative_PithCorrected_perHA.csv\", row.names=1)\ncores.ba.ha[1:10, 1:10]\ncores.ba.ha.stack <- stack(cores.ba.ha)\nnames(cores.ba.ha.stack) <- c(\"BA.m2ha\", \"TreeID\")\ncores.ba.ha.stack$Year <- as.numeric(row.names(cores.ba.ha))\nsummary(cores.ba.ha.stack)\n\n\ntrees.obs.filled <- read.csv(\"AllCores_BAI_filledtopith.csv\", row.names=1)\n#summary(trees.obs.filled)\ntrees.obs.filled[1:10, 1:10]\ntrees.obs.stack <- stack(trees.obs.filled)\nnames(trees.obs.stack) <- c(\"BAI.filled\", \"TreeID\")\ntrees.obs.stack$Year <- as.numeric(row.names(trees.obs.filled))\nsummary(trees.obs.stack)\n\ncores.ba.corr <- read.csv(\"AllCores_BA_Cumulative_PithCorrected_Final.csv\", row.names=1)\n#summary(cores.ba.cum)\ncores.ba.corr[1:10, 1:10]\ncores.ba.tree <- stack(cores.ba.corr)\nnames(cores.ba.tree) <- c(\"BA.tree\", \"TreeID\")\ncores.ba.tree$Year <- as.numeric(row.names(cores.ba.corr))\nsummary(cores.ba.tree)\n\nring.data1 <- merge(ring.data, age.stack, all.x=T)\nsummary(ring.data1)\ndim(ring.data1)\ndim(ring.data)\n\nring.data2 <- merge(ring.data1, cores.ba.ha.stack, all.x=T)\nsummary(ring.data2)\ndim(ring.data2)\ndim(ring.data1)\n\nring.data3 <- merge(ring.data2, trees.obs.stack, all.x=T)\nsummary(ring.data3)\ndim(ring.data3)\ndim(ring.data2)\n\nring.data4 <- merge(ring.data3, cores.ba.tree, all.x=T)\nsummary(ring.data4)\ndim(ring.data4)\ndim(ring.data3)\n\n# Adding Tree pres/abs\nring.data4$Stems <- ifelse(ring.data4$BAI.filled>0 & !(is.na(ring.data4$BAI.filled)), 1, 0)\nsummary(ring.data4)\n\n# Adding tree density per HA\nplot.data <- read.csv(\"PlotData.csv\")\nplot.data$plot <- as.factor(plot.data$plot)\nsummary(plot.data)\n\nfor(j in unique(plot.data$plotID)){\n\tplot.area <- plot.data[plot.data$plotID==j, \"plot.canopy.area\"]\n\tring.data4[ring.data4$PlotID==j,\"Density.Ha\"] <- ring.data4[ring.data4$PlotID==j,\"Stems\"]/plot.area * 10000\n}\n\nsummary(ring.data4)\n\nwrite.csv(ring.data4, \"Cores_FullData2_AllYrs.csv\", row.names=F)\n\nring.data <- read.csv(\"Cores_FullData2_AllYrs.csv\")\nring.data$Plot <- as.factor(ring.data$Plot)\nring.data$Tree <- as.factor(ring.data$Tree)\nsummary(ring.data)\n\n##################################################################################\n# see next script for reconstructing basal area of trees with no samples \n##################################################################################\n",
    "created" : 1423750620948.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3998937426",
    "id" : "4DE0E262",
    "lastKnownWriteTime" : 1423841078,
    "path" : "~/PhD/Carbon Research/Tree-rings-to-biomass/Uncertainty_analysis/christy_gapfilling.R",
    "project_path" : "christy_gapfilling.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}