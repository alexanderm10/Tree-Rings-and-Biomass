{
    "contents" : "##################################################################################\n## Basic Components necessary for data management for doing dendro modelling\n##################################################################################\n\n# clear memory\nrm(list=ls())\n\n# importing libraries\nlibrary(dplR)\nlibrary(lattice)\n\n# Getting Libraries\nlibrary(reshape)\nlibrary(car)\nlibrary(mgcv)\nlibrary(nlme)\nlibrary(lmeSplines)\n#library(lme4)\nlibrary(splines)\nlibrary(MASS)\nlibrary(MuMIn)\nlibrary(ggplot2)\nlibrary(grid)\nse <- function(x){\n\tsd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}\n\nq.blank <- theme(axis.line=element_line(color=\"black\", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color=\"black\", size=14, face=\"bold\"), axis.text.y=element_text(color=\"black\", size=12, face=\"bold\"), axis.title.x=element_text(face=\"bold\", size=14),  axis.title.y=element_text(face=\"bold\", size=14))\n\n\n#################################################################################################\n# STEP 1: Gap-filling measured trees\n# STEP 1b: Pith-correction in measured trees (useful for stand dynamics; won't do unless you ask for it)\n# STEP 2: Gap-filling missing trees\n#\n# BIG SELLING POINT OF THIS APPROACH: we can quantify different levels of uncertainty & variability\n# Caveats: fitting the initial GAMM is very time-intensive (it may take hours with your full data) because current form fits a spline to each tree in a mixed model framework\n\n#################################################################################################\n# Previous workflow\n# 1) Read in RWL, QA/QC\n# 3) Aggregate to tree (factoring in whether cores were dated) level & decide if an entire tree is dated or not -- WRITE THIS AS A FILE!\n# 4) Stack RWL & Merge with metadata (becomes \"ring.data\" or named equivalent)\n\n# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns\nring.data <- read.csv(\"TreeRWL_AllSites_stacked.csv\")\nring.data$Tree <- as.factor(ring.data$Tree) \nsummary(ring.data)\n\n# Tree Data\ntree.data <- read.csv(\"TreeData.csv\")\nsummary(tree.data)\n\n# Site Data (for year cored) \nSite.data <- read.csv(\"raw input files/DOE_plus_valles.csv\", na.strings=\"\")\nSite.data$Year.sample <- as.numeric(substr(Site.data$date.sample,7,10))\nsummary(Site.data)\n\n# merging in the year sampled into the tree data & calculating age\ntree.data <- merge(tree.data, Site.data[,c(\"PlotID\", \"Year.sample\")], all.x=T, all.y=F)\ntree.data$PlotID\ntree.data$Age <- tree.data$Year.sample - tree.data$Pith\nsummary(tree.data)\n\n# We're going to run 2 sets of fillin models:\n# 1) Model based on only DATED trees (m1d)\n# 2) Model based on both DATED and UNDATED trees (m1u)\n\ntrees.dated <- ring.data[ring.data$Dated==\"Y\",\"TreeID\"]\n\n# using the gamm allows us to fit a smoothing spline to each tree, which allows us to basically gapfill taking into account unique tree temporal trends\n#\tcurrent spline parameter: shrinkage version of cubic spline with 3 knots (stiff CR spline)\n#\twhen we fit a generalized version for missing trees, we'll have to decide what to fit it to instead of TreeID; I think probably species|plot\n# m1 <- gamm(RW ~ s(Year, bs=\"cs\", k=3) + species + DBH..cm., random=list(Site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)\n\n# ----------------------------------------------------------------\n# IDEAL MODEL FORM (it won't work for many reasons)\n#\t-- won't predict outside range of years observed on each core\n#\t-- end up with singularity issues\n#\t-- would take FOREVER to fit even if it did work\n# m1d <- gamm(RW ~ s(Year, bs=\"cs\", k=3, by=TreeID) + species*DBH..cm.*canopy.class, random=list(Site=~1, PlotID=~1, TreeID=~1), data=trees.dated.full, na.action=na.omit)\n# ----------------------------------------------------------------\n\n\n# ----------------------------------------------------------------\n# The spline doesn't fit outside the range of observed values, so we need to give it a \"null\" guess\n# As a very very rough guess right now, filling missing with the measurement from the oldest ring\n# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)\n# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?\n\n# ---------------------------------------\n# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)\n# ---------------------------------------\n# What we need: core summary data (DBH..cm., estimated pith date)\n\n# Ignoring all the Sites we don't have and doing some exploratory graphing\ntree.data2 <- tree.data[tree.data$PlotID %in% unique(ring.data$PlotID),]\nsummary(tree.data2)\n\n# Need to remove species for which we have no pith estimates for the time being\nSpecies.pith <- unique(tree.data2[!is.na(tree.data2$Pith), \"Species\"])\ntree.data3 <- tree.data2[tree.data2$Species %in%  Species.pith,]\nsummary(tree.data3)\n\nqplot(DBH..cm., Age, color=Species, data=tree.data3) + facet_wrap(~Species) +\n\tstat_smooth(method=\"lm\", alpha=0.5, size=1.5) +\n\ttheme_bw()\n\n\n# Making a very basic linear model looking at Site-specific species-DBH..cm.-age relationships\ndbh.age <- lm(Age ~ Species*DBH..cm.*Site-1, data=tree.data3)\nsummary(dbh.age)\nsummary(dbh.age)$r.squared # Note, this very basic model works pretty well!\n\n# Using the prediction interval to get us a higher upper bound\nage.pi <- predict(dbh.age, newdata=tree.data3, interval=\"predict\")\nsummary(age.pi)\ndim(age.pi); dim(tree.data3) # Making sure we didn't lose any rows along the way\n\ntree.data3 <- cbind(tree.data3, age.pi)\nsummary(tree.data3)\n\n# Setting the filling window to the upper p.i. limit\ntree.data3$fill.year <- ifelse(is.na(tree.data3$Pith), tree.data3$Year.sample-tree.data3$upr, tree.data3$Pith)\nsummary(tree.data3)\n\n\n# Merging this back into a data frame that contains info for all the trees we're modeling right now\ntree.data.model <- merge(tree.data3, tree.data2, all.x=T, all.y=T)\nsummary(tree.data.model)\n\n#--------------------- \n# QUESTION: what to do about the species with no pith estimates?\n#\tFor now, I'm just going to do a species-naive fit within each plot\n#--------------------- \ndbh.age.plot <- lm(Age ~ DBH..cm.*PlotID-1, data=tree.data.model)\nsummary(dbh.age.plot) \n\nage.pi.plot <- predict(dbh.age.plot, newdata= tree.data.model, interval=\"predict\")\nsummary(age.pi.plot)\ndim(age.pi.plot); dim(tree.data.model)\n\nsummary(tree.data.model)\n# Filling missing fill.year with one caluclated form age.pi.plot fill \ntree.data.model[is.na(tree.data.model$fill.year),\"fill.year\"] <- tree.data.model[is.na(tree.data.model$fill.year),\"Year.sample\"] - age.pi.plot[which(is.na(tree.data.model$fill.year)),3]\nsummary(tree.data.model)\n#--------------------- \n# ---------------------------------------\n\n# ---------------------------------------\n# ORIGINAL USAGE: Provide dummy variable\n# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?\n#\t\tQUESTION: What dummy value do we want to give it?\n#\t\t\tFor now, I'm going to do the mean of the last decade\n# ---------------------------------------\n# summary(ring.data)\n\n# ring.data$RW0 <- ring.data$RW # Making a column of dummy-filled ring widths\n# for(i in unique(ring.data$TreeID)){\n\t# #------------------------------\n\t# #year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)\n\t# #year.min = the oldest year measured\n\t# #rw.fill = the dummy ring width to feed the model; right now this is for the last measured decade \n\t# #\t\t\t-- (yr.min + 10) means the 10 years following year.min (\n\t# #\t\t\t-- e.g. if min year = 1950, we'll fill with the mean value from 1950:1960\n\t# #------------------------------\n\t# yr.fill <- tree.data.model[tree.data.model$TreeID==i,\"fill.year\"]\n\t# yr.min <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), \"Year\"])\n\t# rw.fill <- mean(ring.data[ring.data$TreeID==i & ring.data$Year>=yr.min & ring.data$Year<=(yr.min+10), \"RW\"],na.rm=T)\n\t# #------------------------------\n\n\t# #------------------------------\n\t# # The actual insertion of the dummy fil value into the fill range\n\t# #------------------------------\n\t# ring.data[ring.data$TreeID==i & is.na(ring.data$RW) & ring.data$Year>=yr.fill, \"RW0\"] <- rw.fill\n\t# #------------------------------\n# }\n# summary(ring.data)\n# # ---------------------------------------\n\n# ---------------------------------------\n# New Usage: delete NAs for years way outside what we think we should be fitting\n# 2b) I still don't think we want to be fi\n# ---------------------------------------\nsummary(tree.data.model)\nsummary(ring.data)\ndim(ring.data)\n\nfor(i in unique(ring.data$TreeID)){\n\t#------------------------------\n\t#year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)\n\t#------------------------------\n\tyr.fill <- tree.data.model[tree.data.model$TreeID==i,\"fill.year\"]\n\t#------------------------------\n\n\t#------------------------------\n\t# The actual insertion of the dummy fil value into the fill range\n\t#------------------------------\n\tring.data <- ring.data[!(ring.data$TreeID==i & ring.data$Year<yr.fill),]\n\t#------------------------------\n}\nsummary(ring.data)\ndim(ring.data)\n# ---------------------------------------\n# ----------------------------------------------------------------\n\n# ################################################################\n# ################################################################\n# RUNNING THE GAMM!!\n# ################################################################\n# ################################################################\n# A generalized additive mixed model (gamm) allows us to fit splines in a mixed model context\n# we can let these splines vary by tree which essentially detrends the core\n# here's we're using our dummy-filled ring widths as a response so that the spline will fit over the whole time period of interest\n# NOTE: for this to work with canopy class, we'll need to figure out what to do about dead trees \n# NOTE: Right now this is set up for each Site separately.  If you want to borrow strength from other Sites to help gap fill certain species, run them together\n# ################################################################\n\n# ----------------------------------------------------------------\n# Gapfilling trees for which we have at least some measurements\n# ----------------------------------------------------------------\n# ---------------------------------------\n# Morgan Monroe Forest\n# ---------------------------------------\nring.data.mmf <- ring.data[substr(ring.data$PlotID,1,2)==\"MM\",]\nring.data.mmf <- droplevels(ring.data.mmf) \n# Note: the log link with the gaussian family to prevent fitting negative values requires that you can't actually have 0 growth so we're going to make it really really small instead\nring.data.mmf$RW <- ifelse(ring.data.mmf$RW==0, 1e-6, ring.data.mmf$RW)\nsummary(ring.data.mmf)\n\n\ngamm.mmf <- gamm(log(RW) ~ s(Year, bs=\"cs\", k=3, by=TreeID) + DBH..cm., random=list(Species=~1, Site=~1, PlotID=~1), data= ring.data.mmf, na.action=na.omit)\n\n# Saving the GAMM From above so we can load it without having to refit it\nsave(gamm.mmf, file=\"GapFilling_gamm_mmf_02.2015.rData\")\n\n# # This isn't a great way of doing it, but it'll let you see the splines for each of the cores\n# par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)\n# plot(gamm.mmf$gam)\n\n# Making Predicted ring widths\nring.data.mmf$RW.modeled <- exp(predict(gamm.mmf, ring.data.mmf))\nsummary(ring.data.mmf)\nwrite.csv(ring.data.mmf, \"GapFilling_MMF_Measured_Filled.csv\", row.names=F)\n\n# Graphing of the modeled rings we will use to fill the data (note this isn't truncating ones that are past where we think pith actually is)\npdf(\"gamm_gapfill_mmf.pdf\", height=7.5, width=10)\nggplot() + facet_wrap(~Species) +\n\tgeom_path(aes(x=Year, y=RW, color=Species), data=ring.data.mmf, size=0.5) +\n\tgeom_point(aes(x=Year, y=RW.modeled), ring.data.mmf[is.na(ring.data.mmf$RW),], size=0.5) +\n\tscale_y_continuous(limits=c(0,1.25)) +\n\ttheme_bw()\ndev.off()\n# ---------------------------------------\n\n\n# ---------------------------------------\n# Valles Caldera (Upper & Lower modeled together)\n# ---------------------------------------\nring.data.valles <- ring.data[substr(ring.data$PlotID,1,2)==\"VL\" | substr(ring.data$PlotID,1,2)==\"VU\",]\nring.data.valles <- droplevels(ring.data.valles)\nring.data.valles$RW <- ifelse(ring.data.valles$RW==0, 1e-6, ring.data.valles$RW)\nsummary(ring.data.valles)\n\ngamm.valles <- gamm(log(RW) ~ s(Year, bs=\"cs\", k=3, by=TreeID) + DBH..cm., random=list(Species=~1, Site=~1, PlotID=~1), data= ring.data.valles, na.action=na.omit)\n\n# Saving the GAMM From above so we can load it without having to refit it\nsave(gamm.valles, file=\"GapFilling_gamm_valles_02.2015.rData\")\n\n# # This isn't a great way of doing it, but it'll let you see the splines for each of the cores\n# par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)\n# plot(gamm.valles$gam)\n\nring.data.valles$RW.modeled <- exp(predict(gamm.valles, ring.data.valles))\nsummary(ring.data.valles)\nwrite.csv(ring.data.valles, \"GapFilling_Valles_Measured_Filled.csv\", row.names=F)\n\n# VERY rough graphing of the modeled rings we will use to fill the data\npdf(\"gamm_gapfill_valles.pdf\", height=7.5, width=10)\nggplot() + facet_grid(Species~Site) +\n\tgeom_path(aes(x=Year, y=RW, color=Species), data=ring.data.valles, size=0.25) +\n\tgeom_point(aes(x=Year, y=RW.modeled), ring.data.valles[is.na(ring.data.valles$RW),], size=0.5) +\n\tscale_y_continuous(limits=c(0,1.25)) +\n\ttheme_bw()\ndev.off()\n# ---------------------------------------\n# ----------------------------------------------------------------\n\n\n# ################################################################\n# ################################################################\n\n# ----------------------------------------------------------------\n# Gapfilling trees that we have no measurements for (punky, dead...)\n# ----------------------------------------------------------------\n# Going to gapfill live trees only (won't try and figure out when dead trees welcome)\n# We can't fit a TreeID spline for trees we don't have any measurements for, so we need something more generalizeable\n#\tThe best options are probably species or PlotID; Ross votes PlotID because of variation in the Valles\n# ----------------------------------------------------------------\n# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns\nring.data <- read.csv(\"TreeRWL_AllSites_stacked.csv\")\nring.data$tree <- as.factor(ring.data$tree) \nsummary(ring.data)\n\n# Tree Data\ntree.data <- read.csv(\"TreeData.csv\")\nsummary(tree.data)\n\n# Site Data (for year cored) \nSite.data <- read.csv(\"input files/DOE_plus_valles.csv\", na.strings=\"\")\nSite.data$Year.sample <- as.numeric(substr(Site.data$date.sample,7,10))\nsummary(Site.data)\n\n# merging in the year sampled into the tree data & calculating age\ntree.data <- merge(tree.data, Site.data[,c(\"PlotID\", \"Year.sample\")], all.x=T, all.y=F)\ntree.data$Age <- tree.data$Year.sample - tree.data$Pith\nsummary(tree.data)\n\n# ---------------------------------------\n# ---------------------------------------\n# NOTE: Re-run the size-age section above so that we can create a data frame of NAs to fill for the missing trees\n# ---------------------------------------\n# ---------------------------------------\n\n# creating a data frame of blank ring widths to fill with the gamm\nsummary(tree.data.model)\ntrees.missing <- tree.data.model[!(tree.data.model$TreeID %in% unique(ring.data$TreeID)), c(\"Species\", \"Site\", \"PlotID\", \"TreeID\", \"DBH..cm.\")]\nsummary(trees.missing)# 29 missing trees: 4 from MM, 22 VUF, 3 VLF\ndim(trees.missing)\n\n# Creating a vector of years and dummy ring widths we're going to want to fill\nrw.dummy <- data.frame(Year=min(ring.data$Year):max(ring.data$Year), RW=NA)\nsummary(rw.dummy)\n\ntrees.missing <- merge(trees.missing, rw.dummy, all.x=T, all.y=T)\nsummary(trees.missing)\n\n# ---------------------------------------\n# delete NAs for years way outside what we think we should be fitting\n# ---------------------------------------\nsummary(tree.data.model)\nsummary(trees.missing)\ndim(trees.missing)\n\nfor(i in unique(trees.missing$TreeID)){\n\t#------------------------------\n\t#year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)\n\t#------------------------------\n\tyr.fill <- tree.data.model[tree.data.model$TreeID==i,\"fill.year\"]\n\t#------------------------------\n\n\t#------------------------------\n\t# The actual insertion of the dummy fil value into the fill range\n\t#------------------------------\n\ttrees.missing <- trees.missing[!(trees.missing$TreeID==i & trees.missing$Year<yr.fill),]\n\t#------------------------------\n}\nsummary(trees.missing)\n\n# ----------------------------------------------------------------\n# Creating a gamm for missing trees\n#\tBecause we don't have any ring measurements for missing trees, we can't use a TreeID spline (because we can't predict what we can't fit)\n# \tAfter talking with Ross, we decided to fit the spline by plot, which should get us the general plot dynamics and the hierarchical effects should help fill in the species; The fixed DBH..cm. effect will also help adjust growth based on size\n# ----------------------------------------------------------------\n# We're just fitting a single model for all missing trees, but it'll be okay since we're doing the spline by PlotID and have the random effects structure; this is what we could do for everything if the spline fitting by tree didn't take so long\n\n# the log RW doesn't like 0s, so lets just make 0 really small\nring.data$RW <- ifelse(ring.data$RW==0, 1e-6, ring.data$RW)\nsummary(ring.data)\n\ngamm.missing <- gamm(log(RW) ~ s(Year, bs=\"cs\", k=3, by=PlotID) + DBH..cm., random=list(Species=~1, Site=~1, PlotID=~1), data= ring.data, na.action=na.omit)\n\npar(mfrow=c(3,3))\nplot(gamm.missing$gam)\n\ntrees.missing$RW.modeled <- exp(predict(gamm.missing, trees.missing))\nsummary(trees.missing)\nwrite.csv(trees.missing, \"GapFilling_Missing_Filled.csv\", row.names=F)\n\n# ----------------------------------------------------------------\n\n##################################################################################\n# Create a gapfilled data set\n##################################################################################\n# ---------------------------------------\n# Data Formatting\n# ---------------------------------------\n# putting the Sites back into 1 file\nring.data.valles <- read.csv(\"GapFilling_Valles_Measured_Filled.csv\")\nring.data.mmf <- read.csv(\"GapFilling_MMF_Measured_Filled.csv\")\nring.data.missing <- read.csv(\"GapFilling_Missing_Filled.csv\")\n\ndim(ring.data.valles); dim(ring.data.mmf)\nring.data <- rbind(ring.data.valles, ring.data.mmf)\nring.data <- merge(ring.data, ring.data.missing, all.x=T, all.y=T)\n\n# putting the modeled data where there are no ring widths (will cause negative DBH..cm.)\nring.data$RW.gapfilled <- ifelse(is.na(ring.data$RW), ring.data$RW.modeled, ring.data$RW)\nsummary(ring.data)\n\n# making a data frame with trees as columns and years as ros\nring.data$Year <- as.factor(ring.data$Year)\ntrees.gapfilled <- recast(ring.data[,c(\"Year\", \"TreeID\", \"RW.gapfilled\")], Year ~ TreeID)\nsummary(trees.gapfilled)\n\nrow.names(trees.gapfilled) <- trees.gapfilled$Year\ntrees.gapfilled <- trees.gapfilled[,2:ncol(trees.gapfilled)]\ntrees.gapfilled[(nrow(trees.gapfilled)-10):nrow(trees.gapfilled), 1:10]\n# ---------------------------------------\n\n\n##################################################################################\n# DBH Reconstruction\n##################################################################################\n\n# ---------------------------------------\n# DBH..cm. Reconstruction\n# ---------------------------------------\n# Tree Data\ntree.data <- read.csv(\"TreeData.csv\")\nsummary(tree.data)\n\n# Site Data (for year cored) \nSite.data <- read.csv(\"input files/DOE_plus_valles.csv\", na.strings=\"\")\nSite.data$Year.sample <- as.numeric(substr(Site.data$date.sample,7,10))\nsummary(Site.data)\n\n# merging in the year sampled into the tree data & calculating age\ntree.data <- merge(tree.data, Site.data[,c(\"PlotID\", \"Year.sample\")], all.x=T, all.y=F)\ntree.data$Age <- tree.data$Year.sample - tree.data$Pith\nsummary(tree.data)\n\ncore.data <- read.csv(\"Core_data_DOE_summer_2014.csv\", na.strings=c(\"\", \"NA\", \"#VALUE!\", \"*\"), header=T)\n#adding a column include which plot at the Site the trees belong to\nnames(core.data)\ncore.data$plot <- substr(core.data$plot.id, 3, 3)\ncore.data$plot <- as.factor(core.data$plot)\nsummary(core.data)\n\n# Ordering the data\ntrees.gapfilled <- trees.gapfilled[order(row.names(trees.gapfilled), decreasing=T),order(names(trees.gapfilled))]\ntrees.gapfilled[1:10, 1:10]\ntrees.gapfilled[1:10, (ncol(trees.gapfilled)-10):ncol(trees.gapfilled)]\n\ndbh.recon <- trees.gapfilled\ntrees.check <- vector() # trees with negative DBH..cm.\nfor(j in names(dbh.recon)){\n\n\t# Step 1: Replace filled years beyond the year in which a tree was sampled with NA (both trees.gapfilled & DBH..cm. recon); \n\t# \tGapfilled: filling the years where I changed 0 to 1e-6 back to 0\n\t#\tDBH..cm.recon: fill year of sample with DBH..cm. when sampled\n\ttrees.gapfilled[as.numeric(row.names(trees.gapfilled))>tree.data[tree.data$TreeID==j, \"Year.sample\"],j] <- NA\n\ttrees.gapfilled[,j] <- ifelse(trees.gapfilled[,j]==1e-6, 0, trees.gapfilled[,j])\n\n\tdbh.recon[as.numeric(row.names(dbh.recon))>tree.data[tree.data$TreeID==j, \"Year.sample\"],j] <- NA\n\tdbh.recon[as.numeric(row.names(dbh.recon))==tree.data[tree.data$TreeID==j, \"Year.sample\"],j] <- tree.data[tree.data$TreeID==j, \"DBH..cm.\"]\n\t\n\t# Doing the DBH..cm. reconstruction\t\n\tfor(i in 2:(length(dbh.recon[,j]))){\n\t\tdbh.recon[i,j] <- ifelse(!is.na(trees.gapfilled[i-1,j]), dbh.recon[i-1,j] - trees.gapfilled[i-1,j]*2, dbh.recon[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.\n\t}\n\t\n\t# Get rid of DBH..cm. past the guestimated pith dates -- both DBH..cm. recon & gapfilled\n\tif(!is.na(tree.data[tree.data$TreeID==j, \"Pith\"])){\n\t\tDBH..cm..recon[as.numeric(row.names(DBH..cm..recon))<tree.data[tree.data$TreeID==j, \"Pith\"],j] <- NA\n\t\ttrees.gapfilled[as.numeric(row.names(trees.gapfilled))<tree.data[tree.data$TreeID==j, \"Pith\"],j] <- NA\n\t} else \n\tif(is.na(tree.data[tree.data$TreeID==j, \"Pith\"])){ # Get rid of negative modeled DBH..cm.\n\t\tdbh.recon[,j] <- ifelse(dbh.recon[,j]<0, NA, dbh.recon[,j]) \n\t\ttrees.gapfilled[,j] <- ifelse(dbh.recon[,j]<0, NA, trees.gapfilled[,j]) \t\t\n\t}\n\t# also getting rid of these rings in the stacked ring data too\n\tyears.na <- row.names(trees.gapfilled)[which(is.na(trees.gapfilled[,j]))]\n\tring.data[ring.data$TreeID==j & ring.data$Year %in% years.na,\"RW.gapfilled\"] <- NA\n\n\tif(min(DBH..cm..recon[,j], na.rm=T)<0) trees.check <- c(trees.check, j)\n}\nDBH..cm..recon[1:20, 1:10]\nDBH..cm..recon[1:20, (ncol(DBH..cm..recon)-20):ncol(DBH..cm..recon)]\nmin(DBH..cm..recon, na.rm=T)\ntrees.check\nsummary(DBH..cm..recon[,trees.check])\n\n# for trees with negative DBH..cm., working from the inside out\n\t# If a tree has a negative DBH..cm., we're just going to add from the inside out (at time )\nfor(j in trees.check){\n\tif(min(DBH..cm..recon[,j], na.rm=T)<0){\n\t\tDBH..cm..recon[,j] <- trees.gapfilled[,j]\n\t\tfor(i in (nrow(DBH..cm..recon)-1):1){\n\t\t\tDBH..cm..recon[i,j] <- sum(DBH..cm..recon[i+1, j], trees.gapfilled[i,j]*2, na.rm=T)\n\t\t\t}\n\t}\n}\nmin(DBH..cm..recon, na.rm=T)\nDBH..cm..recon[1:10,trees.check]\nsummary(DBH..cm..recon[, trees.check])\n#trees.gapfilled[, trees.check]\ntree.data[tree.data$TreeID %in% trees.check,]\n# ---------------------------------------\nwrite.csv(dbh.recon, \"GapFilling_DBHrecon_ALL.csv\", row.names=T)\nwrite.csv(trees.gapfilled, \"GapFilling_RingWidths_ALL.csv\", row.names=T)\n\nsummary(ring.data)\nwrite.csv(ring.data, \"TreeRWL_AllSites_stacked_gapfilled_ALL.csv\", row.names=F)\n\n##################################################################################\n# see next script for reconstructing basal area of trees with no samples \n##################################################################################\n",
    "created" : 1424707216424.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2966662518",
    "id" : "E32F5EC4",
    "lastKnownWriteTime" : 1424708988,
    "path" : "~/PhD/Carbon Research/Tree-Rings-and-Biomass/Uncertainty_analysis/christy_gapfilling.R",
    "project_path" : "christy_gapfilling.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}