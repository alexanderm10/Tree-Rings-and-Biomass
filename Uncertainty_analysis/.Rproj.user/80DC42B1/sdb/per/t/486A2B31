{
    "contents" : "library(dplR)\nse <- function(x){\n  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}\n\n\n#################################################################################################\n# Loading up .csv file that has meta data and RWL files for ring widths\n# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother\n#################################################################################################\n\n#load in core details data sheet.  Has living/dead, pith info, measurement info.\n#loading the dplR to use the basal area reconstruction functions.\ncore.data <- read.csv(\"raw input files/Core_data_DOE_summer_2014.csv\", na.strings=c(\"\", \"NA\", \"#VALUE!\", \"*\"), header=T)\n#adding a column include which plot at the site the trees belong to\nnames(core.data)\ncore.data$plot <- substr(core.data$plot.id, 3, 3)\ncore.data$plot <- as.factor(core.data$plot)\nsummary(core.data)\n\n#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH \ntree.data <- read.csv(\"raw input files/tree_metadata_DOE_plus_valles.csv\", na.strings=c(\"\", \"NA\", \"#VALUE!\", \"*\"), header=T)\n#adding a column include which plot at the site the trees belong to\nnames(tree.data)\ntree.data$plot <- substr(tree.data$PlotID, 3, 3)\ntree.data$plot <- as.factor(tree.data$plot)\nsummary(tree.data)\n\n\n\n\n#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.  \n#Removing NA's from the files\n# NOTE: reading in a single rwl with all measured trees otherwise you're going to need to make sure to change the file paths for EVERYTHING otherwise you overwrite important files and make a lot more work for yourself\ncore.rw <- read.rwl(\"RWL/RWL_all_trees.rwl\")\nsummary(core.rw)\n\n#removing the extra character that tellervo adds\nnames(core.rw)<-substr(names(core.rw), 1, 7)\nnames(core.rw)\n\n# NOTE: Unit Conversion Step\n#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR) \nsummary(core.rw)\ncore.rw <- core.rw/10\nsummary(core.rw)\ncore.rw[(nrow(core.rw)-20):nrow(core.rw), 1:10]\n\n\n# ----------------------------------------------------------------------------\n#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!\n# Separating Dead vs. Missing rings\n# What we need to know:\n#1) Dead trees -- fill missing years with 0\n#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0\n#3) Live Trees, missing part of core -- model growth\n\n# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years\n\nfor(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer\n\n\t# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone\n\t# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)\n\tif(!is.na(core.data[core.data$CoreID==j, \"zombie\"]) | core.data[core.data$CoreID==j, \"live.dead\"]==\"DEAD\"){ \n\t\tlast.meas <- as.numeric(core.data[core.data$CoreID==j, \"outer.measured\"]) # last ring which was mesured\n\t \tlast.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)\n\t\tif(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled\n\t\t\tinner.fill <- which(row.names(core.rw)== last.meas+1)\n\t\t\touter.fill <- which(row.names(core.rw)==last.yr)\n\t\t\tcore.rw[inner.fill:outer.fill,j] <- 0\n\t\t}\n\t}\n}\nsummary(core.rw[,c(1:10, (ncol(core.rw)-10):ncol(core.rw))])\n# ----------------------------------------------------------------------------\n\n\n##########################################################################\n#AGGREGATION STEP\n#taking ring widths and aggregating from the core level to the tree level\n##########################################################################\n# ----------------------------------------------------------------------------\n# aggregate to the tree level using only dated trees where possible\ntrees <- unique(substr(names(core.rw), 1, 6)) # listing trees we have measurements for\ntree.rw <- data.frame(array(NA, dim=c(nrow(core.rw), length(trees)))) # a blank data frame to put everything in\nrow.names(tree.rw) <- row.names(core.rw)  # labeling the rows with the years from our rwl\nnames(tree.rw)<-unique(substr(names(core.rw), 1, 6)) # labeling the columns as trees\n# summary(tree.rw) # this will get really big very quickly\ndim(tree.rw) # 266 trees, 112 years of data\n\n# The Aggregation Loop\nfor(i in unique(trees)){\n  cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with\n  cores <- names(core.rw)[cols] # getting the name of the cores we're working with\n  \n  # -----------------------\n  # if there's only one core, we just take that regardless of wheter it's dated or not\n  if(length(cols) == 1){ \n   \ttree.rw[,which(trees==i)] <- core.rw[,cols]\n\n\t# if that single core is dated, list the tree as dated (\"Y\"); if not, list as not (\"N\")\n   \tifelse(core.data[core.data$CoreID==cores, \"dated\"]==\"Y\", tree.data[tree.data$TreeID==i, \"Dated\"] <- \"Y\", tree.data[tree.data$TreeID==i, \"Dated\"] <- \"N\")\n\t# Finding a (best-guess) pith date for the tree\n   \ttree.data[tree.data$TreeID==i, \"Pith\"] <- core.data[core.data$CoreID==cores, \"pith.yr\"]\n  # -----------------------\n\n  \t} else { \n\n    # -----------------------\n  \t# if there's more than 1 core, we need to figure out which if any were dated\n  \tuse <- vector(length=length(cols))\n\tfor(x in 1:length(cols)){\n\t\tifelse(core.data[core.data$CoreID==cores[x], \"dated\"]==\"Y\", use[x] <- \"TRUE\", use[x] <- \"FALSE\")\n\t }\t\n    # -----------------------\n\n    # -----------------------\n\t# now we know which were dated, so we can use that to figure out which cores to average\n\tif(length(use[use==\"TRUE\"])==1) { \n\t\t# if only 1 core is dated, use only that core and call the tree dated\n  \t \ttree.rw[,which(trees==i)] <- core.rw[,cols[which(use==\"TRUE\")]]\n  \t \ttree.data[tree.data$TreeID==i, \"Dated\"] <- \"Y\"\n   \t\ttree.data[tree.data$TreeID==i, \"Pith\"] <- core.data[core.data$CoreID==cores[which(use==\"TRUE\")], \"pith.yr\"]\n\n    # -----------------------\n\n\t} else if(length(use[use==\"TRUE\"])>1) { \n    # -----------------------\n    # If there's greater than one dated core, take the mean of the dated cores and call the tree dated\n\t\ttree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use==\"TRUE\")]], na.rm=T)\n\t\ttree.data[tree.data$TreeID==i, \"Dated\"] <- \"Y\"\n   \t\ttree.data[tree.data$TreeID==i, \"Pith\"] <- mean(core.data[core.data$CoreID==cores[which(use==\"TRUE\")], \"pith.yr\"], na.rm=T)\n\n\t} else { \n    # -----------------------\n    # If no cores are dated, take the mean of whatever we have and call the tree undated\n\t\ttree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T) \n\t\ttree.data[tree.data$TreeID==i, \"Dated\"] <- \"N\"\n   \t\ttree.data[tree.data$TreeID==i, \"Pith\"] <- mean(core.data[core.data$CoreID==cores, \"pith.yr\"], na.rm=T)\n\t\t\n    # -----------------------\n\t}\n  }\n}\n# Note: There are some warnings, but I think it's okay\n\n# summary(tree.rw)\nmin(tree.rw, na.rm=T); max(tree.rw, na.rm=T)\ndim(tree.rw)\ntree.rw[(nrow(tree.rw)-20):nrow(tree.rw),1:10]\n\n# We've updated the tree.data file, so lets save our changes before we move any further\n# We only added a new column and didn't change anything that was original, so it should be okay, but lets just double check before moving forward\ntree.data$Dated <- as.factor(tree.data$Dated)\nsummary(tree.data)\n# NOTE: right now you have a ridculously long name for your tree data spreadsheet, so I'm going to call it something different for my own sanity right now :-P\nwrite.csv(tree.data, \"TreeData.csv\", row.names=F)\n\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n# CRR: writing our tree RWL to a csv formatted for gap filling before we calculate BAI (bc some have missing outsides and that's bad if we're working outside-in in out calculations)\n\n# stacking the RWL so that we have a single column of ring widths & an identifying column with TreeID\ntree.stack <- stack(tree.rw)\nnames(tree.stack) <- c(\"RW\", \"TreeID\")\ntree.stack$Year <- as.numeric(row.names(tree.rw)) # adding in the years\nsummary(tree.stack)\n\n# attaching all of our useful tree data\nsummary(tree.data)\ntree.stack <- merge(tree.stack, tree.data, all.x=T, all.y=F)\nsummary(tree.stack)\ndim(tree.stack)\n\nwrite.csv(tree.stack, \"TreeRWL_AllSites_stacked.csv\", row.names=F)\n\n# ----------------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n# GO TO GAPFILLING SCRIPT NOW!!:-)\n# ----------------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n",
    "created" : 1424708362549.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "106304631",
    "id" : "486A2B31",
    "lastKnownWriteTime" : 1424707681,
    "path" : "~/PhD/Carbon Research/Tree-Rings-and-Biomass/Uncertainty_analysis/pregapfilling_TRW_formatting.R",
    "project_path" : "pregapfilling_TRW_formatting.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}