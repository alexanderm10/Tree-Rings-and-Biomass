{
    "contents" : "##################################################################################\n## Basic Components necessary for data management for doing dendro modelling\n##################################################################################\n\n# clear memory\nrm(list=ls())\n\n# importing libraries\nlibrary(dplR)\nlibrary(lattice)\n\n# Getting Libraries\nlibrary(reshape)\nlibrary(car)\nlibrary(mgcv)\nlibrary(nlme)\nlibrary(lmeSplines)\n#library(lme4)\nlibrary(splines)\nlibrary(MASS)\nlibrary(MuMIn)\nlibrary(ggplot2)\nlibrary(grid)\nse <- function(x){\n\tsd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}\n\nq.blank <- theme(axis.line=element_line(color=\"black\", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color=\"black\", size=14, face=\"bold\"), axis.text.y=element_text(color=\"black\", size=12, face=\"bold\"), axis.title.x=element_text(face=\"bold\", size=14),  axis.title.y=element_text(face=\"bold\", size=14))\n\n\n#################################################################################################\n# STEP 1: Gap-filling measured trees\n# STEP 1b: Pith-correction in measured trees (useful for stand dynamics; won't do unless you ask for it)\n# STEP 2: Gap-filling missing trees\n#\n# BIG SELLING POINT OF THIS APPROACH: we can quantify different levels of uncertainty & variability\n# Caveats: fitting the initial GAMM is very time-intensive (it may take hours with your full data) because current form fits a spline to each tree in a mixed model framework\n\n#################################################################################################\n# Previous workflow\n# 1) Read in RWL, QA/QC\n# 3) Aggregate to tree (factoring in whether cores were dated) level & decide if an entire tree is dated or not -- WRITE THIS AS A FILE!\n# 4) Stack RWL & Merge with metadata (becomes \"ring.data\" or named equivalent)\n\n# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns\nring.data <- read.csv(\"TreeRWL_AllSites_stacked.csv\")\nring.data$tree <- as.factor(ring.data$tree) \nsummary(ring.data)\n\n# Tree Data\ntree.data <- read.csv(\"TreeData.csv\")\nsummary(tree.data)\n\n# Site Data (for year cored) \nsite.data <- read.csv(\"input files/DOE_plus_valles.csv\", na.strings=\"\")\nsite.data$Year.sample <- as.numeric(substr(site.data$date.sample,7,10))\nsummary(site.data)\n\n# merging in the year sampled into the tree data & calculating age\ntree.data <- merge(tree.data, site.data[,c(\"PlotID\", \"Year.sample\")], all.x=T, all.y=F)\ntree.data$Age <- tree.data$Year.sample - tree.data$Pith\nsummary(tree.data)\n\n# We're going to run 2 sets of fillin models:\n# 1) Model based on only DATED trees (m1d)\n# 2) Model based on both DATED and UNDATED trees (m1u)\n\ntrees.dated <- ring.data[ring.data$Dated==\"Y\",\"TreeID\"]\n\n# using the gamm allows us to fit a smoothing spline to each tree, which allows us to basically gapfill taking into account unique tree temporal trends\n#\tcurrent spline parameter: shrinkage version of cubic spline with 3 knots (stiff CR spline)\n#\twhen we fit a generalized version for missing trees, we'll have to decide what to fit it to instead of TreeID; I think probably species|plot\n# m1 <- gamm(RW ~ s(Year, bs=\"cs\", k=3) + species + dbh, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)\n\n# ----------------------------------------------------------------\n# IDEAL MODEL FORM (it won't work for many reasons)\n#\t-- won't predict outside range of years observed on each core\n#\t-- end up with singularity issues\n#\t-- would take FOREVER to fit even if it did work\n# m1d <- gamm(RW ~ s(Year, bs=\"cs\", k=3, by=TreeID) + species*dbh*canopy.class, random=list(site=~1, PlotID=~1, TreeID=~1), data=trees.dated.full, na.action=na.omit)\n# ----------------------------------------------------------------\n\n\n# ----------------------------------------------------------------\n# The spline doesn't fit outside the range of observed values, so we need to give it a \"null\" guess\n# As a very very rough guess right now, filling missing with the measurement from the oldest ring\n# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)\n# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?\n\n# ---------------------------------------\n# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)\n# ---------------------------------------\n# What we need: core summary data (DBH, estimated pith date)\n\n# Ignoring all the sites we don't have and doing some exploratory graphing\ntree.data2 <- tree.data[tree.data$PlotID %in% unique(ring.data$PlotID),]\nsummary(tree.data2)\n\n# Need to remove species for which we have no pith estimates for the time being\nspp.pith <- unique(tree.data2[!is.na(tree.data2$Pith), \"spp\"])\ntree.data3 <- tree.data2[tree.data2$spp %in%  spp.pith,]\nsummary(tree.data3)\n\nqplot(dbh, Age, color=spp, data=tree.data3) + facet_wrap(~spp) +\n\tstat_smooth(method=\"lm\", alpha=0.5, size=1.5) +\n\ttheme_bw()\n\n\n# Making a very basic linear model looking at site-specific species-dbh-age relationships\ndbh.age <- lm(Age ~ spp*dbh*site-1, data=tree.data3)\nsummary(dbh.age)\nsummary(dbh.age)$r.squared # Note, this very basic model works pretty well!\n\n# Using the prediction interval to get us a higher upper bound\nage.pi <- predict(dbh.age, newdata=tree.data3, interval=\"predict\")\nsummary(age.pi)\ndim(age.pi); dim(tree.data3) # Making sure we didn't lose any rows along the way\n\ntree.data3 <- cbind(tree.data3, age.pi)\nsummary(tree.data3)\n\n# Setting the filling window to the upper p.i. limit\ntree.data3$fill.year <- ifelse(is.na(tree.data3$Pith), tree.data3$Year.sample-tree.data3$upr, tree.data3$Pith)\nsummary(tree.data3)\n\n\n# Merging this back into a data frame that contains info for all the trees we're modeling right now\ntree.data.model <- merge(tree.data3, tree.data2, all.x=T, all.y=T)\nsummary(tree.data.model)\n\n#--------------------- \n# QUESTION: what to do about the species with no pith estimates?\n#\tFor now, I'm just going to do a species-naive fit within each plot\n#--------------------- \ndbh.age.plot <- lm(Age ~ dbh*PlotID-1, data=tree.data.model)\nsummary(dbh.age.plot) \n\nage.pi.plot <- predict(dbh.age.plot, newdata= tree.data.model, interval=\"predict\")\nsummary(age.pi.plot)\ndim(age.pi.plot); dim(tree.data.model)\n\nsummary(tree.data.model)\n# Filling missing fill.year with one caluclated form age.pi.plot fill \ntree.data.model[is.na(tree.data.model$fill.year),\"fill.year\"] <- tree.data.model[is.na(tree.data.model$fill.year),\"Year.sample\"] - age.pi.plot[which(is.na(tree.data.model$fill.year)),3]\nsummary(tree.data.model)\n#--------------------- \n# ---------------------------------------\n\n# ---------------------------------------\n# ORIGINAL USAGE: Provide dummy variable\n# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?\n#\t\tQUESTION: What dummy value do we want to give it?\n#\t\t\tFor now, I'm going to do the mean of the last decade\n# ---------------------------------------\n# summary(ring.data)\n\n# ring.data$RW0 <- ring.data$RW # Making a column of dummy-filled ring widths\n# for(i in unique(ring.data$TreeID)){\n\t# #------------------------------\n\t# #year.fill = the oldest year to fill based on above step (prediction interval, size-species-site relationships)\n\t# #year.min = the oldest year measured\n\t# #rw.fill = the dummy ring width to feed the model; right now this is for the last measured decade \n\t# #\t\t\t-- (yr.min + 10) means the 10 years following year.min (\n\t# #\t\t\t-- e.g. if min year = 1950, we'll fill with the mean value from 1950:1960\n\t# #------------------------------\n\t# yr.fill <- tree.data.model[tree.data.model$TreeID==i,\"fill.year\"]\n\t# yr.min <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), \"Year\"])\n\t# rw.fill <- mean(ring.data[ring.data$TreeID==i & ring.data$Year>=yr.min & ring.data$Year<=(yr.min+10), \"RW\"],na.rm=T)\n\t# #------------------------------\n\n\t# #------------------------------\n\t# # The actual insertion of the dummy fil value into the fill range\n\t# #------------------------------\n\t# ring.data[ring.data$TreeID==i & is.na(ring.data$RW) & ring.data$Year>=yr.fill, \"RW0\"] <- rw.fill\n\t# #------------------------------\n# }\n# summary(ring.data)\n# # ---------------------------------------\n\n# ---------------------------------------\n# New Usage: delete NAs for years way outside what we think we should be fitting\n# 2b) I still don't think we want to be fi\n# ---------------------------------------\nsummary(tree.data.model)\nsummary(ring.data)\ndim(ring.data)\n\nfor(i in unique(ring.data$TreeID)){\n\t#------------------------------\n\t#year.fill = the oldest year to fill based on above step (prediction interval, size-species-site relationships)\n\t#------------------------------\n\tyr.fill <- tree.data.model[tree.data.model$TreeID==i,\"fill.year\"]\n\t#------------------------------\n\n\t#------------------------------\n\t# The actual insertion of the dummy fil value into the fill range\n\t#------------------------------\n\tring.data <- ring.data[!(ring.data$TreeID==i & ring.data$Year<yr.fill),]\n\t#------------------------------\n}\nsummary(ring.data)\ndim(ring.data)\n# ---------------------------------------\n# ----------------------------------------------------------------\n\n# ----------------------------------------------------------------\n# ----------------------------------------------------------------\n# RUNNING THE GAMM!!\n# ----------------------------------------------------------------\n# ----------------------------------------------------------------\n# A generalized additive mixed model (gamm) allows us to fit splines in a mixed model context\n# we can let these splines vary by tree which essentially detrends the core\n# here's we're using our dummy-filled ring widths as a response so that the spline will fit over the whole time period of interest\n# NOTE: for this to work with canopy class, we'll need to figure out what to do about dead trees \n# NOTE: Right now this is set up for each site separately.  If you want to borrow strength from other sites to help gap fill certain species, run them together\n# ----------------------------------------------------------------\n\n# ---------------------------------------\n# Morgan Monroe Forest\n# ---------------------------------------\nring.data.mmf <- ring.data[substr(ring.data$PlotID,1,2)==\"MM\",]\nring.data.mmf <- droplevels(ring.data.mmf) \n# Note: the log link with the gaussian family to prevent fitting negative values requires that you can't actually have 0 growth so we're going to make it really really small instead\nring.data.mmf$RW <- ifelse(ring.data.mmf$RW==0, 1e-6, ring.data.mmf$RW)\nsummary(ring.data.mmf)\n\n\ngamm.mmf <- gamm(log(RW) ~ s(Year, bs=\"cs\", k=3, by=TreeID) + dbh, random=list(spp=~1, site=~1, PlotID=~1), data= ring.data.mmf, na.action=na.omit)\n\n# Saving the GAMM From above so we can load it without having to refit it\nsave(gamm.mmf, file=\"GapFilling_gamm_mmf_02.2015.rData\")\n\n# # This isn't a great way of doing it, but it'll let you see the splines for each of the cores\n# par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)\n# plot(gamm.mmf$gam)\n\n# Making Predicted ring widths\nring.data.mmf$RW.modeled <- exp(predict(gamm.mmf, ring.data.mmf))\nsummary(ring.data.mmf)\n\n# Graphing of the modeled rings we will use to fill the data (note this isn't truncating ones that are past where we think pith actually is)\npdf(\"gamm_gapfill_mmf.pdf\", height=7.5, width=10)\nggplot() + facet_wrap(~spp) +\n\tgeom_path(aes(x=Year, y=RW, color=spp), data=ring.data.mmf, size=0.5) +\n\tgeom_point(aes(x=Year, y=RW.modeled), ring.data.mmf[is.na(ring.data.mmf$RW),], size=0.5) +\n\tscale_y_continuous(limits=c(0,1.25)) +\n\ttheme_bw()\ndev.off()\n# ---------------------------------------\n\n\n# ---------------------------------------\n# Valles Caldera (Upper & Lower modeled together)\n# ---------------------------------------\nring.data.valles <- ring.data[substr(ring.data$PlotID,1,2)==\"VL\" | substr(ring.data$PlotID,1,2)==\"VU\",]\nring.data.valles <- droplevels(ring.data.valles)\nring.data.valles $RW <- ifelse(ring.data.valles$RW==0, 1e-6, ring.data.valles$RW)\nsummary(ring.data.valles)\n\ngamm.valles <- gamm(log(RW) ~ s(Year, bs=\"cs\", k=3, by=TreeID) + dbh, random=list(spp=~1, site=~1, PlotID=~1), data= ring.data.valles, na.action=na.omit)\n\n# Saving the GAMM From above so we can load it without having to refit it\nsave(gamm.valles, file=\"GapFilling_gamm_valles_02.2015.rData\")\n\n# # This isn't a great way of doing it, but it'll let you see the splines for each of the cores\n# par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)\n# plot(gamm.valles$gam)\n\nring.data.valles$RW.modeled <- exp(predict(gamm.valles, ring.data.valles))\nsummary(ring.data.valles)\n\n\n# VERY rough graphing of the modeled rings we will use to fill the data\npdf(\"gamm_gapfill_valles.pdf\", height=7.5, width=10)\nggplot() + facet_grid(spp~site) +\n\tgeom_path(aes(x=Year, y=RW, color=spp), data=ring.data.valles, size=0.25) +\n\tgeom_point(aes(x=Year, y=RW.modeled), ring.data.valles[is.na(ring.data.valles$RW),], size=0.5) +\n\tscale_y_continuous(limits=c(0,1.25)) +\n\ttheme_bw()\ndev.off()\n# ---------------------------------------\n# ----------------------------------------------------------------\n\n# ----------------------------------------------------------------\n# Create a gapfilled data set\n# ----------------------------------------------------------------\n# ---------------------------------------\n# Data Formatting\n# ---------------------------------------\n# putting the sites back into 1 file\ndim(ring.data.valles); dim(ring.data.mmf)\nring.data <- rbind(ring.data.valles, ring.data.mmf)\n\n# putting the modeled data where there are no ring widths (will cause negative dbh)\nring.data$RW.gapfilled <- ifelse(is.na(ring.data$RW), ring.data$RW.modeled, ring.data$RW)\nsummary(ring.data)\n\n# making a data frame with trees as columns and years as ros\nring.data$Year <- as.factor(ring.data$Year)\ntrees.gapfilled <- recast(ring.data[,c(\"Year\", \"TreeID\", \"RW.gapfilled\")], Year ~ TreeID)\nsummary(trees.gapfilled)\n\nrow.names(trees.gapfilled) <- trees.gapfilled$Year\ntrees.gapfilled <- trees.gapfilled[,2:ncol(trees.gapfilled)]\ntrees.gapfilled[(nrow(trees.gapfilled)-10):nrow(trees.gapfilled), 1:10]\n# ---------------------------------------\n\n# ---------------------------------------\n# DBH Reconstruction\n# ---------------------------------------\n# Tree Data\ntree.data <- read.csv(\"TreeData.csv\")\nsummary(tree.data)\n\n# Site Data (for year cored) \nsite.data <- read.csv(\"input files/DOE_plus_valles.csv\", na.strings=\"\")\nsite.data$Year.sample <- as.numeric(substr(site.data$date.sample,7,10))\nsummary(site.data)\n\n# merging in the year sampled into the tree data & calculating age\ntree.data <- merge(tree.data, site.data[,c(\"PlotID\", \"Year.sample\")], all.x=T, all.y=F)\ntree.data$Age <- tree.data$Year.sample - tree.data$Pith\nsummary(tree.data)\n\ncore.data <- read.csv(\"Core_data_DOE_summer_2014.csv\", na.strings=c(\"\", \"NA\", \"#VALUE!\", \"*\"), header=T)\n#adding a column include which plot at the site the trees belong to\nnames(core.data)\ncore.data$plot <- substr(core.data$plot.id, 3, 3)\ncore.data$plot <- as.factor(core.data$plot)\nsummary(core.data)\n\n# Ordering the data\ntrees.gapfilled <- trees.gapfilled[order(row.names(trees.gapfilled), decreasing=T),order(names(trees.gapfilled))]\ntrees.gapfilled[1:10, 1:10]\ntrees.gapfilled[1:10, (ncol(trees.gapfilled)-10):ncol(trees.gapfilled)]\n\ndbh.recon <- trees.gapfilled\ntrees.check <- vector() # trees with negative dbh\nfor(j in names(dbh.recon)){\n\t# Step 1: Replace filled years beyond the year in which a tree was sampled with NA (both trees.gapfilled & DBH recon); \n\t# \tGapfilled: filling the years where I changed 0 to 1e-6 back to 0\n\t#\tdbhrecon: fill year of sample with DBH when sampled\n\ttrees.gapfilled[as.numeric(row.names(trees.gapfilled))>tree.data[tree.data$TreeID==j, \"Year.sample\"],j] <- NA\n\ttrees.gapfilled[,j] <- ifelse(trees.gapfilled[,j]==1e-6, 0, trees.gapfilled[,j])\n\n\tdbh.recon[as.numeric(row.names(dbh.recon))>tree.data[tree.data$TreeID==j, \"Year.sample\"],j] <- NA\n\tdbh.recon[as.numeric(row.names(dbh.recon))==tree.data[tree.data$TreeID==j, \"Year.sample\"],j] <- tree.data[tree.data$TreeID==j, \"dbh\"]\n\t\n\t# Doing the DBH reconstruction\t\n\tfor(i in 2:(length(dbh.recon[,j]))){\n\t\tdbh.recon[i,j] <- ifelse(!is.na(trees.gapfilled[i-1,j]), dbh.recon[i-1,j] - trees.gapfilled[i-1,j]*2, dbh.recon[i,j]) # subtracting the previous year's growth from DBH to get that year's DBH\n\t}\n\t\n\t# Get rid of dbh past the guestimated pith dates -- both dbh recon & gapfilled\n\tif(!is.na(tree.data[tree.data$TreeID==j, \"Pith\"])){\n\t\tdbh.recon[as.numeric(row.names(dbh.recon))<tree.data[tree.data$TreeID==j, \"Pith\"],j] <- NA\n\t\ttrees.gapfilled[as.numeric(row.names(trees.gapfilled))<tree.data[tree.data$TreeID==j, \"Pith\"],j] <- NA\n\t} else \n\tif(is.na(tree.data[tree.data$TreeID==j, \"Pith\"])){ # Get rid of negative modeled dbh\n\t\tdbh.recon[,j] <- ifelse(dbh.recon[,j]<0, NA, dbh.recon[,j]) \n\t\ttrees.gapfilled[,j] <- ifelse(dbh.recon[,j]<0, NA, trees.gapfilled[,j]) \t\t\n\t}\n\t# also getting rid of these rings in the stacked ring data too\n\tyears.na <- row.names(trees.gapfilled)[which(is.na(trees.gapfilled[,j]))]\n\tring.data[ring.data$TreeID==j & ring.data$Year %in% years.na,\"RW.gapfilled\"] <- NA\n\n\tif(min(dbh.recon[,j], na.rm=T)<0) trees.check <- c(trees.check, j)\n}\ndbh.recon[1:20, 1:10]\ndbh.recon[1:20, (ncol(dbh.recon)-20):ncol(dbh.recon)]\nmin(dbh.recon, na.rm=T)\ntrees.check\nsummary(dbh.recon[,trees.check])\n\n# for trees with negative dbh, working from the inside out\n\t# If a tree has a negative DBH, we're just going to add from the inside out (at time )\nfor(j in trees.check){\n\tif(min(dbh.recon[,j], na.rm=T)<0){\n\t\tdbh.recon[,j] <- trees.gapfilled[,j]\n\t\tfor(i in (nrow(dbh.recon)-1):1){\n\t\t\tdbh.recon[i,j] <- sum(dbh.recon[i+1, j], trees.gapfilled[i,j]*2, na.rm=T)\n\t\t\t}\n\t}\n}\nmin(dbh.recon, na.rm=T)\ndbh.recon[1:10,trees.check]\nsummary(dbh.recon[, trees.check])\n#trees.gapfilled[, trees.check]\ntree.data[tree.data$TreeID %in% trees.check,]\n# ---------------------------------------\nwrite.csv(dbh.recon, \"gap_filled_dbh.recon.csv\", row.names=T)\nwrite.csv(trees.gapfilled, \"gap_filled_ring.widths.csv\", row.names=T)\n\nsummary(ring.data)\nwrite.csv(ring.data, \"TreeRWL_AllSites_stacked_gapfilled.csv\", row.names=F)\n\n\n\n\n\n\n\n\n\n\n\n##################################################################################\n# see next script for reconstructing basal area of trees with no samples \n##################################################################################\n",
    "created" : 1424707216424.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1502645125",
    "id" : "E32F5EC4",
    "lastKnownWriteTime" : 1424707680,
    "path" : "~/PhD/Carbon Research/Tree-Rings-and-Biomass/Uncertainty_analysis/christy_gapfilling.R",
    "project_path" : "christy_gapfilling.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}