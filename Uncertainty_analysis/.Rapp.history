###################################################################################
## Basic Components necessary for data management for doing dendro modelling#
###################################################################################
#
# clear memory#
rm(list=ls())#
#
# importing libraries#
library(dplR)#
library(lattice)#
#
# Getting Libraries#
library(reshape)#
library(car)#
library(mgcv)#
library(nlme)#
library(lmeSplines)#
#library(lme4)#
library(splines)#
library(MASS)#
library(MuMIn)#
library(ggplot2)#
library(grid)#
se <- function(x){#
	sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
#
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))
# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns#
ring.data <- read.csv("TreeRWL_AllSites_stacked.csv")#
ring.data$tree <- as.factor(ring.data$tree) #
summary(ring.data)#
#
# Tree Data#
tree.data <- read.csv("TreeData.csv")#
summary(tree.data)#
#
# Site Data (for year cored) #
site.data <- read.csv("input files/DOE_plus_valles.csv", na.strings="")#
site.data$Year.sample <- as.numeric(substr(site.data$date.sample,7,10))#
summary(site.data)#
#
# merging in the year sampled into the tree data & calculating age#
tree.data <- merge(tree.data, site.data[,c("PlotID", "Year.sample")], all.x=T, all.y=F)#
tree.data$Age <- tree.data$Year.sample - tree.data$Pith#
summary(tree.data)#
#
# We're going to run 2 sets of fillin models:#
# 1) Model based on only DATED trees (m1d)#
# 2) Model based on both DATED and UNDATED trees (m1u)#
#
trees.dated <- ring.data[ring.data$Dated=="Y","TreeID"]
# ---------------------------------------#
# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)#
# ---------------------------------------#
# What we need: core summary data (DBH, estimated pith date)#
#
# Ignoring all the sites we don't have and doing some exploratory graphing#
tree.data2 <- tree.data[tree.data$PlotID %in% unique(ring.data$PlotID),]#
summary(tree.data2)#
#
# Need to remove species for which we have no pith estimates for the time being#
spp.pith <- unique(tree.data2[!is.na(tree.data2$Pith), "spp"])#
tree.data3 <- tree.data2[tree.data2$spp %in%  spp.pith,]#
summary(tree.data3)#
#
qplot(dbh, Age, color=spp, data=tree.data3) + facet_wrap(~spp) +#
	stat_smooth(method="lm", alpha=0.5, size=1.5) +#
	theme_bw()#
# Making a very basic linear model looking at site-specific species-dbh-age relationships#
dbh.age <- lm(Age ~ spp*dbh*site-1, data=tree.data3)#
summary(dbh.age)#
summary(dbh.age)$r.squared # Note, this very basic model works pretty well!#
#
# Using the prediction interval to get us a higher upper bound#
age.pi <- predict(dbh.age, newdata=tree.data3, interval="predict")#
summary(age.pi)#
dim(age.pi); dim(tree.data3) # Making sure we didn't lose any rows along the way#
#
tree.data3 <- cbind(tree.data3, age.pi)#
summary(tree.data3)#
#
# Setting the filling window to the upper p.i. limit#
tree.data3$fill.year <- ifelse(is.na(tree.data3$Pith), tree.data3$Year.sample-tree.data3$upr, tree.data3$Pith)#
summary(tree.data3)#
# Merging this back into a data frame that contains info for all the trees we're modeling right now#
tree.data.model <- merge(tree.data3, tree.data2, all.x=T, all.y=T)#
summary(tree.data.model)
#--------------------- #
# QUESTION: what to do about the species with no pith estimates?#
#	For now, I'm just going to do a species-naive fit within each plot#
#--------------------- #
dbh.age.plot <- lm(Age ~ dbh*PlotID-1, data=tree.data.model)#
summary(dbh.age.plot) #
#
age.pi.plot <- predict(dbh.age.plot, newdata= tree.data.model, interval="predict")#
summary(age.pi.plot)#
dim(age.pi.plot); dim(tree.data.model)#
#
summary(tree.data.model)#
# Filling missing fill.year with one caluclated form age.pi.plot fill #
tree.data.model[is.na(tree.data.model$fill.year),"fill.year"] <- tree.data.model[is.na(tree.data.model$fill.year),"Year.sample"] - age.pi.plot[which(is.na(tree.data.model$fill.year)),3]#
summary(tree.data.model)
summary(tree.data.model)
tree.data.model$TreeID %in% unique(ring.data$TreeID)
trees.missing <- tree.data.model$TreeID[!(tree.data.model$TreeID %in% unique(ring.data$TreeID))]
trees.missing
length(trees.missing)
?data.frame
min(ring.data$Year):max(ring.data$Year)
rw.dummy <- data.frame(Year=min(ring.data$Year):max(ring.data$Year), RW=NA)
summary(rw.dummy)
trees.missing <- merge(trees.missing, rw.dummy, all.x=T, all.y=T)
summary(trees.missing)
trees.missing <- tree.data.model[!(tree.data.model$TreeID %in% unique(ring.data$TreeID)), c("spp", "site", "PlotID", "TreeID")]
summary(trees.missing)
summary(trees.missing); dim(trees.missing)
# Creating a vector of years and dummy ring widths we're going to want to fill#
rw.dummy <- data.frame(Year=min(ring.data$Year):max(ring.data$Year), RW=NA)#
summary(rw.dummy)#
#
trees.missing <- merge(trees.missing, rw.dummy, all.x=T, all.y=T)#
names(trees.missing) <- c("TreeID", "Year", "RW")#
summary(trees.missing)
trees.missing <- tree.data.model[!(tree.data.model$TreeID %in% unique(ring.data$TreeID)), c("spp", "site", "PlotID", "TreeID")]#
summary(trees.missing)# 29 missing trees: 4 from MM, 22 VUF, 3 VLF#
dim(trees.missing)#
#
# Creating a vector of years and dummy ring widths we're going to want to fill#
rw.dummy <- data.frame(Year=min(ring.data$Year):max(ring.data$Year), RW=NA)#
summary(rw.dummy)
trees.missing <- merge(trees.missing, rw.dummy, all.x=T, all.y=T)
summary(trees.missing)
summary(tree.data.model)#
summary(trees.missing)
for(i in unique(trees.missing$TreeID)){#
	#------------------------------#
	#year.fill = the oldest year to fill based on above step (prediction interval, size-species-site relationships)#
	#------------------------------#
	yr.fill <- tree.data.model[tree.data.model$TreeID==i,"fill.year"]#
	#------------------------------#
#
	#------------------------------#
	# The actual insertion of the dummy fil value into the fill range#
	#------------------------------#
	trees.missing <- trees.missing[!(trees.missing$TreeID==i & trees.missing$Year<yr.fill),]#
	#------------------------------#
}#
summary(trees.missing)
gamm.missing <- gamm(log(RW) ~ s(Year, bs="cs", k=3, by=PlotID) + dbh, random=list(spp=~1, site=~1, PlotID=~1), data= ring.data, na.action=na.omit)
summary(ring.data)
ring.data[ring.data$RW==0, "RW"] <- 1e-6
summary(ring.data)
ring.data[ring.data$RW==0, "RW"]
ring.data$RW <- ifelse(ring.data$RW==0, 1e-6, ring.data$RW)
summary(ring.data)
gamm.missing <- gamm(log(RW) ~ s(Year, bs="cs", k=3, by=PlotID) + dbh, random=list(spp=~1, site=~1, PlotID=~1), data= ring.data, na.action=na.omit)
summary(treeeID)
summary(tree.data.model)
library(dplR)#
se <- function(x){#
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
##################################################################################################
# Loading up .csv file that has meta data and RWL files for ring widths#
# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother#
##################################################################################################
#
#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH #
#loading the dplR to use the basal area reconstruction functions.#
#
core.data <- read.csv("Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(core.data)#
core.data$plot <- substr(core.data$plot.id, 3, 3)#
core.data$plot <- as.factor(core.data$plot)
summary(core.data)
unique(core.data$plot.id)
tree.data <- read.csv("tree_metadata_DOE_plus_valles.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(tree.data)#
tree.data$plot <- substr(tree.data$PlotID, 3, 3)#
tree.data$plot <- as.factor(tree.data$plot)#
#
summary(tree.data)
library(dplR)#
se <- function(x){#
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
##################################################################################################
# Loading up .csv file that has meta data and RWL files for ring widths#
# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother#
##################################################################################################
#
#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH #
#loading the dplR to use the basal area reconstruction functions.#
#
core.data <- read.csv("Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(core.data)#
core.data$plot <- substr(core.data$plot.id, 3, 3)#
core.data$plot <- as.factor(core.data$plot)#
summary(core.data)#
#
tree.data <- read.csv("tree_metadata_DOE_plus_valles.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(tree.data)#
tree.data$plot <- substr(tree.data$PlotID, 3, 3)#
tree.data$plot <- as.factor(tree.data$plot)#
# Correcting Valles Plot IDs#
summary(tree.data)#
#load in core details data sheet.  Has living/dead, pith info, measurement info.#
#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.  #
#Removing NA's from the files#
# NOTE: reading in a single rwl with all measured trees otherwise you're going to need to make sure to change the file paths for EVERYTHING otherwise you overwrite important files and make a lot more work for yourself#
core.rw <- read.rwl("RWL/RWL_all_trees.rwl")#
summary(core.rw)#
#
#removing the extra character that tellervo adds#
names(core.rw)<-substr(names(core.rw), 1, 7)#
names(core.rw)#
#
# NOTE: Unit Conversion Step#
#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR) #
summary(core.rw)#
core.rw <- core.rw/10#
summary(core.rw)#
core.rw[(nrow(core.rw)-20):nrow(core.rw), 1:10]#
# ----------------------------------------------------------------------------#
#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!#
# Separating Dead vs. Missing rings#
# What we need to know:#
#1) Dead trees -- fill missing years with 0#
#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0#
#3) Live Trees, missing part of core -- model growth#
#
# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years#
#
for(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer#
#
	# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone#
	# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)#
	if(!is.na(core.data[core.data$CoreID==j, "zombie"]) | core.data[core.data$CoreID==j, "live.dead"]=="DEAD"){ #
		last.meas <- as.numeric(core.data[core.data$CoreID==j, "outer.measured"]) # last ring which was mesured#
	 	last.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)#
		if(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled#
			inner.fill <- which(row.names(core.rw)== last.meas+1)#
			outer.fill <- which(row.names(core.rw)==last.yr)#
			core.rw[inner.fill:outer.fill,j] <- 0#
		}#
	}#
}#
summary(core.rw[,c(1:10, (ncol(core.rw)-10):ncol(core.rw))])#
# ----------------------------------------------------------------------------
core.data <- read.csv("raw input files/Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(core.data)#
core.data$plot <- substr(core.data$plot.id, 3, 3)#
core.data$plot <- as.factor(core.data$plot)#
summary(core.data)#
#
tree.data <- read.csv("raw input files/tree_metadata_DOE_plus_valles.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(tree.data)#
tree.data$plot <- substr(tree.data$PlotID, 3, 3)#
tree.data$plot <- as.factor(tree.data$plot)#
# Correcting Valles Plot IDs#
summary(tree.data)
#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.  #
#Removing NA's from the files#
# NOTE: reading in a single rwl with all measured trees otherwise you're going to need to make sure to change the file paths for EVERYTHING otherwise you overwrite important files and make a lot more work for yourself#
core.rw <- read.rwl("RWL/RWL_all_trees.rwl")#
summary(core.rw)#
#
#removing the extra character that tellervo adds#
names(core.rw)<-substr(names(core.rw), 1, 7)#
names(core.rw)#
#
# NOTE: Unit Conversion Step#
#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR) #
summary(core.rw)#
core.rw <- core.rw/10#
summary(core.rw)#
core.rw[(nrow(core.rw)-20):nrow(core.rw), 1:10]#
# ----------------------------------------------------------------------------#
#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!#
# Separating Dead vs. Missing rings#
# What we need to know:#
#1) Dead trees -- fill missing years with 0#
#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0#
#3) Live Trees, missing part of core -- model growth#
#
# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years#
#
for(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer#
#
	# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone#
	# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)#
	if(!is.na(core.data[core.data$CoreID==j, "zombie"]) | core.data[core.data$CoreID==j, "live.dead"]=="DEAD"){ #
		last.meas <- as.numeric(core.data[core.data$CoreID==j, "outer.measured"]) # last ring which was mesured#
	 	last.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)#
		if(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled#
			inner.fill <- which(row.names(core.rw)== last.meas+1)#
			outer.fill <- which(row.names(core.rw)==last.yr)#
			core.rw[inner.fill:outer.fill,j] <- 0#
		}#
	}#
}#
summary(core.rw[,c(1:10, (ncol(core.rw)-10):ncol(core.rw))])#
# ----------------------------------------------------------------------------#
###########################################################################
#AGGREGATION STEP#
#taking ring widths and aggregating from the core level to the tree level#
###########################################################################
# ----------------------------------------------------------------------------#
# aggregate to the tree level using only dated trees where possible#
trees <- unique(substr(names(core.rw), 1, 6)) # listing trees we have measurements for#
tree.rw <- data.frame(array(NA, dim=c(nrow(core.rw), length(trees)))) # a blank data frame to put everything in#
row.names(tree.rw) <- row.names(core.rw)  # labeling the rows with the years from our rwl#
names(tree.rw)<-unique(substr(names(core.rw), 1, 6)) # labeling the columns as trees#
# summary(tree.rw) # this will get really big very quickly#
dim(tree.rw) # 176 trees, 107 years of data#
#
# The Aggregation Loop#
for(i in unique(trees)){#
  cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with#
  cores <- names(core.rw)[cols] # getting the name of the cores we're working with#
  # -----------------------#
  # if there's only one core, we just take that regardless of wheter it's dated or not#
  if(length(cols) == 1){ #
   	tree.rw[,which(trees==i)] <- core.rw[,cols]#
#
	# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")#
   	ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")#
	# Finding a (best-guess) pith date for the tree#
   	tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores, "pith.yr"]#
  # -----------------------#
#
  	} else { #
#
    # -----------------------#
  	# if there's more than 1 core, we need to figure out which if any were dated#
  	use <- vector(length=length(cols))#
	for(x in 1:length(cols)){#
		ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")#
	 }	#
    # -----------------------#
#
    # -----------------------#
	# now we know which were dated, so we can use that to figure out which cores to average#
	if(length(use[use=="TRUE"])==1) { #
		# if only 1 core is dated, use only that core and call the tree dated#
  	 	tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]#
  	 	tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]#
#
    # -----------------------#
#
	} else if(length(use[use=="TRUE"])>1) { #
    # -----------------------#
    # If there's greater than one dated core, take the mean of the dated cores and call the tree dated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)#
		tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)#
#
	} else { #
    # -----------------------#
    # If no cores are dated, take the mean of whatever we have and call the tree undated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T) #
		tree.data[tree.data$TreeID==i, "Dated"] <- "N"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)#
    # -----------------------#
	}#
  }#
}#
# Note: There are some warnings, but I think it's okay#
#
# summary(tree.rw)#
min(tree.rw, na.rm=T); max(tree.rw, na.rm=T)#
dim(tree.rw)#
tree.rw[(nrow(tree.rw)-20):nrow(tree.rw),1:10]#
#
# We've updated the tree.data file, so lets save our changes before we move any further#
# We only added a new column and didn't change anything that was original, so it should be okay, but lets just double check before moving forward#
tree.data$Dated <- as.factor(tree.data$Dated)#
summary(tree.data)#
# NOTE: right now you have a ridculously long name for your tree data spreadsheet, so I'm going to call it something different for my own sanity right now :-P#
write.csv(tree.data, "TreeData.csv", row.names=F)
warnings()
###################################################################################
## Basic Components necessary for data management for doing dendro modelling#
###################################################################################
#
# clear memory#
rm(list=ls())#
#
# importing libraries#
library(dplR)#
library(lattice)#
#
# Getting Libraries#
library(reshape)#
library(car)#
library(mgcv)#
library(nlme)#
library(lmeSplines)#
#library(lme4)#
library(splines)#
library(MASS)#
library(MuMIn)#
library(ggplot2)#
library(grid)#
se <- function(x){#
	sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
#
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))#
##################################################################################################
# STEP 1: Gap-filling measured trees#
# STEP 1b: Pith-correction in measured trees (useful for stand dynamics; won't do unless you ask for it)#
# STEP 2: Gap-filling missing trees#
##
# BIG SELLING POINT OF THIS APPROACH: we can quantify different levels of uncertainty & variability#
# Caveats: fitting the initial GAMM is very time-intensive (it may take hours with your full data) because current form fits a spline to each tree in a mixed model framework#
#
##################################################################################################
# Previous workflow#
# 1) Read in RWL, QA/QC#
# 3) Aggregate to tree (factoring in whether cores were dated) level & decide if an entire tree is dated or not -- WRITE THIS AS A FILE!#
# 4) Stack RWL & Merge with metadata (becomes "ring.data" or named equivalent)#
#
# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns#
ring.data <- read.csv("TreeRWL_AllSites_stacked.csv")#
ring.data$tree <- as.factor(ring.data$tree) #
summary(ring.data)
