vla.density <- data.frame(array(dim=c(1, 33)))#
vla.density <- vector(length=length(end.yr:start.yr))#
vla.density[,] <- 0.0694
vla.density <- data.frame(array(dim=c(1, 33)))#
vla.density[,] <- 0.0694
for(i in 2:length(vla.density[1,])){#
  vla.density[1,i] <- vla.density[1,i-1] + vla.density[1,i-1]*mort.mean[i]/100#
}#
vla.density
plot(vla.density[1,])
plot(as.vector(vla.density[1,]))
plot(as.vector(vla.density[1,]), type="l")
class(vla.density[1,])
vla.density <- vector(length=length(end.yr:start.yr))#
vla.density[] <- 0.0694#
names(vla.density) <- end.yr:start.yr#
#
for(i in 2:length(vla.density[1,])){#
  vla.density[1,i] <- vla.density[1,i-1] + vla.density[1,i-1]*mort.mean[i]/100#
}#
vla.density#
#
vla.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci)))) #
rownames(vla.density.ci) <- row.names(ci)#
row.names(vla.density.ci) <- names(ci.mort.rate)#
vla.density.ci <-  ci #
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density, type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,], lty="dashed")#
lines(vla.density.ci[2,], lty="dashed")
length(ci)
start.m <- rnorm(1000, mean=0.4843, sd= 0.2823)#
rate.m <- rnorm(1000, mean= 0.024, sd= 0.027)#
start.yr = 1979#
end.yr = 2011#
#
mort.rate <- data.frame(array(dim=c(1000, 33)))#
names(mort.rate) <- start.yr:end.yr#
#
for(j in 1:1000){#
mort.rate[j,1] = sample(start.m, size=1, replace=T)#
#
for(i in 2:length(mort.rate)){#
  mort.rate[j,i] <- mort.rate[j,i-1] + mort.rate[j,i-1]*sample(rate.m, size=1, replace=T)#
}#
}#
summary(mort.rate)#
ci <- apply(mort.rate, 2, FUN=quantile, c(0.025, 0.975))#
mort.mean <- apply(mort.rate, 2, FUN=mean)#
#
plot(mort.mean, type="l", ylim=range(ci))#
lines(ci[1,], lty="dashed")#
lines(ci[2,], lty="dashed")#
#
#ci<- as.data.frame(ci)#
#
mort.rate <- mort.mean[sort(names(mort.mean), decreasing=T)]#
ci.mort.rate <- ci[,sort(colnames(ci), decreasing=T)]
vla.density <- vector(length=length(end.yr:start.yr))#
vla.density[] <- 0.0694#
names(vla.density) <- end.yr:start.yr#
#
for(i in 2:length(vla.density)){#
  vla.density[i] <- vla.density[i-1] + vla.density[i-1]*mort.mean[i]/100#
}#
vla.density#
#
vla.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci)))) #
rownames(vla.density.ci) <- row.names(ci)#
row.names(vla.density.ci) <- names(ci.mort.rate)#
vla.density.ci <-  ci #
vla.density.ci[,] <- 0.0694
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density, type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,], lty="dashed")#
lines(vla.density.ci[2,], lty="dashed")
mort.mean
plot(mort.mean~names(mort.mean), type="l", ylim=range(ci))
lines(ci[1,]~names(mort.mean), lty="dashed")
lines(ci[1,]~names(ci), lty="dashed")
lines(ci[1,]~colnames(ci), lty="dashed")
lines(ci[2,]~colnames(ci), lty="dashed")
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))
lines(vla.density.ci[1,]~names(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~names(vla.density.ci), lty="dashed")
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
vla.density.ci
vla.density.ci <-  ci #
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
vla.density.ci <-  ci
vla.density
ci
vla.density.ci <-  ci[,sort(colnames(ci), descending=T)]#
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
vla.density.ci
vla.density.ci <-  ci[,sort(colnames(ci), descending=T)]
?sort
vla.density.ci <-  ci[,sort(colnames(ci), decreasing=T)]#
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
vla.density.ci <-  ci.mort.rate#
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
plot(vla.density~names(vla.density), type="l", ylim=c(0,max(vla.density.ci)))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
vla.density <- vector(length=length(end.yr:start.yr))#
vla.density[] <- 0.590278#
names(vla.density) <- end.yr:start.yr#
#
for(i in 2:length(vla.density)){#
  vla.density[i] <- vla.density[i-1] + vla.density[i-1]*mort.mean[i]/100#
}#
vla.density#
vla.density.ci <-  ci.mort.rate#
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")#
#
vlb.density <- data.frame(array(dim=c(1, 33)))#
vlb.density[,] <- unique(tree.data$Density..stems.ha.[tree.data$PlotID=="VLB"])/1000#
names(vlb.density) <- end.yr:start.yr#
#
for(i in 2:length(vlb.density)){#
  vlb.density[i] <- vlb.density[i-1] + vlb.density[i-1]*mort.mean[i]/100#
}#
vlb.density
# Mortality data gathered from van Mantgem 2009#
# used interior numbers start year 1979 and end year 2011#
# used to change densities for the valles #
#
start.m <- rnorm(1000, mean=0.4843, sd= 0.2823)#
rate.m <- rnorm(1000, mean= 0.024, sd= 0.027)#
start.yr = 1979#
end.yr = 2011#
#
mort.rate <- data.frame(array(dim=c(1000, 33)))#
names(mort.rate) <- start.yr:end.yr#
#
for(j in 1:1000){#
mort.rate[j,1] = sample(start.m, size=1, replace=T)#
#
for(i in 2:length(mort.rate)){#
  mort.rate[j,i] <- mort.rate[j,i-1] + mort.rate[j,i-1]*sample(rate.m, size=1, replace=T)#
}#
}#
summary(mort.rate)#
ci <- apply(mort.rate, 2, FUN=quantile, c(0.025, 0.975))#
mort.mean <- apply(mort.rate, 2, FUN=mean)#
#
plot(mort.mean~names(mort.mean), type="l", ylim=range(ci))#
lines(ci[1,]~colnames(ci), lty="dashed")#
lines(ci[2,]~colnames(ci), lty="dashed")#
#
#ci<- as.data.frame(ci)#
#
mort.rate <- mort.mean[sort(names(mort.mean), decreasing=T)]#
ci.mort.rate <- ci[,sort(colnames(ci), decreasing=T)]#
vla.density <- vector(length=length(end.yr:start.yr))#
vla.density[] <- 0.590278#
names(vla.density) <- end.yr:start.yr#
#
for(i in 2:length(vla.density)){#
  vla.density[i] <- vla.density[i-1] + vla.density[i-1]*mort.mean[i]/100#
}#
vla.density#
vla.density.ci <-  ci.mort.rate#
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")#
#
vlb.density <- data.frame(array(dim=c(1, 33)))#
vlb.density[,] <- unique(tree.data$Density..stems.ha.[tree.data$PlotID=="VLB"])/1000#
names(vlb.density) <- end.yr:start.yr#
#
for(i in 2:length(vlb.density)){#
  vlb.density[i] <- vlb.density[i-1] + vlb.density[i-1]*mort.mean[i]/100#
}#
vlb.density
# Mortality data gathered from van Mantgem 2009#
# used interior numbers start year 1979 and end year 2011#
# used to change densities for the valles #
#
start.m <- rnorm(1000, mean=0.4843, sd= 0.2823)#
rate.m <- rnorm(1000, mean= 0.024, sd= 0.027)#
start.yr = 1979#
end.yr = 2011#
#
mort.rate <- data.frame(array(dim=c(1000, 33)))#
names(mort.rate) <- start.yr:end.yr#
#
for(j in 1:1000){#
mort.rate[j,1] = sample(start.m, size=1, replace=T)#
#
for(i in 2:length(mort.rate)){#
  mort.rate[j,i] <- mort.rate[j,i-1] + mort.rate[j,i-1]*sample(rate.m, size=1, replace=T)#
}#
}#
summary(mort.rate)#
ci <- apply(mort.rate, 2, FUN=quantile, c(0.025, 0.975))#
mort.mean <- apply(mort.rate, 2, FUN=mean)#
#
plot(mort.mean~names(mort.mean), type="l", ylim=range(ci))#
lines(ci[1,]~colnames(ci), lty="dashed")#
lines(ci[2,]~colnames(ci), lty="dashed")#
#
#ci<- as.data.frame(ci)#
#
mort.rate <- mort.mean[sort(names(mort.mean), decreasing=T)]#
ci.mort.rate <- ci[,sort(colnames(ci), decreasing=T)]#
vla.density <- vector(length=length(end.yr:start.yr))#
vla.density[] <- 0.590278#
names(vla.density) <- end.yr:start.yr#
#
for(i in 2:length(vla.density)){#
  vla.density[i] <- vla.density[i-1] + vla.density[i-1]*mort.mean[i]/100#
}#
vla.density
vla.density.ci <-  ci.mort.rate#
vla.density.ci[,] <- 0.0694#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")#
#
vlb.density <- data.frame(array(dim=c(1, 33)))#
vlb.density[,] <- unique(tree.data$Density..stems.ha.[tree.data$PlotID=="VLB"])/1000#
names(vlb.density) <- end.yr:start.yr#
#
for(i in 2:length(vlb.density)){#
  vlb.density[i] <- vlb.density[i-1] + vlb.density[i-1]*mort.mean[i]/100#
}#
vlb.density#
vua.density <- data.frame(array(dim=c(1, 33)))#
vua.density[,] <- unique(tree.data$Density..stems.ha.[tree.data$PlotID=="VUA"])/1000#
names(vua.density) <- end.yr:start.yr#
#
for(i in 2:length(vua.density)){#
  vua.density[i] <- vua.density[i-1] + vua.density[i-1]*mort.mean[i]/100#
}#
vua.density
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
vla.density
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))
vla.density.ci <-  ci.mort.rate#
vla.density.ci[,] <- 0.590278#
#
for(j in 1:nrow(vla.density.ci)){#
  for(i in 2:ncol(vla.density.ci)){#
    vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))#
lines(vla.density.ci[1,]~colnames(vla.density.ci), lty="dashed")#
lines(vla.density.ci[2,]~colnames(vla.density.ci), lty="dashed")
vlb.density <- vector(length=length(end.yr:start.yr))#
vlb.density[] <- 0.089744#
names(vlb.density) <- end.yr:start.yr#
#
for(i in 2:length(vlb.density)){#
  vlb.density[i] <- vlb.density[i-1] + vlb.density[i-1]*mort.mean[i]/100#
}#
vlb.density#
vlb.density.ci <-  ci.mort.rate#
vlb.density.ci[,] <- 0.089744#
#
for(j in 1:nrow(vlb.density.ci)){#
  for(i in 2:ncol(vlb.density.ci)){#
    vlb.density.ci[j,i] <-vlb.density.ci[j,i-1] + vlb.density.ci[j,i-1]*ci.mort.rate[j,i]/100#
}#
}#
plot(vlb.density~names(vlb.density), type="l", ylim=range(vlb.density.ci))#
lines(vlb.density.ci[1,]~colnames(vlb.density.ci), lty="dashed")#
lines(vlb.density.ci[2,]~colnames(vlb.density.ci), lty="dashed")
20/25
5/25
setwd("~/Dropbox/PalEON CR/Tree Rings/Tree-Rings-and-Biomass/Uncertainty_analysis")#
#
library(dplR)#
library(ggplot2)#
se <- function(x){#
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
# Run this script after the gap filling process scripts have been run#
# For the NACP15 abstract run Tree_rw_gapfilled.csv#
# load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.#
#
g.filled.diam <- read.csv("gap_filled_dbh.recon.csv", header=T, row.names=1)#
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]#
summary(g.filled.diam)#
#
# read in tree data#
tree.data <- read.csv("TreeData.csv", header=T)#
summary(tree.data)#
#trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" | substr(tree.data$PlotID, 1, 2)=="MM",]#
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]#
summary(trees.use)#
#
#quick plot#
#spag.plot(g.filled.diam)#
#
plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")#
summary(plot.data)
setwd("~/Desktop/Dropbox/PalEON CR/Tree Rings/Tree-Rings-and-Biomass/Uncertainty_analysis")
library(dplR)#
library(ggplot2)#
se <- function(x){#
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
# Run this script after the gap filling process scripts have been run#
# For the NACP15 abstract run Tree_rw_gapfilled.csv#
# load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.#
#
g.filled.diam <- read.csv("gap_filled_dbh.recon.csv", header=T, row.names=1)#
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]#
summary(g.filled.diam)#
#
# read in tree data#
tree.data <- read.csv("TreeData.csv", header=T)#
summary(tree.data)#
#trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" | substr(tree.data$PlotID, 1, 2)=="MM",]#
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]#
summary(trees.use)#
#
#quick plot#
#spag.plot(g.filled.diam)#
#
plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")#
summary(plot.data)
library(car)#
#
# Getting rid of POTR for now for conceptual figure purposes#
trees.use <- trees.use[!(trees.use$Species=="POTR"),]#
summary(trees.use)#
unique(trees.use$Species)#
#
trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'")#
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
rm(list=ls())
setwd("~/Desktop/Dropbox/PalEON CR/Tree Rings/Tree-Rings-and-Biomass/Uncertainty_analysis")#
#
library(dplR)#
library(ggplot2)#
library(car)#
#
se <- function(x){#
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
# Run this script after the gap filling process scripts have been run#
# For the NACP15 abstract run Tree_rw_gapfilled.csv#
###########################################################################
# Doing the Allometry sampling (form allometry_sampling.R)#
###########################################################################
allometries<- list()#
#
###########################################################################
# Sampling the Allometric MCMC#
###########################################################################
# Pecan Only#
load("AllomFiles/Picea/PecanOnly/Allom.test.2.Rdata")
ls
ls()
summary(allom)
summary(allom$parm)
summary(allometries)
allometries
summary(obs)
summary(obs[[1]])
obs[[1]]
summary(DICg)
DICg
pD
pDg
summary(mc)
summary(mc[[1]])
source("/var/folders/qh/20hm5f4m8xjgjd0059bmn_zh0000gp/T//Rtmp19Kg59/file361273dd77")#
unlink("/var/folders/qh/20hm5f4m8xjgjd0059bmn_zh0000gp/T//Rtmp19Kg59/file361273dd77")
# --------------------------------------------------------------------------------#
# --------------------------------------------------------------------------------#
# Workflow for modeling generalized tree growth for the Valles Caldera#
# Note: This is developed so that we can use our tree rings to gap-fill the trees#
#       in data from Marcy Litvak.  This means we have to remove at least PlotID &#
#       either generalize species or drop that as well. #
# --------------------------------------------------------------------------------#
# --------------------------------------------------------------------------------#
#
# --------------------------------------------------------------------------------#
# Loading in libraries and some other useful things#
# --------------------------------------------------------------------------------#
# clear memory#
rm(list=ls())#
#
# importing libraries#
library(dplR)#
library(lattice)#
#
# Getting Libraries#
library(reshape)#
library(car)#
library(mgcv)#
library(nlme)#
library(lmeSplines)#
#library(lme4)#
library(splines)#
library(MASS)#
library(MuMIn)#
library(ggplot2)#
library(grid)#
se <- function(x){#
	sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
#
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))#
# -----------------------------------------------#
# --------------------------------------------------------------------------------#
# Loading in & comparing our tree ring data & Marcy's #
#    data so we know how to the structure the gamm#
# --------------------------------------------------------------------------------#
# -----------------------------------------------#
# Tree Ring Data#
# Format: stack all of the core measurements (BAI or RW) to create a single data frame with a single column of measurements and all predictors in other columns#
# -----------------------------------------------#
ring.data <- read.csv("TreeRWL_AllSites_stacked.csv")#
ring.data$Tree <- as.factor(ring.data$Tree) #
ring.data <- ring.data[,!names(ring.data)=="Density..stems.ha."]#
summary(ring.data)#
#
# Tree Data#
tree.data <- read.csv("TreeData.csv")#
tree.data <- tree.data[,!names(tree.data)=="Density..stems.ha."]#
summary(tree.data)#
#
# Site Data (for year cored) #
site.data <- read.csv("raw input files/DOE_plus_valles.csv", na.strings="")#
site.data$Year.sample <- as.numeric(substr(site.data$date.sample,7,10))#
summary(site.data)#
#
# merging in the year sampled into the tree data & calculating age#
# also adding the correct stem density here#
tree.data <- merge(tree.data, site.data[,c("PlotID", "Year.sample")], all.x=T, all.y=F)#
tree.data$PlotID#
tree.data$Age <- tree.data$Year.sample - tree.data$Pith#
summary(tree.data)#
#
# -----------------------------------------------#
#
# -----------------------------------------------#
# subsetting only data for the Valles & Formatting#
# -----------------------------------------------#
ring.data <- ring.data[substr(ring.data$PlotID,1,1)=="V",]#
summary(ring.data)#
tree.data <- tree.data[substr(tree.data$PlotID,1,1)=="V",]#
#
# merge in the modern stem density here#
tree.data <- merge(tree.data, site.data[,c("PlotID", "Year.sample")], all.x=T, all.y=F)#
ring.data <- merge(ring.data, site.data[,c("PlotID", "Density.Total..stems.ha.")], all.x=T, all.y=F)#
summary(tree.data)#
summary(ring.data)#
#
# Recoding the sites to match Marcy's#
tree.data$Site <- recode(tree.data$Site, "'Valles Caldera Upper'='PPINE'; 'Valles Caldera Lower'='MCON'")#
ring.data$Site <- recode(ring.data$Site, "'Valles Caldera Upper'='PPINE'; 'Valles Caldera Lower'='MCON'")#
summary(ring.data)#
summary(tree.data)#
#
# Just for reference: find the trees that were dated#
trees.dated <- ring.data[ring.data$Dated=="Y","TreeID"]#
# -----------------------------------------------#
#
# -----------------------------------------------#
# Marcy Litvak's data#
#   ***ADD WHATEVER WE NEED TO FOR FORMATTING HERE***#
#	***This might include recoding species in both Marcy's & our data#
#   ***Make sure site codes line up, etc.#
# -----------------------------------------------#
marcy.ppine <- read.csv("raw input files/marcy_ppine_2013.csv")#
summary(marcy.ppine)#
marcy.mcon <- read.csv("raw input files/marcy_mcon_2012.csv")#
summary(marcy.mcon)#
#
names(marcy.ppine)#
names(marcy.mcon)#
#
marcy <- rbind(marcy.ppine[,names(marcy.ppine) %in%  names(marcy.mcon)], marcy.mcon)#
summary(marcy)#
# -----------------------------------------------#
#
# -----------------------------------------------#
# Recode Species#
#### ------------#
#### ROSS -- I'll leave it to you to decide what to do with these species#
#### ------------#
# -----------------------------------------------#
unique(ring.data$Species) # PIPO, PIEN, PSME#
unique(tree.data$Species) # PIPO, PIEN, PSME, POTR#
unique(marcy$Species)     # PIPO, PIEN,     , POTR, ABCO#
# Just for now I created 3 categories: PIPO, PIEN, and OTHER#
ring.data$Species.Model <- recode(ring.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
tree.data$Species.Model <- recode(tree.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
marcy$Species.Model <- recode(marcy$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
# -----------------------------------------------#
#
# -----------------------------------------------#
# --------------------------------------------------------------------------------#
#
# --------------------------------------------------------------------------------#
# Pre-GAMM formatting#
# --------------------------------------------------------------------------------#
# -----------------------------------------------#
# Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)#
# -----------------------------------------------#
# Ignoring all the Sites we don't have and doing some exploratory graphing#
tree.data2 <- tree.data[tree.data$PlotID %in% unique(ring.data$PlotID),]#
summary(tree.data2)#
#
# Need to remove species for which we have no pith estimates for the time being#
Species.pith <- unique(tree.data2[!is.na(tree.data2$Pith), "Species"])#
tree.data3 <- tree.data2[tree.data2$Species %in%  Species.pith,]#
summary(tree.data3)#
#
# Making a very basic linear model looking at Site-specific species-DBH..cm.-age relationships#
dbh.age <- lm(Age ~ Species*DBH..cm.*Site-1, data=tree.data3)#
summary(dbh.age)#
summary(dbh.age)$r.squared # Note, this very basic model works pretty well!#
#
# Using the prediction interval to get us a higher upper bound#
age.pi <- predict(dbh.age, newdata=tree.data3, interval="predict")#
summary(age.pi)#
dim(age.pi); dim(tree.data3) # Making sure we didn't lose any rows along the way#
#
tree.data3 <- cbind(tree.data3, age.pi)#
summary(tree.data3)#
#
# Setting the filling window to the upper p.i. limit#
tree.data3$fill.year <- ifelse(is.na(tree.data3$Pith), tree.data3$Year.sample-tree.data3$upr, tree.data3$Pith)#
summary(tree.data3)#
# Merging this back into a data frame that contains info for all the trees we're modeling right now#
tree.data.model <- merge(tree.data3, tree.data2, all.x=T, all.y=T)#
summary(tree.data.model)#
summary(tree.data.model)#
summary(ring.data)#
dim(ring.data)#
#
# Do the actual trimming of years way outside the time frame we're interested in#
for(i in unique(ring.data$TreeID)){#
	#------------------------------#
	#year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)#
	#------------------------------#
	yr.fill <- tree.data.model[tree.data.model$TreeID==i,"fill.year"]#
	#------------------------------#
#
	#------------------------------#
	# The actual insertion of the dummy fil value into the fill range#
	#------------------------------#
	ring.data <- ring.data[!(ring.data$TreeID==i & ring.data$Year<yr.fill),]#
	#------------------------------#
}#
summary(ring.data)#
dim(ring.data)#
#
# -----------------------------------------------#
#
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------#
# Generate the gamm for gap-filling purposes#
# Thought: We could add a factor for initial plot density to get some of the plot effects#
#          that were being captured by the random PlotID effect earlier#
##
# Note: We need to think about at what level we want to fit the spline#
#       -- For the tree ring data, we moved to fitting by plot, but that won't work here#
#       -- My reccomendation would be to fit by species or just by site (i.e. PIPO & MCON#
#          have different patterns, but within the site there's a common history/dynamic)#
# --------------------------------------------------------------------------------#
# The actual gamm; note: I added a fixed modern density effect to try and account for one of the major differences among plots#
gamm.valles.general <- gamm(log(RW) ~ s(Year, bs="cs", k=3, by=Site) + DBH..cm. + Density.Total..stems.ha., random=list(Species.Model=~1, Site=~1), data= ring.data, na.action=na.omit)
save(gamm.valles.general, file="GapFilling_gamm_valles_generalized_2015.04.02.rData")
plot(gamm.valles.general)
plot(gamm.valles.general$gam)
summary(marcy)
names(marcy)["DBH_1"] <- "DBH..cm."
names(marcy)["DBH_1"]
names(marcy)=="DBH_1"
names(marcy)=="DBH_1" <- "DBH..cm."
marcy$PlotID <- paste(marcy$Site, marcy$Transect, sep=".")
summary(marcy)
marcy$PlotID <- as.factor(paste(marcy$Site, marcy$Transect, sep="."))
summary(marcy)
names(marcy)[15]
names(marcy)[16]
marcy.density <- aggregate(marcy[,c("Plot_Radius")], by=list(marcy[,"PlotID"]), FUN=length*pi*10^2)
marcy.density <- aggregate(marcy[,c("Plot_Radius")], by=list(marcy[,"PlotID"]), FUN=length)
summary(marcy.density)
names(marcy.density) <- c("PlotID", "n.stems")
summary(marcy.density)
pi * 10^2
marcy.density$Density.Total..stems.ha. <- marcy.density$n.stems * pi * 10^2 / 10000 # stems/ha
summary(marcy.density)
summary(tree.data)
tree.data <- merge(tree.data, site.data[,c("PlotID", "Density.Total..stems.ha.")], all.x=T, all.y=F)#
ring.data <- merge(ring.data, site.data[,c("PlotID", "Density.Total..stems.ha.")], all.x=T, all.y=F)#
summary(tree.data)#
summary(ring.data)
marcy.density$Density.Total..stems.ha. <- marcy.density$n.stems/(pi*10^2)*10000 # stems/ha
summary(marcy.density)
marcy <- merge(marcy, marcy.density)
summary(marcy)
marcy$Tree_Tag_Number <- as.factor(marcy$Tree_Tag_Number)
summary(marcy)
marcy.fill <- marcy[,c("Tree_Tag_Number", "Species", "Site", "PlotID", "DBH..cm.", "Density.Total..stems.ha.")]
# Merging the two into 1 data frame and doing a bit of formatting#
marcy <- rbind(marcy.ppine[,names(marcy.ppine) %in%  names(marcy.mcon)], marcy.mcon)#
marcy$PlotID <- as.factor(paste(marcy$Site, marcy$Transect, sep="."))#
names(marcy)[16] <- "DBH..cm." #
marcy$Tree_Tag_Number <- as.factor(marcy$Tree_Tag_Number)#
summary(marcy)
# Finding Marcy's plot Densities#
#### ------------#
#### ROSS -- Double check that my assumptions about Marcy's sampling design are correect#
#### ------------#
marcy.density <- aggregate(marcy[,c("Plot_Radius")], by=list(marcy[,"PlotID"]), FUN=length)#
names(marcy.density) <- c("PlotID", "n.stems")#
marcy.density$Density.Total..stems.ha. <- marcy.density$n.stems/(pi*10^2)*10000 # stems/ha#
summary(marcy.density)#
#
# Merging the plot densities back into marcy's data#
marcy <- merge(marcy, marcy.density)#
summary(marcy)
# -----------------------------------------------#
#
# -----------------------------------------------#
# Recode Species#
#### ------------#
#### ROSS -- I'll leave it to you to decide what to do with these species#
#### ------------#
# -----------------------------------------------#
unique(ring.data$Species) # PIPO, PIEN, PSME#
unique(tree.data$Species) # PIPO, PIEN, PSME, POTR#
unique(marcy$Species)     # PIPO, PIEN,     , POTR, ABCO#
# Just for now I created 3 categories: PIPO, PIEN, and OTHER#
ring.data$Species.Model <- recode(ring.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
tree.data$Species.Model <- recode(tree.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
marcy$Species.Model <- recode(marcy$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
# -----------------------------------------------
marcy.fill <- marcy[,c("Tree_Tag_Number", "Species.Model", "Site", "PlotID", "DBH..cm.", "Density.Total..stems.ha.")]
summary(marcy.fill)
rw.dummy <- data.frame(Year=min(ring.data$Year):max(ring.data$Year), RW=NA)#
summary(rw.dummy)
marcy.fill <- merge(marcy.fill, rw.dummy, all.x=T, all.y=T)
summary(marcy.fill)
marcy.fill$RW <- exp(predict(gamm.valles.general, marcy.fill))
summary(ring.data)
summary(tree.data)
tree.data$Density.Total..stems.ha. <- as.numeric(paste(tree.data$Density.Total..stems.ha.))
summary(tree.data)
ring.data$Density.Total..stems.ha. <- as.numeric(paste(ring.data$Density.Total..stems.ha.))
summary(marcy.density)
# --------------------------------------------------------------------------------#
# --------------------------------------------------------------------------------#
# Workflow for modeling generalized tree growth for the Valles Caldera#
# Note: This is developed so that we can use our tree rings to gap-fill the trees#
#       in data from Marcy Litvak.  This means we have to remove at least PlotID &#
#       either generalize species or drop that as well. #
# --------------------------------------------------------------------------------#
# --------------------------------------------------------------------------------#
#
# --------------------------------------------------------------------------------#
# Loading in libraries and some other useful things#
# --------------------------------------------------------------------------------#
# clear memory#
rm(list=ls())#
#
# importing libraries#
library(dplR)#
library(lattice)#
#
# Getting Libraries#
library(reshape)#
library(car)#
library(mgcv)#
library(nlme)#
library(lmeSplines)#
#library(lme4)#
library(splines)#
library(MASS)#
library(MuMIn)#
library(ggplot2)#
library(grid)#
se <- function(x){#
	sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
#
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))#
# -----------------------------------------------#
# --------------------------------------------------------------------------------#
# Loading in & comparing our tree ring data & Marcy's #
#    data so we know how to the structure the gamm#
# --------------------------------------------------------------------------------#
# -----------------------------------------------#
# Tree Ring Data#
# Format: stack all of the core measurements (BAI or RW) to create a single data frame with a single column of measurements and all predictors in other columns#
# -----------------------------------------------#
ring.data <- read.csv("TreeRWL_AllSites_stacked.csv")#
ring.data$Tree <- as.factor(ring.data$Tree) #
ring.data <- ring.data[,!names(ring.data)=="Density..stems.ha."]#
summary(ring.data)#
#
# Tree Data#
tree.data <- read.csv("TreeData.csv")#
tree.data <- tree.data[,!names(tree.data)=="Density..stems.ha."]#
summary(tree.data)#
#
# Site Data (for year cored) #
site.data <- read.csv("raw input files/DOE_plus_valles.csv", na.strings="")#
site.data$Year.sample <- as.numeric(substr(site.data$date.sample,7,10))#
summary(site.data)#
#
# merging in the year sampled into the tree data & calculating age#
# also adding the correct stem density here#
tree.data <- merge(tree.data, site.data[,c("PlotID", "Year.sample")], all.x=T, all.y=F)#
tree.data$PlotID#
tree.data$Age <- tree.data$Year.sample - tree.data$Pith#
summary(tree.data)#
#
# -----------------------------------------------#
#
# -----------------------------------------------#
# subsetting only data for the Valles & Formatting#
# -----------------------------------------------#
ring.data <- ring.data[substr(ring.data$PlotID,1,1)=="V",]#
summary(ring.data)#
tree.data <- tree.data[substr(tree.data$PlotID,1,1)=="V",]#
#
# merge in the modern stem density here#
tree.data <- merge(tree.data, site.data[,c("PlotID", "Density.Total..stems.ha.")], all.x=T, all.y=F)#
ring.data <- merge(ring.data, site.data[,c("PlotID", "Density.Total..stems.ha.")], all.x=T, all.y=F)#
tree.data$Density.Total..stems.ha. <- as.numeric(paste(tree.data$Density.Total..stems.ha.))#
ring.data$Density.Total..stems.ha. <- as.numeric(paste(ring.data$Density.Total..stems.ha.))#
summary(tree.data)#
summary(ring.data)#
#
# Recoding the sites to match Marcy's#
tree.data$Site <- recode(tree.data$Site, "'Valles Caldera Upper'='PPINE'; 'Valles Caldera Lower'='MCON'")#
ring.data$Site <- recode(ring.data$Site, "'Valles Caldera Upper'='PPINE'; 'Valles Caldera Lower'='MCON'")#
summary(ring.data)#
summary(tree.data)#
#
# Just for reference: find the trees that were dated#
trees.dated <- ring.data[ring.data$Dated=="Y","TreeID"]#
# -----------------------------------------------#
#
# -----------------------------------------------#
# Marcy Litvak's data#
#   ***ADD WHATEVER WE NEED TO FOR FORMATTING HERE***#
#	***This might include recoding species in both Marcy's & our data#
#   ***Make sure site codes line up, etc.#
# -----------------------------------------------#
marcy.ppine <- read.csv("raw input files/marcy_ppine_2013.csv")#
summary(marcy.ppine)#
marcy.mcon <- read.csv("raw input files/marcy_mcon_2012.csv")#
summary(marcy.mcon)#
#
names(marcy.ppine)#
names(marcy.mcon)#
#
# Merging the two into 1 data frame and doing a bit of formatting#
marcy <- rbind(marcy.ppine[,names(marcy.ppine) %in%  names(marcy.mcon)], marcy.mcon)#
marcy$PlotID <- as.factor(paste(marcy$Site, marcy$Transect, sep="."))#
names(marcy)[16] <- "DBH..cm." #
marcy$Tree_Tag_Number <- as.factor(marcy$Tree_Tag_Number)#
summary(marcy)#
# Finding Marcy's plot Densities#
#### ------------#
#### ROSS -- Double check that my assumptions about Marcy's sampling design are correect#
#### ------------#
marcy.density <- aggregate(marcy[,c("Plot_Radius")], by=list(marcy[,"PlotID"]), FUN=length)#
names(marcy.density) <- c("PlotID", "n.stems")#
marcy.density$Density.Total..stems.ha. <- marcy.density$n.stems/(pi*10^2)*10000 # stems/ha#
summary(marcy.density)#
#
# Merging the plot densities back into marcy's data#
marcy <- merge(marcy, marcy.density)#
summary(marcy)#
# -----------------------------------------------#
#
# -----------------------------------------------#
# Recode Species#
#### ------------#
#### ROSS -- I'll leave it to you to decide what to do with these species#
#### ------------#
# -----------------------------------------------#
unique(ring.data$Species) # PIPO, PIEN, PSME#
unique(tree.data$Species) # PIPO, PIEN, PSME, POTR#
unique(marcy$Species)     # PIPO, PIEN,     , POTR, ABCO#
# Just for now I created 3 categories: PIPO, PIEN, and OTHER#
ring.data$Species.Model <- recode(ring.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
tree.data$Species.Model <- recode(tree.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
marcy$Species.Model <- recode(marcy$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")#
# -----------------------------------------------
# -----------------------------------------------#
# --------------------------------------------------------------------------------#
#
# --------------------------------------------------------------------------------#
# Pre-GAMM formatting#
# --------------------------------------------------------------------------------#
# -----------------------------------------------#
# Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)#
# -----------------------------------------------#
# Ignoring all the Sites we don't have and doing some exploratory graphing#
tree.data2 <- tree.data[tree.data$PlotID %in% unique(ring.data$PlotID),]#
summary(tree.data2)#
#
# Need to remove species for which we have no pith estimates for the time being#
Species.pith <- unique(tree.data2[!is.na(tree.data2$Pith), "Species"])#
tree.data3 <- tree.data2[tree.data2$Species %in%  Species.pith,]#
summary(tree.data3)#
#
# Making a very basic linear model looking at Site-specific species-DBH..cm.-age relationships#
dbh.age <- lm(Age ~ Species*DBH..cm.*Site-1, data=tree.data3)#
summary(dbh.age)#
summary(dbh.age)$r.squared # Note, this very basic model works pretty well!#
#
# Using the prediction interval to get us a higher upper bound#
age.pi <- predict(dbh.age, newdata=tree.data3, interval="predict")#
summary(age.pi)#
dim(age.pi); dim(tree.data3) # Making sure we didn't lose any rows along the way#
#
tree.data3 <- cbind(tree.data3, age.pi)#
summary(tree.data3)#
#
# Setting the filling window to the upper p.i. limit#
tree.data3$fill.year <- ifelse(is.na(tree.data3$Pith), tree.data3$Year.sample-tree.data3$upr, tree.data3$Pith)#
summary(tree.data3)#
# Merging this back into a data frame that contains info for all the trees we're modeling right now#
tree.data.model <- merge(tree.data3, tree.data2, all.x=T, all.y=T)#
summary(tree.data.model)#
summary(tree.data.model)#
summary(ring.data)#
dim(ring.data)#
#
# Do the actual trimming of years way outside the time frame we're interested in#
for(i in unique(ring.data$TreeID)){#
	#------------------------------#
	#year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)#
	#------------------------------#
	yr.fill <- tree.data.model[tree.data.model$TreeID==i,"fill.year"]#
	#------------------------------#
#
	#------------------------------#
	# The actual insertion of the dummy fil value into the fill range#
	#------------------------------#
	ring.data <- ring.data[!(ring.data$TreeID==i & ring.data$Year<yr.fill),]#
	#------------------------------#
}#
summary(ring.data)#
dim(ring.data)#
#
# -----------------------------------------------#
#
# --------------------------------------------------------------------------------#
# --------------------------------------------------------------------------------#
# Generate the gamm for gap-filling purposes#
# Thought: We could add a factor for initial plot density to get some of the plot effects#
#          that were being captured by the random PlotID effect earlier#
##
# Note: We need to think about at what level we want to fit the spline#
#       -- For the tree ring data, we moved to fitting by plot, but that won't work here#
#       -- My reccomendation would be to fit by species or just by site (i.e. PIPO & MCON#
#          have different patterns, but within the site there's a common history/dynamic)#
##
# Note: In the gamm below, DBH and Density are the modern DBH and density because we can't fit#
# --------------------------------------------------------------------------------#
# The actual gamm; note: I added a fixed modern density effect to try and account for one of the major differences among plots#
gamm.valles.general <- gamm(log(RW) ~ s(Year, bs="cs", k=3, by=Site) + DBH..cm. + Density.Total..stems.ha., random=list(Species.Model=~1, Site=~1), data= ring.data, na.action=na.omit)#
#
# This plots the overall shape of growth curves by site#
#     Take a look. This actually makes a good argument for the sites sharing a common history#
plot(gamm.valles.general$gam)#
#
# Saving the GAMM From above so we can load it without having to refit it#
save(gamm.valles.general, file="GapFilling_gamm_valles_generalized_2015.04.02.rData")#
#
# -------------------------------
plot(gamm.valles.general$gam)
save(gamm.valles.general, file="GapFilling_gamm_valles_generalized_2015.04.02.rData")
# --------------------------------------------------------------------------------#
# Apply the gamm to Mary's data#
# --------------------------------------------------------------------------------#
# -----------------------------------------------#
# Create a blank data set from Marcy's data#
# -----------------------------------------------#
summary(marcy)#
marcy.fill <- marcy[,c("Tree_Tag_Number", "Species.Model", "Site", "PlotID", "DBH..cm.", "Density.Total..stems.ha.")]#
summary(marcy.fill)#
# Creating a vector of years and dummy ring widths we're going to want to fill#
rw.dummy <- data.frame(Year=min(ring.data$Year):max(ring.data$Year), RW=NA)#
summary(rw.dummy)#
#
# merge the dummy frame with Marcy's trees#
marcy.fill <- merge(marcy.fill, rw.dummy, all.x=T, all.y=T)#
summary(marcy.fill)#
# -----------------------------------------------
# -----------------------------------------------#
# Apply the gamm to Marcy's data#
# -----------------------------------------------#
marcy.fill$RW <- exp(predict(gamm.valles.general, marcy.fill))
summary(marcy.fill)
write.csv(marcy.fill, "GapFilling_Litvak_Raw.csv", row.names=F)
marcy.fill <- marcy.fill[!is.na(marcy.fill$RW),]
summary(marcy.fill)
core.data <- read.csv("raw input files/Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the Site the trees belong to#
names(core.data)
marcy.fill2 <- recast(marcy.fill[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number)
summary(marcy.fill)
marcy.fill$Year <- as.factor(marcy.fill$Year)
summary(marcy.fill)
marcy.fill2 <- recast(marcy.fill[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number)
summary(marcy.fill2)
marcy.fill2 <- recast(marcy.fill[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, Fun=MEAN)
marcy.fill2 <- recast(marcy.fill[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, Fun=mean)
summary(marcy.fill2)
marcy.fill2 <- recast(marcy.fill[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, FUN=mean)
summary(marcy.fill2)
?recast
summary(marcy.fill)
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill[,c("Tree_Tag_Number", "Year", "PlotID")]), fun=mean)
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill[,c("Tree_Tag_Number", "Year", "PlotID")]), FUN=mean)
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill$"Tree_Tag_Number", marcy.fill$Year, marcy.fill$PlotID)), FUN=mean)
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill$Tree_Tag_Number, marcy.fill$Year, marcy.fill$PlotID)), FUN=mean)
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill$Tree_Tag_Number, marcy.fill$Year, marcy.fill$PlotID), FUN=mean)
summary(marcy.fill2)
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill$Tree_Tag_Number, marcy.fill$Year), FUN=mean)
summary(marcy.fill2)
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill$Tree_Tag_Number, marcy.fill$Year), FUN=mean)#
names(marcy.fill2) <- c("Tree_Tag_Number", "Year", "RW")#
summary(marcy.fill2)
marcy.fill3 <- recast(marcy.fill2[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, FUN=mean)
summary(marcy.fill3)
marcy.fill3[1:10,1:10]
row.names(marcy.fill3) <- marcy.fill$Year
row.names(marcy.fill3) <- marcy.fill3$Year
marcy.fill3 <- marcy.fill3[,2:ncol(marcy.fill3)]
summary(marcy.fill3)
marcy.fill3[1:10,1:10]
marcy.fill3 <- marcy.fill3[order(row.names(marcy.fill3), decreasing=T),]
summary(marcy.fill3)
marcy.fill3[1:10,1:10]
summary(marcy)
marcy.dbh <- marcy.fill3#
for(j in names(marcy.dbh)){#
	# put NA in any rows older than when the tree was last measured#
	marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year")],j] <- NA#
#
	# Put DBH in the year dbh last measured in the dield#
	marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "Year"])#
	# Doing the actual DBH reconstruction#
	for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}#
	# We don't have any estimated pith dates, so we're just going to stop when DBH goes negative#
	marcy.dbh[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.dbh[,j]) #
}
j
marcy.dbh <- marcy.fill3
for(j in names(marcy.dbh)){#
	# put NA in any rows older than when the tree was last measured#
	marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"])],j] <- NA#
#
	# Put DBH in the year dbh last measured in the dield#
	marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "Year"])#
	# Doing the actual DBH reconstruction#
	for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}#
	# We don't have any estimated pith dates, so we're just going to stop when DBH goes negative#
	marcy.dbh[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.dbh[,j]) #
}
# --------------------------------------------------------------------------------#
summary(marcy)#
#
# Get rid of trees that had no DBH & making year a factor for recasting#
marcy.fill <- marcy.fill[!is.na(marcy.fill$RW),]#
marcy.fill$Year <- as.factor(marcy.fill$Year)#
summary(marcy.fill)#
#
# Some trees are in the dataframe twice for some reason.  #
# Going to aggregate to take the mean ring width just to be safe#
marcy.fill2 <- aggregate(marcy.fill[,"RW"], by=list(marcy.fill$Tree_Tag_Number, marcy.fill$Year), FUN=mean)#
names(marcy.fill2) <- c("Tree_Tag_Number", "Year", "RW")#
summary(marcy.fill2)#
#
# Re-casting the data so that trees are columns and years are rows#
#   Then deleting the Year column & sorting the data so that most recent is tat the top#
marcy.fill3 <- recast(marcy.fill2[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, FUN=mean)#
row.names(marcy.fill3) <- marcy.fill3$Year#
marcy.fill3 <- marcy.fill3[,2:ncol(marcy.fill3)]#
marcy.fill3 <- marcy.fill3[order(row.names(marcy.fill3), decreasing=T),]#
summary(marcy.fill3[,1:20])#
marcy.fill3[1:10,1:10]
marcy.dbh <- marcy.fill3
j
names(marcy.dbh)
h="461"
j="461"
max(marcy[marcy$Tree_Tag_Number==j, "Year"])
marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"])],j] <- NA
as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"])
marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA
marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "Year"])
for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}
marcy.dbh[,j]
marcy.dbh <- marcy.fill3
marcy.dbh[,j]
marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA
marcy.dbh[,j]
marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "Year"])
marcy.dbh[,j]
marcy.fill3[as.numeric(row.names(marcy.fill3))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA
is.na(marcy.fill3[i-1,j])
marcy.dbh[i,j]
i
i=2
marcy.dbh[,j]
for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}
marcy.dbh[,j]
marcy.fill3[as.numeric(row.names(marcy.fill3))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
	marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
#
	# Put DBH in the year dbh last measured in the dield#
	marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "DBH..cm."])
marcy.dbh[,j]
for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}
marcy.dbh[,j]
marcy.dbh[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.dbh[,j])
marcy.dbh[,j]
marcy.fill3 <- recast(marcy.fill2[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, FUN=mean)#
row.names(marcy.fill3) <- marcy.fill3$Year#
marcy.fill3 <- marcy.fill3[,2:ncol(marcy.fill3)]#
marcy.fill3 <- marcy.fill3[order(row.names(marcy.fill3), decreasing=T),]#
summary(marcy.fill3[,1:20])#
marcy.fill3[1:10,1:10]#
marcy.dbh <- marcy.fill3#
for(j in names(marcy.dbh)){#
	# put NA in any rows older than when the tree was last measured#
	marcy.fill3[as.numeric(row.names(marcy.fill3))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
	marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
#
	# Put DBH in the year dbh last measured in the dield#
	marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "DBH..cm."])#
	# Doing the actual DBH reconstruction#
	for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}#
	# We don't have any estimated pith dates, so we're just going to stop when DBH goes negative#
	marcy.dbh[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.dbh[,j]) #
}
# Re-casting the data so that trees are columns and years are rows#
#   Then deleting the Year column & sorting the data so that most recent is tat the top#
marcy.fill3 <- recast(marcy.fill2[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, FUN=mean)#
row.names(marcy.fill3) <- marcy.fill3$Year#
marcy.fill3 <- marcy.fill3[,2:ncol(marcy.fill3)]#
marcy.fill3 <- marcy.fill3[order(row.names(marcy.fill3), decreasing=T),]#
summary(marcy.fill3[,1:20])#
marcy.fill3[1:10,1:10]#
marcy.dbh <- marcy.fill3#
for(j in names(marcy.dbh)){#
	# put NA in any rows older than when the tree was last measured#
	marcy.fill3[as.numeric(row.names(marcy.fill3))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
	marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
#
	# Put DBH in the year dbh last measured in the dield#
	marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "DBH..cm."])#
	# Doing the actual DBH reconstruction#
	for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}#
	# We don't have any estimated pith dates, so we're just going to stop when DBH goes negative#
	marcy.dbh[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.dbh[,j]) #
	marcy.fill3[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.marcy.fill3[,j]) #
}
# Re-casting the data so that trees are columns and years are rows#
#   Then deleting the Year column & sorting the data so that most recent is tat the top#
marcy.fill3 <- recast(marcy.fill2[,c("Year", "Tree_Tag_Number", "RW")], Year ~ Tree_Tag_Number, FUN=mean)#
row.names(marcy.fill3) <- marcy.fill3$Year#
marcy.fill3 <- marcy.fill3[,2:ncol(marcy.fill3)]#
marcy.fill3 <- marcy.fill3[order(row.names(marcy.fill3), decreasing=T),]#
summary(marcy.fill3[,1:20])#
marcy.fill3[1:10,1:10]#
marcy.dbh <- marcy.fill3#
for(j in names(marcy.dbh)){#
	# put NA in any rows older than when the tree was last measured#
	marcy.fill3[as.numeric(row.names(marcy.fill3))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
	marcy.dbh[as.numeric(row.names(marcy.dbh))>max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- NA#
#
	# Put DBH in the year dbh last measured in the dield#
	marcy.dbh[as.numeric(row.names(marcy.dbh))==max(marcy[marcy$Tree_Tag_Number==j, "Year"]),j] <- max(marcy[marcy$Tree_Tag_Number==j, "DBH..cm."])#
	# Doing the actual DBH reconstruction#
	for(i in 2:(length(marcy.dbh[,j]))){#
		marcy.dbh[i,j] <- ifelse(!is.na(marcy.fill3[i-1,j]), marcy.dbh[i-1,j] - marcy.fill3[i-1,j]*2, marcy.dbh[i,j]) # subtracting the previous year's growth from DBH..cm. to get that year's DBH..cm.#
	}#
	# We don't have any estimated pith dates, so we're just going to stop when DBH goes negative#
	marcy.dbh[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.dbh[,j]) #
	marcy.fill3[,j] <- ifelse(marcy.dbh[,j]<0, NA, marcy.fill3[,j]) #
}
marcy.dbh[,j]
marcy.fill3[,j]
write.csv(marcy.dbh, "Gapfilling_DBHrecon_Litvak.csv", row.names=T)#
write.csv(marcy.fill3, "Gapfilling_RingWidths_Modeled_Final_Litvak.csv", row.names=T)
release.minor <- read.csv("Trees_ReleaseEvents_MinorRelease.csv", row.names=1)#
dim(release.minor)#
release.minor[1:10, 1:11]#
# years <- disturb$Year#
#
release.majoar <- read.csv("Trees_ReleaseEvents_MajorRelease.csv", row.names=1)#
dim(release.major)#
release.major[1:10, 1:11]#
#
dim(dated.rw)#
dim(release.major)#
dim(release.minor)
release.minor <- read.csv("Trees_ReleaseEvents_MinorRelease.csv", row.names=1)#
dim(release.minor)#
release.minor[1:10, 1:11]#
# years <- disturb$Year#
#
release.majar <- read.csv("Trees_ReleaseEvents_MajorRelease.csv", row.names=1)#
dim(release.major)#
release.major[1:10, 1:11]#
#
dim(dated.rw)#
dim(release.major)#
dim(release.minor)
release.major <- read.csv("Trees_ReleaseEvents_MajorRelease.csv", row.names=1)
release.major <- read.csv("Trees_ReleaseEvents_MajorRelease.csv", row.names=1)#
dim(release.major)#
release.major[1:10, 1:11]#
#
dim(dated.rw)#
dim(release.major)#
dim(release.minor)
tree.rw <- read.csv("tree_rw.csv", header=T, row.names=1)#
summary(tree.rw)#
dated.rw <- tree.rw[,substr(names(tree.rw),1,1)=="V" & names(tree.rw) %in% trees.use$TreeID]#
summary(dated.rw)
tree.data <- read.csv("TreeData.csv", header=T)#
summary(tree.data)#
#trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" | substr(tree.data$PlotID, 1, 2)=="MM",]#
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" & tree.data$Dated=="Y",]#
trees.use <- trees.use[!is.na(trees.use$TreeID),]#
head(trees.use)#
dim(trees.use)#
tree.rw <- read.csv("tree_rw.csv", header=T, row.names=1)#
summary(tree.rw)#
dated.rw <- tree.rw[,substr(names(tree.rw),1,1)=="V" & names(tree.rw) %in% trees.use$TreeID]#
summary(dated.rw)
release.minor <- read.csv("Trees_ReleaseEvents_MinorRelease.csv", row.names=1)#
dim(release.minor)#
release.minor[1:10, 1:11]#
# years <- disturb$Year#
#
release.major <- read.csv("Trees_ReleaseEvents_MajorRelease.csv", row.names=1)#
dim(release.major)#
release.major[1:10, 1:11]#
#
dim(dated.rw)#
dim(release.major)#
dim(release.minor)
# Stacking RW measurements#
dated.stack <- stack(dated.rw)#
names(dated.stack) <- c("RW", "TreeID")#
dated.stack$Year <- as.numeric(paste(row.names(dated.rw)))#
dated.stack$Stems <- ifelse(dated.stack$RW>0, 1, NA)#
dated.stack$PlotID <- as.factor(substr(dated.stack$TreeID,1,4)) #
dated.stack$Site <- as.factor(substr(dated.stack$TreeID,1,3)) #
summary(dated.stack)#
#
# Stacking Minor Releases#
minor.stack <- stack(release.minor)#
names(minor.stack) <- c("Release.Minor", "TreeID")#
# minor.stack$Disturb <- ifelse(minor.stack$Disturb==0, NA, minor.stack$Disturb)#
minor.stack$Year <- as.numeric(paste(row.names(release.minor)))#
summary(minor.stack)#
#
# Stacking Major Releases#
major.stack <- stack(release.major)#
names(major.stack) <- c("Release.Major", "TreeID")#
# minor.stack$Disturb <- ifelse(minor.stack$Disturb==0, NA, minor.stack$Disturb)#
major.stack$Year <- as.numeric(paste(row.names(release.major)))#
summary(major.stack)#
#
minor.stack[1:20,]#
major.stack[1:20,]
release.stack <- merge(minor.stack, major.stack, all.x=T, all.y=T)#
release.stack$Release.Minor <- ifelse(release.stack$Release.Minor >= 2, NA, release.stack$Release.Minor)#
summary(release.stack)#
dim(release.stack);dim(minor.stack); dim(major.stack)#
#
# Merging BAI measurements with Release Events#
dated.stack2 <- merge(dated.stack, release.stack, all.x=T, all.y=T)#
dated.stack2$n.Minor <- ifelse(release.stack$Release.Minor>0,1,NA)#
dated.stack2$n.Major <- ifelse(release.stack$Release.Major>0,1,NA)#
summary(dated.stack2)#
dim(dated.stack)
release.plot1 <- aggregate(dated.stack2[,c("Release.Minor", "Release.Major")], by=list(dated.stack2$Year, dated.stack2$PlotID, dated.stack2$Site), FUN=mean, na.rm=T)#
names(release.plot1) <- c("Year", "PlotID", "Site", "Release.Minor", "Release.Major")#
summary(release.plot1)
release.plot2 <- aggregate(dated.stack2[,c("n.Minor", "n.Major", "Stems")], by=list(dated.stack2$Year, dated.stack2$PlotID, dated.stack2$Site), FUN=sum, na.rm=T)#
names(release.plot2) <- c("Year", "PlotID", "Site", "n.Minor", "n.Major", "n.Plot")#
summary(release.plot2)#
#
hist(release.plot2$n.Major)#
hist(release.plot2$n.Plot)#
unique(release.plot2$n.Major)
dim(release.plot1); dim(release.plot2)#
release.plot <- merge(release.plot1, release.plot2, all.x=T, all.y=T)#
release.plot$p.Minor <- release.plot$n.Minor/release.plot$n.Plot#
release.plot$p.Major <- release.plot$n.Major/release.plot$n.Plot#
# release.plot$Trans <- as.factor(substr(release.plot$PlotID,4,4))#
release.plot$Plot <- as.factor(substr(release.plot$PlotID,4,4))#
release.plot <- release.plot[,c("PlotID", "Site", "Plot", "Year", "Release.Minor", "Release.Major", "n.Minor", "n.Major", "n.Plot", "p.Minor", "p.Major")]#
release.plot$Plot <- recode(release.plot$Plot, "'0'= 'A'; 1 = 'B' ")#
summary(release.plot)#
dim(release.plot)
library(car)
dim(release.plot1); dim(release.plot2)#
release.plot <- merge(release.plot1, release.plot2, all.x=T, all.y=T)#
release.plot$p.Minor <- release.plot$n.Minor/release.plot$n.Plot#
release.plot$p.Major <- release.plot$n.Major/release.plot$n.Plot#
# release.plot$Trans <- as.factor(substr(release.plot$PlotID,4,4))#
release.plot$Plot <- as.factor(substr(release.plot$PlotID,4,4))#
release.plot <- release.plot[,c("PlotID", "Site", "Plot", "Year", "Release.Minor", "Release.Major", "n.Minor", "n.Major", "n.Plot", "p.Minor", "p.Major")]#
release.plot$Plot <- recode(release.plot$Plot, "'0'= 'A'; 1 = 'B' ")#
summary(release.plot)#
dim(release.plot)
# Calculate mean release event for trees that do not have NA#
release.plot1 <- aggregate(dated.stack2[,c("Release.Minor", "Release.Major")], by=list(dated.stack2$Year, dated.stack2$PlotID, dated.stack2$Site), FUN=mean, na.rm=T)#
names(release.plot1) <- c("Year", "PlotID", "Site", "Release.Minor", "Release.Major")#
summary(release.plot1)#
#
release.plot2 <- aggregate(dated.stack2[,c("n.Minor", "n.Major", "Stems")], by=list(dated.stack2$Year, dated.stack2$PlotID, dated.stack2$Site), FUN=sum, na.rm=T)#
names(release.plot2) <- c("Year", "PlotID", "Site","n.Minor", "n.Major", "n.Plot")#
summary(release.plot2)#
#
hist(release.plot2$n.Major)#
hist(release.plot2$n.Plot)#
unique(release.plot2$n.Major)#
#
dim(release.plot1); dim(release.plot2)#
release.plot <- merge(release.plot1, release.plot2, all.x=T, all.y=T)#
release.plot$p.Minor <- release.plot$n.Minor/release.plot$n.Plot#
release.plot$p.Major <- release.plot$n.Major/release.plot$n.Plot#
# release.plot$Trans <- as.factor(substr(release.plot$PlotID,4,4))#
release.plot$Plot <- as.factor(substr(release.plot$PlotID,4,4))#
release.plot <- release.plot[,c("PlotID", "Site", "Plot", "Year","Release.Minor", "Release.Major", "n.Minor", "n.Major", "n.Plot", "p.Minor", "p.Major")]#
release.plot$Plot <- recode(release.plot$Plot, "'0'='A'; '1'='B'")#
summary(release.plot)#
dim(release.plot)
# Setting a minimum threshold#
release.plot2 <- release.plot#
release.plot2$p.Minor <- ifelse(release.plot2$p.Minor<0.25, 0, release.plot2$p.Minor)#
release.plot2$p.Major <- ifelse(release.plot2$p.Major<0.25, 0, release.plot2$p.Major)#
summary(release.plot2)#
#
min(release.plot2[release.plot2$p.Minor>0, "p.Minor"], na.rm=T)#
hist(release.plot2[release.plot2$p.Minor>0, "p.Minor"])
ggplot(data=release.plot2[release.plot2$Site=="VLF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
library(ggplot2)
ggplot(data=release.plot2[release.plot2$Site=="VLF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
library(ggplot2)#
library(grid)#
library(dplR)#
####################################################
se <- function(x){#
	sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
#
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))	#
#
large.axes2 <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=18), axis.text.y=element_text(color="black", size=18), axis.title.x=element_text(face="bold", size=20, vjust=-1),  axis.title.y=element_text(face="bold", size=20, vjust=0.2), plot.margin=unit(c(2,2,2,2), "lines")) + theme(legend.position=c(0.2,0.8), legend.text=element_text(size=20), legend.title=element_text(size=20), legend.background=element_rect(fill="white"), legend.key=element_rect(color="white", fill=NA)) + theme(strip.text=element_text(size=rel(1.25), face="bold"))
ggplot(data=release.plot2[release.plot2$Site=="VLF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
# Setting a minimum threshold#
release.plot2 <- release.plot#
release.plot2$p.Minor <- ifelse(release.plot2$p.Minor<0.25, 0, release.plot2$p.Minor)#
release.plot2$p.Major <- ifelse(release.plot2$p.Major<0.25, 0, release.plot2$p.Major)#
summary(release.plot2)#
#
min(release.plot2[release.plot2$p.Minor>0, "p.Minor"], na.rm=T)#
hist(release.plot2[release.plot2$p.Minor>0, "p.Minor"])#
#
ggplot(data=release.plot2[release.plot2$Site=="VLF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
ggplot(data=release.plot2[release.plot2$Site=="VLF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1)
ggplot(data=release.plot2[release.plot2$Site=="VLF",]) + geom_histogram(aes(x=Year, weight=p.Major), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
ggplot(data=release.plot2[release.plot2$Site=="VUF",]) + geom_histogram(aes(x=Year, weight=p.Major), binwidth=1) + facet_grid(PlotID ~ .) + large.axes2 + scale_x_continuous(breaks=c(1800,1850,1900,1950,2000)) +  scale_y_continuous(breaks=c(0.5))
ggplot(data=release.plot2[,]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
ggplot(data=release.plot2[release.plot2$Site=="VUF",]) + geom_histogram(aes(x=Year, weight=p.Major), binwidth=1) + facet_grid(Plot ~ .) + large.axes2 + scale_x_continuous(breaks=c(1800,1850,1900,1950,2000)) +  scale_y_continuous(breaks=c(0.5))
ggplot(data=release.plot2[release.plot2$Site=="VUF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
ggplot(data=release.plot2[release.plot2$Site=="VLF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
ggplot(data=release.plot2[release.plot2$Site=="VUF",]) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site ~ Plot) + large.axes2 + scale_x_continuous(breaks=c(1900,2000))
###############################################################################
# Aggregating to the Site Level (mostly for graphing)#
###############################################################################
release.plot <- read.csv("ReleaseEvents_Plots.csv")#
release.plot[is.na(release.plot)] <- 0#
summary(release.plot)
release.site <- aggregate(release.plot[,c("Release.Minor", "Release.Major", "p.Minor", "p.Major"),], by=list(release.plot$Site, release.plot$Year), FUN=mean, na.rm=T)#
names(release.site) <- c("Site", "Year", names(release.site[,3:ncol(release.site)]))#
release.site$Site.NS <- recode(release.site$Site, "'VLF'='1'; 'VUF'='2'")#
levels(release.site$Site.NS) <- c("VLF", "VUF")#
summary(release.site)
ggplot(data=release.site[release.site$p.Major>=0.25,]) + geom_histogram(aes(x=Year, weight=p.Major), binwidth=1) + facet_grid(Site ~ .) + large.axes2 + scale_x_continuous(breaks=c(1800,1850,1900,1950,2000)) +  scale_y_continuous(breaks=c(0,0.25))
summary(release.site)
ggplot(data=release.site[release.site$p.Major>=0.25,]) + geom_histogram(aes(x=Year, weight=p.Major), binwidth=1) + facet_grid(Site ~ .)
gplot(data=release.site) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site.NS ~ .) + large.axes2 + scale_x_continuous(limits=c(1950, 2014), breaks=c(1950,1960,1970,1980,1990,2000)) +  scale_y_continuous(name="Percent Trees Meeting Criteria", breaks=c(0,0.15))+#
  ggtitle("Minor Releases")
ggplot(data=release.site) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site.NS ~ .) + large.axes2 + scale_x_continuous(limits=c(1950, 2014), breaks=c(1950,1960,1970,1980,1990,2000)) +  scale_y_continuous(name="Percent Trees Meeting Criteria", breaks=c(0,0.15))+#
  ggtitle("Minor Releases")
ggplot(data=release.site) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site.NS ~ .) + large.axes2 + scale_x_continuous(limits=c(1950, 2014), breaks=c(1950,1960,1970,1980,1990,2000)) +  scale_y_continuous(name="Percent Trees Meeting Criteria", breaks=c(0,0.5))+#
  ggtitle("Minor Releases")
ggplot(data=release.site) + geom_histogram(aes(x=Year, weight=p.Minor), binwidth=1) + facet_grid(Site.NS ~ .) + large.axes2 + scale_x_continuous(limits=c(1950, 2014), breaks=c(1950,1960,1970,1980,1990,2000)) +  scale_y_continuous(name="Percent Trees Meeting Criteria", breaks=c(0,0.5), limits=c(0, 0.5))+#
  ggtitle("Minor Releases")
ggplot(data=release.site) + geom_histogram(aes(x=Year, weight=p.Major), binwidth=1) + facet_grid(Site.NS ~ .) + large.axes2 + scale_x_continuous(limits=c(1950, 2014),breaks=c(1950,1960,1970,1980,1990,2000)) +  scale_y_continuous(name="Percent Trees Meeting Criteria", breaks=c(0,0.15))+#
  ggtitle("Major Releases")
ggplot(data=release.site) + geom_histogram(aes(x=Year, weight=p.Major), binwidth=1) + facet_grid(Site.NS ~ .) + large.axes2 + scale_x_continuous(limits=c(1950, 2014),breaks=c(1950,1960,1970,1980,1990,2000)) +  scale_y_continuous(name="Percent Trees Meeting Criteria", breaks=c(0,0.25), limits=c(0,0.25))+#
  ggtitle("Major Releases")
#################################################################################
# assessing the differences between Marcy BM recon and Valles BM recon#
#################################################################################
#
load("marcy_bm_recon.Rdata") #loads in the biom.marcy#
load("valles_bm_recon.Rdata") #loads in the biom.valles#
summary(biom.marcy)#
#
names(biom.marcy)#
#
#################################################################################
# making mean Site biomass for Marcy's PIPO data#
#################################################################################
names(biom.marcy)
marcy.pipo.bm <- data.frame(apply(biom.marcy[,c(5:8)], 1, mean))#
marcy.pipo.ci <- apply(biom.marcy[,c(5:8)], 1, quantile, c(0.025, 0.975))#
summary(marcy.pipo.ci)
dim(biom.marcy)
summary(biom.marcy)
summary(biom.valles)
