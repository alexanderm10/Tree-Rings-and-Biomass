names(tree.deets) <- "ID"
summary(tree.deets)
names(core.data)
# Getting tree level data
for(i in unique(tree.deets$ID)){
tree.deets[tree.deets$ID==i, "DBH"] <- tree.data[tree.data$TreeID==i,"dbh"]
}
summary(tree.deets)
#diameter reconstructions of each tree from the trees that dated??
dbh.recon <- tree.rw
summary(dbh.recon)
summary(tree.deets)
for(j in seq_along(dbh.recon)){
# inserting 2012 DBH
dbh.recon[1,j] <- tree.deets[tree.deets$ID==names(dbh.recon[j]),"DBH"]
for(i in 2:(length(dbh.recon[,j]))){
dbh.recon[i,j] <- ifelse(!is.na(tree.rw[i,j]), dbh.recon[i-1,j] - tree.rw[i-1,j]*2, tree.rw[i,j]*2) # subtracting the previous year's growth from DBH to get that year's DBH
}
}
summary(dbh.recon)
library(dplR)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
#################################################################################################
# Loading up .csv file that has meta data and RWL files for ring widths
# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother
#################################################################################################
#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH
#loading the dplR to use the basal area reconstruction functions.
core.data <- read.csv("Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)
#adding a column include which plot at the site the trees belong to
names(core.data)
core.data$plot <- substr(core.data$plot.id, 3, 3)
core.data$plot <- as.factor(core.data$plot)
summary(core.data)
tree.data <- read.csv("tree_metadata_DOE_plus_valles.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)
#adding a column include which plot at the site the trees belong to
names(tree.data)
tree.data$plot <- substr(tree.data$PlotID, 3, 3)
tree.data$plot <- as.factor(tree.data$plot)
summary(tree.data)
#load in core details data sheet.  Has living/dead, pith info, measurement info.
#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.
#Removing NA's from the files
# FUTURE NOTE: need to create a generalizeable file to house all RW measurements
core.rw <- read.rwl("valles_all_trees.rwl")
head(core.rw)
summary(core.rw)
#removing the extra character that tellervo adds
names(core.rw)<-substr(names(core.rw), 1, 7)
names(core.rw)
# NOTE: Unit Conversion Step
#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR)
summary(core.rw)
core.rw <- core.rw/10
summary(core.rw)
# ----------------------------------------------------------------------------
#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!
# Separating Dead vs. Missing rings
# What we need to know:
#1) Dead trees -- fill missing years with 0
#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0
#3) Live Trees, missing part of core -- model growth
# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years
for(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer
# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone
# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)
if(!is.na(core.data[core.data$CoreID==j, "zombie"]) | core.data[core.data$CoreID==j, "live.dead"]=="DEAD"){
last.meas <- as.numeric(core.data[core.data$CoreID==j, "outer.measured"]) # last ring which was mesured
last.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)
if(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled
inner.fill <- which(row.names(core.rw)== last.meas+1)
outer.fill <- which(row.names(core.rw)==last.yr)
core.rw[inner.fill:outer.fill,j] <- 0
}
}
}
summary(core.rw)
# ----------------------------------------------------------------------------
##########################################################################
#AGGREGATION STEP
#taking ring widths and aggregating from the core level to the tree level
##########################################################################
# ----------------------------------------------------------------------------
# aggregate to the tree level using only dated trees where possible
trees <- unique(substr(names(core.rw), 1, 6)) # listing trees we have measurements for
tree.rw <- data.frame(array(NA, dim=c(nrow(core.rw), length(trees)))) # a blank data frame to put everything in
row.names(tree.rw) <- row.names(core.rw)  # labeling the rows with the years from our rwl
names(tree.rw)<-unique(substr(names(core.rw), 1, 6)) # labeling the columns as trees
# summary(tree.rw) # this will get really big very quickly
dim(tree.rw) # 176 trees, 107 years of data
# The Aggregation Loop
for(i in unique(trees)){
cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with
cores <- names(core.rw)[cols] # getting the name of the cores we're working with
# -----------------------
# if there's only one core, we just take that regardless of wheter it's dated or not
if(length(cols) == 1){
tree.rw[,which(trees==i)] <- core.rw[,cols]
# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")
ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")
# Finding a (best-guess) pith date for the tree
tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores, "pith.yr"]
# -----------------------
} else {
# -----------------------
# if there's more than 1 core, we need to figure out which if any were dated
use <- vector(length=length(cols))
for(x in 1:length(cols)){
ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")
}
# -----------------------
# -----------------------
# now we know which were dated, so we can use that to figure out which cores to average
if(length(use[use=="TRUE"])==1) {
# if only 1 core is dated, use only that core and call the tree dated
tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]
tree.data[tree.data$TreeID==i, "Dated"] <- "Y"
tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]
# -----------------------
} else if(length(use[use=="TRUE"])>1) {
# -----------------------
# If there's greater than one dated core, take the mean of the dated cores and call the tree dated
tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)
tree.data[tree.data$TreeID==i, "Dated"] <- "Y"
tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)
} else {
# -----------------------
# If no cores are dated, take the mean of whatever we have and call the tree undated
tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T)
tree.data[tree.data$TreeID==i, "Dated"] <- "N"
tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)
# -----------------------
}
}
}
# Note: There are some warnings, but I think it's okay
# summary(tree.rw)
min(tree.rw, na.rm=T); max(tree.rw, na.rm=T)
dim(tree.rw)
# We've updated the tree.data file, so lets save our changes before we move any further
# We only added a new column and didn't change anything that was original, so it should be okay, but lets just double check before moving forward
tree.data$Dated <- as.factor(tree.data$Dated)
summary(tree.data)
# NOTE: right now you have a ridculously long name for your tree data spreadsheet, so I'm going to call it something different for my own sanity right now :-P
write.csv(tree.data, "TreeData.csv", row.names=F)
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# CRR: writing our tree RWL to a csv formatted for gap filling before we calculate BAI (bc some have missing outsides and that's bad if we're working outside-in in out calculations)
# stacking the RWL so that we have a single column of ring widths & an identifying column with TreeID
tree.stack <- stack(tree.rw)
names(tree.stack) <- c("RW", "TreeID")
tree.stack$Year <- as.numeric(row.names(tree.rw)) # adding in the years
summary(tree.stack)
# attaching all of our useful tree data
summary(tree.data)
tree.stack <- merge(tree.stack, tree.data, all.x=T, all.y=F)
summary(tree.stack)
dim(tree.stack)
write.csv(tree.stack, "TreeRWL_stacked.csv", row.names=F)
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# I think this next block can get deleted
# ----------------------------------------------------------------------------
# Subsetting only the sites & species I have full data for right now
#sites <- unique(establishment$Site)
#sites
#species <- unique(establishment$Spp)
#species
# looking at which cores for which we have measurements
# FOR CHRISTY: what about the cores where we don't have any data?  Will that be added later?
cores.meas <- as.vector(colnames(core.rw))
cores.meas[1:10] # checking names
length(cores.meas) # checking size
#this is looking at which trees we have measurements for (1,6) translates to AAA000 six characters
#This is commented out becasue we have a dated column in our core.data csv file
# Making a binary column of whether the tree was dated or not
#for(i in 1:length(diam.data$TreeID)){
#  diam.data$Dated[i] <- ifelse(diam.data$TreeID[i] %in% mmf.id2, "YES", "NO")
#}
#diam.data$Dated <- as.factor(diam.data$Dated) # making a factor (because sometimes goes weird)
#diam.data$Spp.Dated <- as.factor(paste(diam.data$spp, diam.data$Dated, sep=".")) # don't worry about this (something I"m playing with)
#summary(diam.data)
names(core.data)
summary(core.data)
core.deets <- data.frame(names(core.rw))
names(core.deets) <- "ID"
summary(core.deets)
names(core.data)
# Associating dbh with coreID
for(i in unique(core.deets$ID)){
core.deets[core.deets$ID==i, "DBH"] <- core.data[core.data$CoreID==i,"dbh"]
}
summary(core.deets)
#subsetting the DBH list to match what cores were actually dated
#core.names <- names(all.dated2)
#ID2 <- ID[ID$ID %in% core.names,]
#order both Core details object we just made, and the uploaded TR measurements
core.deets <- core.deets[order(core.deets$ID),]
head(core.deets)
#Flipping the dataset so that it has the most recent year at the top
core.rw <- core.rw[order(row.names(core.rw), decreasing=T),order(names(core.rw))]
head(core.rw)
ncol(core.rw)
#order both tree details object we just made, and the uploaded TR measurements
tree.deets <- tree.deets[order(tree.deets$ID),]
head(tree.deets)
#Flipping the dataset so that it has the most recent year at the top
tree.rw <- tree.rw[order(row.names(tree.rw), decreasing=T),order(names(tree.rw))]
head(tree.rw)
ncol(tree.rw)
# ----------------------------------------------------------------------------
#making dataframe of tree diameter
tree.deets <- data.frame(names(tree.rw))
names(tree.deets) <- "ID"
summary(tree.deets)
names(core.data)
# Getting tree level data
for(i in unique(tree.deets$ID)){
tree.deets[tree.deets$ID==i, "DBH"] <- tree.data[tree.data$TreeID==i,"dbh"]
}
summary(tree.deets)
#diameter reconstructions of each tree from the trees that dated??
dbh.recon <- tree.rw
summary(dbh.recon)
summary(tree.deets)
for(j in seq_along(dbh.recon)){
# inserting 2012 DBH
dbh.recon[1,j] <- tree.deets[tree.deets$ID==names(dbh.recon[j]),"DBH"]
for(i in 2:(length(dbh.recon[,j]))){
dbh.recon[i,j] <- ifelse(!is.na(tree.rw[i,j]), dbh.recon[i-1,j] - tree.rw[i-1,j]*2, tree.rw[i,j]*2) # subtracting the previous year's growth from DBH to get that year's DBH
}
}
summary(dbh.recon)
for(i in unique(tree.deets$ID)){
tree.deets[tree.deets$ID==i, "DBH"] <- tree.data[tree.data$TreeID==i,"dbh"]
}
summary(tree.deets)
summary(tree.rw)
dbh.recon <- tree.rw
summary(dbh.recon)
summary(tree.deets)
head(dbh.rwcon)
head(dbh.recon)
library(dplR)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
#################################################################################################
# Loading up .csv file that has meta data and RWL files for ring widths
# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother
#################################################################################################
#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH
#loading the dplR to use the basal area reconstruction functions.
core.data <- read.csv("Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)
#adding a column include which plot at the site the trees belong to
names(core.data)
core.data$plot <- substr(core.data$plot.id, 3, 3)
core.data$plot <- as.factor(core.data$plot)
summary(core.data)
tree.data <- read.csv("tree_metadata_DOE_plus_valles.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)
#adding a column include which plot at the site the trees belong to
names(tree.data)
tree.data$plot <- substr(tree.data$PlotID, 3, 3)
tree.data$plot <- as.factor(tree.data$plot)
summary(tree.data)
#load in core details data sheet.  Has living/dead, pith info, measurement info.
#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.
#Removing NA's from the files
# FUTURE NOTE: need to create a generalizeable file to house all RW measurements
core.rw <- read.rwl("valles_all_trees.rwl")
head(core.rw)
summary(core.rw)
#removing the extra character that tellervo adds
names(core.rw)<-substr(names(core.rw), 1, 7)
names(core.rw)
# NOTE: Unit Conversion Step
#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR)
summary(core.rw)
core.rw <- core.rw/10
summary(core.rw)
# ----------------------------------------------------------------------------
#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!
# Separating Dead vs. Missing rings
# What we need to know:
#1) Dead trees -- fill missing years with 0
#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0
#3) Live Trees, missing part of core -- model growth
# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years
for(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer
# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone
# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)
if(!is.na(core.data[core.data$CoreID==j, "zombie"]) | core.data[core.data$CoreID==j, "live.dead"]=="DEAD"){
last.meas <- as.numeric(core.data[core.data$CoreID==j, "outer.measured"]) # last ring which was mesured
last.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)
if(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled
inner.fill <- which(row.names(core.rw)== last.meas+1)
outer.fill <- which(row.names(core.rw)==last.yr)
core.rw[inner.fill:outer.fill,j] <- 0
}
}
}
summary(core.rw)
# ----------------------------------------------------------------------------
##########################################################################
#AGGREGATION STEP
#taking ring widths and aggregating from the core level to the tree level
##########################################################################
# ----------------------------------------------------------------------------
# aggregate to the tree level using only dated trees where possible
trees <- unique(substr(names(core.rw), 1, 6)) # listing trees we have measurements for
tree.rw <- data.frame(array(NA, dim=c(nrow(core.rw), length(trees)))) # a blank data frame to put everything in
row.names(tree.rw) <- row.names(core.rw)  # labeling the rows with the years from our rwl
names(tree.rw)<-unique(substr(names(core.rw), 1, 6)) # labeling the columns as trees
# summary(tree.rw) # this will get really big very quickly
dim(tree.rw) # 176 trees, 107 years of data
# The Aggregation Loop
for(i in unique(trees)){
cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with
cores <- names(core.rw)[cols] # getting the name of the cores we're working with
# -----------------------
# if there's only one core, we just take that regardless of wheter it's dated or not
if(length(cols) == 1){
tree.rw[,which(trees==i)] <- core.rw[,cols]
# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")
ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")
# Finding a (best-guess) pith date for the tree
tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores, "pith.yr"]
# -----------------------
} else {
# -----------------------
# if there's more than 1 core, we need to figure out which if any were dated
use <- vector(length=length(cols))
for(x in 1:length(cols)){
ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")
}
# -----------------------
# -----------------------
# now we know which were dated, so we can use that to figure out which cores to average
if(length(use[use=="TRUE"])==1) {
# if only 1 core is dated, use only that core and call the tree dated
tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]
tree.data[tree.data$TreeID==i, "Dated"] <- "Y"
tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]
# -----------------------
} else if(length(use[use=="TRUE"])>1) {
# -----------------------
# If there's greater than one dated core, take the mean of the dated cores and call the tree dated
tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)
tree.data[tree.data$TreeID==i, "Dated"] <- "Y"
tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)
} else {
# -----------------------
# If no cores are dated, take the mean of whatever we have and call the tree undated
tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T)
tree.data[tree.data$TreeID==i, "Dated"] <- "N"
tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)
# -----------------------
}
}
}
# Note: There are some warnings, but I think it's okay
# summary(tree.rw)
min(tree.rw, na.rm=T); max(tree.rw, na.rm=T)
dim(tree.rw)
# We've updated the tree.data file, so lets save our changes before we move any further
# We only added a new column and didn't change anything that was original, so it should be okay, but lets just double check before moving forward
tree.data$Dated <- as.factor(tree.data$Dated)
summary(tree.data)
# NOTE: right now you have a ridculously long name for your tree data spreadsheet, so I'm going to call it something different for my own sanity right now :-P
write.csv(tree.data, "TreeData.csv", row.names=F)
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# CRR: writing our tree RWL to a csv formatted for gap filling before we calculate BAI (bc some have missing outsides and that's bad if we're working outside-in in out calculations)
# stacking the RWL so that we have a single column of ring widths & an identifying column with TreeID
tree.stack <- stack(tree.rw)
names(tree.stack) <- c("RW", "TreeID")
tree.stack$Year <- as.numeric(row.names(tree.rw)) # adding in the years
summary(tree.stack)
# attaching all of our useful tree data
summary(tree.data)
tree.stack <- merge(tree.stack, tree.data, all.x=T, all.y=F)
summary(tree.stack)
dim(tree.stack)
write.csv(tree.stack, "TreeRWL_stacked.csv", row.names=F)
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# I think this next block can get deleted
# ----------------------------------------------------------------------------
# Subsetting only the sites & species I have full data for right now
#sites <- unique(establishment$Site)
#sites
#species <- unique(establishment$Spp)
#species
# looking at which cores for which we have measurements
# FOR CHRISTY: what about the cores where we don't have any data?  Will that be added later?
cores.meas <- as.vector(colnames(core.rw))
cores.meas[1:10] # checking names
length(cores.meas) # checking size
#this is looking at which trees we have measurements for (1,6) translates to AAA000 six characters
#This is commented out becasue we have a dated column in our core.data csv file
# Making a binary column of whether the tree was dated or not
#for(i in 1:length(diam.data$TreeID)){
#  diam.data$Dated[i] <- ifelse(diam.data$TreeID[i] %in% mmf.id2, "YES", "NO")
#}
#diam.data$Dated <- as.factor(diam.data$Dated) # making a factor (because sometimes goes weird)
#diam.data$Spp.Dated <- as.factor(paste(diam.data$spp, diam.data$Dated, sep=".")) # don't worry about this (something I"m playing with)
#summary(diam.data)
names(core.data)
summary(core.data)
core.deets <- data.frame(names(core.rw))
names(core.deets) <- "ID"
summary(core.deets)
names(core.data)
# Associating dbh with coreID
for(i in unique(core.deets$ID)){
core.deets[core.deets$ID==i, "DBH"] <- core.data[core.data$CoreID==i,"dbh"]
}
summary(core.deets)
#subsetting the DBH list to match what cores were actually dated
#core.names <- names(all.dated2)
#ID2 <- ID[ID$ID %in% core.names,]
#order both Core details object we just made, and the uploaded TR measurements
core.deets <- core.deets[order(core.deets$ID),]
head(core.deets)
#Flipping the dataset so that it has the most recent year at the top
core.rw <- core.rw[order(row.names(core.rw), decreasing=T),order(names(core.rw))]
head(core.rw)
ncol(core.rw)
tree.deets <- data.frame(names(tree.rw))
names(tree.deets) <- "ID"
summary(tree.deets)
names(core.data)
# Getting tree level data
for(i in unique(tree.deets$ID)){
tree.deets[tree.deets$ID==i, "DBH"] <- tree.data[tree.data$TreeID==i,"dbh"]
}
summary(tree.deets)
#diameter reconstructions of each tree from the trees that dated??
dbh.recon <- tree.rw
summary(dbh.recon)
summary(tree.deets)
for(j in seq_along(dbh.recon)){
# inserting 2012 DBH
dbh.recon[1,j] <- tree.deets[tree.deets$ID==names(dbh.recon[j]),"DBH"]
for(i in 2:(length(dbh.recon[,j]))){
dbh.recon[i,j] <- ifelse(!is.na(tree.rw[i,j]), dbh.recon[i-1,j] - tree.rw[i-1,j]*2, tree.rw[i,j]*2) # subtracting the previous year's growth from DBH to get that year's DBH
}
}
summary(dbh.recon)
#order both tree details object we just made, and the uploaded TR measurements
tree.deets <- tree.deets[order(tree.deets$ID),]
head(tree.deets)
#Flipping the dataset so that it has the most recent year at the top
tree.rw <- tree.rw[order(row.names(tree.rw), decreasing=T),order(names(tree.rw))]
head(tree.rw)
ncol(tree.rw)
# importing libraries
library(dplR)
library(lattice)
# Getting Libraries
library(reshape)
library(car)
library(mgcv)
library(nlme)
library(lmeSplines)
#library(lme4)
library(splines)
library(MASS)
library(MuMIn)
library(ggplot2)
library(grid)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))
plot(m1$gam)
head(ring.data)
ring.data <- read.csv("TreeRWL_Valles_stacked.csv")
ring.data$tree <- as.factor(ring.data$tree)
summary(ring.data)
tree.data <- read.csv("TreeData.csv")
summary(tree.data)
# We're going to run 2 sets of fillin models:
# 1) Model based on only DATED trees (m1d)
# 2) Model based on both DATED and UNDATED trees (m1u)
trees.dated <- ring.data[ring.data$Dated=="Y","TreeID"]
ring.data$RW0 <- ring.data$RW
for(i in unique(ring.data$TreeID)){
yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])
ring.data[ring.data$TreeID==i & is.na(ring.data$RW), "RW0"] <- ring.data[ring.data$TreeID==i & ring.data$Year==yr, "RW"]
}
summary(ring.data)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + spp + dbh, random=list(site=~1, PlotID=~1), data=ring.data, na.action=na.omit)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + spp + dbh, random=list(site=~1, PlotID=~1), data=ring.data, na.action=na.omit)
save(m1, file="GapFilling_gamm_valles_02.2015.rData")
par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)
plot(m1$gam)
ring.data$RW.modeled <- ifelse(ring.data$RW.modeled < 0, 0, ring.data$RW.modeled)
summary(ring.data)
par(new=F, mfrow=c(1,1), mar=c(5,5,0,0)+0.1)
for(i in unique(ring.data$TreeID)){
plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))
par(new=T)
}
for(i in unique(ring.data$TreeID)){
plot(RW.modeled ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.4, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T), ylab="")
par(new=T)
}
ring.data$RW.modeled <- predict(m1, ring.data)
