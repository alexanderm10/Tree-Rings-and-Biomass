}
plot(vub.density~names(vub.density), type="l", ylim=range(vub.density.ci))
lines(vub.density.ci[1,]~names(vub.density), lty="dashed")
lines(vub.density.ci[2,]~ names(vub.density), lty="dashed")
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# Workflow for modeling generalized tree growth for the Valles Caldera
# Note: This is developed so that we can use our tree rings to gap-fill the trees
#       in data from Marcy Litvak.  This means we have to remove at least PlotID &
#       either generalize species or drop that as well.
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# Loading in libraries and some other useful things
# --------------------------------------------------------------------------------
# clear memory
rm(list=ls())
# importing libraries
library(dplR)
library(lattice)
# Getting Libraries
library(reshape)
library(car)
library(mgcv)
library(nlme)
library(lmeSplines)
#library(lme4)
library(splines)
library(MASS)
library(MuMIn)
library(ggplot2)
library(grid)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))
# -----------------------------------------------
# --------------------------------------------------------------------------------
# Loading in & comparing our tree ring data & Marcy's
#    data so we know how to the structure the gamm
# --------------------------------------------------------------------------------
# -----------------------------------------------
# Tree Ring Data
# Format: stack all of the core measurements (BAI or RW) to create a single data frame with a single column of measurements and all predictors in other columns
# -----------------------------------------------
ring.data <- read.csv("TreeRWL_AllSites_stacked.csv")
ring.data$Tree <- as.factor(ring.data$Tree)
ring.data <- ring.data[,!names(ring.data)=="Density..stems.ha."]
summary(ring.data)
# Tree Data
tree.data <- read.csv("TreeData.csv")
tree.data <- tree.data[,!names(tree.data)=="Density..stems.ha."]
summary(tree.data)
# Site Data (for year cored)
site.data <- read.csv("raw input files/DOE_plus_valles.csv", na.strings="")
site.data$Year.sample <- as.numeric(substr(site.data$date.sample,7,10))
summary(site.data)
tree.data <- merge(tree.data, site.data[,c("PlotID", "Year.sample")], all.x=T, all.y=F)
tree.data$PlotID
tree.data$Age <- tree.data$Year.sample - tree.data$Pith
summary(tree.data)
ring.data <- ring.data[substr(ring.data$PlotID,1,1)=="V",]
summary(ring.data)
tree.data <- tree.data[substr(tree.data$PlotID,1,1)=="V",]
# merge in the modern stem density here
tree.data <- merge(tree.data, site.data[,c("PlotID", "Density.Total..stems.ha.")], all.x=T, all.y=F)
ring.data <- merge(ring.data, site.data[,c("PlotID", "Density.Total..stems.ha.")], all.x=T, all.y=F)
tree.data$Density.Total..stems.ha. <- as.numeric(paste(tree.data$Density.Total..stems.ha.))
ring.data$Density.Total..stems.ha. <- as.numeric(paste(ring.data$Density.Total..stems.ha.))
summary(tree.data)
summary(ring.data)
# Recoding the sites to match Marcy's
tree.data$Site <- recode(tree.data$Site, "'Valles Caldera Upper'='PPINE'; 'Valles Caldera Lower'='MCON'")
ring.data$Site <- recode(ring.data$Site, "'Valles Caldera Upper'='PPINE'; 'Valles Caldera Lower'='MCON'")
summary(ring.data)
summary(tree.data)
# Just for reference: find the trees that were dated
trees.dated <- ring.data[ring.data$Dated=="Y","TreeID"]
marcy.ppine <- read.csv("raw input files/marcy_ppine_2013.csv")
summary(marcy.ppine)
marcy.mcon <- read.csv("raw input files/marcy_mcon_2012.csv")
summary(marcy.mcon)
names(marcy.ppine)
names(marcy.mcon)
# Merging the two into 1 data frame and doing a bit of formatting
marcy <- rbind(marcy.ppine[,names(marcy.ppine) %in%  names(marcy.mcon)], marcy.mcon)
marcy$PlotID <- as.factor(paste(marcy$Site, marcy$Transect, sep="."))
names(marcy)[16] <- "DBH..cm."
marcy$Tree_Tag_Number <- as.factor(marcy$Tree_Tag_Number)
summary(marcy)
View(marcy)
marcy.density <- aggregate(marcy[,c("Plot_Radius")], by=list(marcy[,"PlotID"]), FUN=length)
names(marcy.density) <- c("PlotID", "n.stems")
marcy.density$Density.Total..stems.ha. <- marcy.density$n.stems/(pi*10^2)*10000 # stems/ha
summary(marcy.density)
# Merging the plot densities back into marcy's data
marcy <- merge(marcy, marcy.density)
summary(marcy)
unique(ring.data$Species) # PIPO, PIEN, PSME
unique(tree.data$Species) # PIPO, PIEN, PSME, POTR
unique(marcy$Species)     # PIPO, PIEN,     , POTR, ABCO
# Just for now I created 3 categories: PIPO, PIEN, and OTHER
ring.data$Species.Model <- recode(ring.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")
tree.data$Species.Model <- recode(tree.data$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")
marcy$Species.Model <- recode(marcy$Species, "'PIPO'='PIPO'; 'PIEN'='PIEN'; 'PSME'='OTHER'; 'POTR'='OTHER'; 'ABCO'='OTHER'")
# -----------------------------------------------
View(marcy)
# Mortality data gathered from van Mantgem 2009
# used interior numbers start year 1979 and end year 2011
# used to change densities for the valles
start.m <- rnorm(1000, mean=0.4843, sd= 0.2823)
rate.m <- rnorm(1000, mean= 0.024, sd= 0.027)
start.yr = 1979
end.yr = 2011
mort.rate <- data.frame(array(dim=c(1000, 33)))
names(mort.rate) <- start.yr:end.yr
for(j in 1:1000){
mort.rate[j,1] = sample(start.m, size=1, replace=T)
for(i in 2:length(mort.rate)){
mort.rate[j,i] <- mort.rate[j,i-1] + mort.rate[j,i-1]*sample(rate.m, size=1, replace=T)
}
}
summary(mort.rate)
ci <- apply(mort.rate, 2, FUN=quantile, c(0.025, 0.975))
mort.mean <- apply(mort.rate, 2, FUN=mean)
plot(mort.mean, type="l", ylim=range(ci))
lines(ci[1,], lty="dashed")
lines(ci[2,], lty="dashed")
#ci<- as.data.frame(ci)
mort.rate <- mort.mean[sort(names(mort.mean), decreasing=T)]
ci.mort.rate <- ci[,sort(colnames(ci), decreasing=T)]
vla.density <- vector(length=length(end.yr:start.yr))
vla.density[] <- 0.590278
names(vla.density) <- end.yr:start.yr
for(i in 2:length(vla.density)){
vla.density[i] <- vla.density[i-1] + vla.density[i-1]*mort.mean[i]/100
}
vla.density
vla.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vla.density.ci) <- row.names(ci)
row.names(vla.density.ci) <- names(ci.mort.rate)
vla.density.ci <-  ci
vla.density.ci[,] <- 0.590278
for(j in 1:nrow(vla.density.ci)){
for(i in 2:ncol(vla.density.ci)){
vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))
lines(vla.density.ci[1,]~names(vla.density), lty="dashed")
lines(vla.density.ci[2,]~names(vla.density), lty="dashed")
vlb.density <- vector(length=length(end.yr:start.yr))
vlb.density[] <- 0.089744
names(vlb.density) <- end.yr:start.yr
for(i in 2:length(vlb.density)){
vlb.density[i] <- vlb.density[i-1] + vlb.density[i-1]*mort.mean[i]/100
}
vlb.density
vlb.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vlb.density.ci) <- row.names(ci)
row.names(vlb.density.ci) <- names(ci.mort.rate)
vlb.density.ci <-  ci
vlb.density.ci[,] <- 0.089744
for(j in 1:nrow(vlb.density.ci)){
for(i in 2:ncol(vlb.density.ci)){
vlb.density.ci[j,i] <-vlb.density.ci[j,i-1] + vlb.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vlb.density~names(vlb.density), type="l", ylim=range(vlb.density.ci))
lines(vlb.density.ci[1,]~names(vlb.density), lty="dashed")
lines(vlb.density.ci[2,]~names(vlb.density), lty="dashed")
vua.density <- vector(length=length(end.yr:start.yr))
vua.density[] <- 0.111111
names(vua.density) <- end.yr:start.yr
for(i in 2:length(vua.density)){
vua.density[i] <- vua.density[i-1] + vua.density[i-1]*mort.mean[i]/100
}
vua.density
vua.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vua.density.ci) <- row.names(ci)
row.names(vua.density.ci) <- names(ci.mort.rate)
vua.density.ci <-  ci
vua.density.ci[,] <- 0.111111
for(j in 1:nrow(vua.density.ci)){
for(i in 2:ncol(vua.density.ci)){
vua.density.ci[j,i] <-vua.density.ci[j,i-1] + vua.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vua.density~names(vua.density), type="l", ylim=range(vua.density.ci))
lines(vua.density.ci[1,]~names(vua.density), lty="dashed")
lines(vua.density.ci[2,]~names(vua.density), lty="dashed")
vub.density <- vector(length=length(end.yr:start.yr))
vub.density[] <- 0.194444
names(vub.density) <- end.yr:start.yr
for(i in 2:length(vub.density)){
vub.density[i] <- vub.density[i-1] + vub.density[i-1]*mort.mean[i]/100
}
vub.density
vub.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vub.density.ci) <- row.names(ci)
row.names(vub.density.ci) <- names(ci.mort.rate)
vub.density.ci <-  ci
vub.density.ci[,] <- 0.194444
for(j in 1:nrow(vub.density.ci)){
for(i in 2:ncol(vub.density.ci)){
vub.density.ci[j,i] <-vub.density.ci[j,i-1] + vub.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vub.density~names(vub.density), type="l", ylim=range(vub.density.ci))
lines(vub.density.ci[1,]~names(vub.density), lty="dashed")
lines(vub.density.ci[2,]~ names(vub.density), lty="dashed")
mort.list <- list(vla.density, vlb.density, vua.density, vub.density)
mort.ci.list <- list(vla.density.ci, vlb.density.ci, vua.density.ci, vub.density.ci)
#####################################################
# applying changing densities to the biomass estimate
#####################################################
library(dplR)
library(ggplot2)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
g.filled.diam <- read.csv("gap_filled_dbh.recon.csv", header=T, row.names=1)
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
summary(g.filled.diam)
# read in tree data
tree.data <- read.csv("TreeData.csv", header=T)
summary(tree.data)
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]
summary(trees.use)
plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
summary(plot.data)
##########################################################################
# Allometric Equations
##########################################################################
#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations
library(car)
# Getting rid of POTR for now for conceptual figure purposes
trees.use <- trees.use[!(trees.use$Species=="POTR"),]
summary(trees.use)
unique(trees.use$Species)
trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'")
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
# will want to do general equations and pft level equations as well, but later
# log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics
#allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
allom.temp <- g.filled.diam
allom.temp[,] <- NA
# dbh=0 causes problems, so we're going to make those NA
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam)
dim(g.filled.diam)
#want to set up an array that has the layers 1) the time series of biomass 2) mean mortality numbers at the plot level 3) confidence intervals for the plots
bm.array <- array(NA, dim=c(nrow(g.filled.diam), length(unique(trees.use$PlotID)), ncol(allometries[[1]])))
row.names(bm.array) <- row.names(g.filled.diam)  #CRR Added
summary(bm.array[,,1])
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
# Note: we'll have to make this a bit fancier in the future for species with mu0==0
#   allom.temp[,cols] <- allom.eq(mu0= -3.5185,
#                          mu1 = 2.6909,
#                         #DBH = seq(from=30, to=1, length=nrow(g.filled.diam)))
#                          DBH = g.filled.diam[,cols])
# test <- allom.eq(mu0=ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"]),
#                               mu1 =ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"]),
#                               DBH = g.filled.diam[,cols])
# mu0 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"])
# mu1 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"])
mu0=allometries[[j]][i,mean("Bg0")]
mu1=allometries[[j]][i,mean("Bg1")]
allom.temp[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
# summing to the plot level
allom.temp[is.na(allom.temp)] <- 0
# biomass loop for summing trees to plots
# We're doing the unit conversions here; we had calculated density in stems/ha, but Christy wants to look at Biomass in kg/m2, so we're putting everything in kg/m2 here
for(p in 1:length(plots)){
cols <- which(names(allom.temp) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
if(substr(plots[p],1,1)=="V"){
bm.array[,p,i] <- rowMeans(allom.temp[,cols])*plot.data[plot.data$PlotID==paste(plots[p]), "Density.Total..stems.ha."]/10000 #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
} else {
temp <- allom.temp[,cols]
for(t in names(temp)){ # Convert biomass/tree to biomass/ha
temp[,t] <- temp[,t] * tree.data[tree.data$TreeID==t,"Density..stems.ha."]/10000
}
bm.array[,p,i] <- rowSums(temp) #sum biomass/ha
}
}
#--------------------------------------------------
# Mortality data gathered from van Mantgem 2009
# used interior numbers start year 1979 and end year 2011
# used to change densities for the valles
start.m <- rnorm(1000, mean=0.4843, sd= 0.2823)
rate.m <- rnorm(1000, mean= 0.024, sd= 0.027)
start.yr = 1979
end.yr = 2011
mort.rate <- data.frame(array(dim=c(1000, 33)))
names(mort.rate) <- start.yr:end.yr
for(j in 1:1000){
mort.rate[j,1] = sample(start.m, size=1, replace=T)
for(i in 2:length(mort.rate)){
mort.rate[j,i] <- mort.rate[j,i-1] + mort.rate[j,i-1]*sample(rate.m, size=1, replace=T)
}
}
summary(mort.rate)
ci <- apply(mort.rate, 2, FUN=quantile, c(0.025, 0.975))
mort.mean <- apply(mort.rate, 2, FUN=mean)
plot(mort.mean, type="l", ylim=range(ci))
lines(ci[1,], lty="dashed")
lines(ci[2,], lty="dashed")
#ci<- as.data.frame(ci)
mort.rate <- mort.mean[sort(names(mort.mean), decreasing=T)]
ci.mort.rate <- ci[,sort(colnames(ci), decreasing=T)]
vla.density <- vector(length=length(end.yr:start.yr))
vla.density[] <- 0.590278
names(vla.density) <- end.yr:start.yr
for(i in 2:length(vla.density)){
vla.density[i] <- vla.density[i-1] + vla.density[i-1]*mort.mean[i]/100
}
vla.density
vla.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vla.density.ci) <- row.names(ci)
row.names(vla.density.ci) <- names(ci.mort.rate)
vla.density.ci <-  ci
vla.density.ci[,] <- 0.590278
for(j in 1:nrow(vla.density.ci)){
for(i in 2:ncol(vla.density.ci)){
vla.density.ci[j,i] <-vla.density.ci[j,i-1] + vla.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vla.density~names(vla.density), type="l", ylim=range(vla.density.ci))
lines(vla.density.ci[1,]~names(vla.density), lty="dashed")
lines(vla.density.ci[2,]~names(vla.density), lty="dashed")
vlb.density <- vector(length=length(end.yr:start.yr))
vlb.density[] <- 0.089744
names(vlb.density) <- end.yr:start.yr
for(i in 2:length(vlb.density)){
vlb.density[i] <- vlb.density[i-1] + vlb.density[i-1]*mort.mean[i]/100
}
vlb.density
vlb.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vlb.density.ci) <- row.names(ci)
row.names(vlb.density.ci) <- names(ci.mort.rate)
vlb.density.ci <-  ci
vlb.density.ci[,] <- 0.089744
for(j in 1:nrow(vlb.density.ci)){
for(i in 2:ncol(vlb.density.ci)){
vlb.density.ci[j,i] <-vlb.density.ci[j,i-1] + vlb.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vlb.density~names(vlb.density), type="l", ylim=range(vlb.density.ci))
lines(vlb.density.ci[1,]~names(vlb.density), lty="dashed")
lines(vlb.density.ci[2,]~names(vlb.density), lty="dashed")
vua.density <- vector(length=length(end.yr:start.yr))
vua.density[] <- 0.111111
names(vua.density) <- end.yr:start.yr
for(i in 2:length(vua.density)){
vua.density[i] <- vua.density[i-1] + vua.density[i-1]*mort.mean[i]/100
}
vua.density
vua.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vua.density.ci) <- row.names(ci)
row.names(vua.density.ci) <- names(ci.mort.rate)
vua.density.ci <-  ci
vua.density.ci[,] <- 0.111111
for(j in 1:nrow(vua.density.ci)){
for(i in 2:ncol(vua.density.ci)){
vua.density.ci[j,i] <-vua.density.ci[j,i-1] + vua.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vua.density~names(vua.density), type="l", ylim=range(vua.density.ci))
lines(vua.density.ci[1,]~names(vua.density), lty="dashed")
lines(vua.density.ci[2,]~names(vua.density), lty="dashed")
vub.density <- vector(length=length(end.yr:start.yr))
vub.density[] <- 0.194444
names(vub.density) <- end.yr:start.yr
for(i in 2:length(vub.density)){
vub.density[i] <- vub.density[i-1] + vub.density[i-1]*mort.mean[i]/100
}
vub.density
vub.density.ci <-  data.frame(array(dim=c(nrow(ci), ncol(ci))))
rownames(vub.density.ci) <- row.names(ci)
row.names(vub.density.ci) <- names(ci.mort.rate)
vub.density.ci <-  ci
vub.density.ci[,] <- 0.194444
for(j in 1:nrow(vub.density.ci)){
for(i in 2:ncol(vub.density.ci)){
vub.density.ci[j,i] <-vub.density.ci[j,i-1] + vub.density.ci[j,i-1]*ci.mort.rate[j,i]/100
}
}
plot(vub.density~names(vub.density), type="l", ylim=range(vub.density.ci))
lines(vub.density.ci[1,]~names(vub.density), lty="dashed")
lines(vub.density.ci[2,]~ names(vub.density), lty="dashed")
mort.list <- list(vla.density, vlb.density, vua.density, vub.density)
mort.ci.list <- list(vla.density.ci, vlb.density.ci, vua.density.ci, vub.density.ci)
library(dplR)
library(ggplot2)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
g.filled.diam <- read.csv("gap_filled_dbh.recon.csv", header=T, row.names=1)
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
summary(g.filled.diam)
# read in tree data
tree.data <- read.csv("TreeData.csv", header=T)
summary(tree.data)
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]
summary(trees.use)
plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
summary(plot.data)
##########################################################################
# Allometric Equations
##########################################################################
#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations
library(car)
# Getting rid of POTR for now for conceptual figure purposes
trees.use <- trees.use[!(trees.use$Species=="POTR"),]
summary(trees.use)
unique(trees.use$Species)
trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'")
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
# will want to do general equations and pft level equations as well, but later
# log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics
#allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
allom.temp <- g.filled.diam
allom.temp[,] <- NA
# dbh=0 causes problems, so we're going to make those NA
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam)
dim(g.filled.diam)
bm.array <- array(NA, dim=c(nrow(g.filled.diam), length(unique(trees.use$PlotID)), ncol(allometries[[1]])))
# Conversion of diameter reconstruction to biomass
# Sampling the MCMC output generated by PEcAn to obtain ranges of possible biomass as opposed to a single line
# creating an object to serve as a home for all of the allometry samples we will pull from the individual species mcmc
allometries<- list()
# Sampling 500 random rows from the last 5000 runs of the MCMC
# need to not pull rows with a negative mu1
# loading in the MCMC data from PEcAn for PIPO
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PIPO.2.Rdata")
allometries[["pipo"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$pipo)
# loading in PSME pecan mcmc runs and making a PSME section within the allometries list. This will be repeate for all species present in the DOE study.
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PSME.2.Rdata")
allometries[["psme"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$psme)
# loading in ABCO pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.ABCO.2.Rdata")
allometries[["abco"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$abco)
# loading in general spruce pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PICEA.2.Rdata")
allometries[["picea.sp"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$picea.sp)
# loading in general pine pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PINUS.2.Rdata")
allometries[["pinus.sp"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$pinus.sp)
# loading in general fir pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.ABIES.2.Rdata")
allometries[["abies.sp"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$abies.sp)
#save the list as ______ to draw from later when we convert diameter reconstructions into biomass
save(allometries, file="allometries_list.Rdata")
# Conversion of diameter reconstruction to biomass
# Sampling the MCMC output generated by PEcAn to obtain ranges of possible biomass as opposed to a single line
# creating an object to serve as a home for all of the allometry samples we will pull from the individual species mcmc
allometries<- list()
# Sampling 500 random rows from the last 5000 runs of the MCMC
# need to not pull rows with a negative mu1
# loading in the MCMC data from PEcAn for PIPO
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PIPO.2.Rdata")
allometries[["pipo"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$pipo)
# loading in PSME pecan mcmc runs and making a PSME section within the allometries list. This will be repeate for all species present in the DOE study.
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PSME.2.Rdata")
allometries[["psme"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$psme)
# loading in ABCO pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.ABCO.2.Rdata")
allometries[["abco"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$abco)
# loading in general spruce pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PICEA.2.Rdata")
allometries[["picea.sp"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$picea.sp)
# loading in general pine pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.PINUS.2.Rdata")
allometries[["pinus.sp"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$pinus.sp)
# loading in general fir pecan mcmc runs
load("/Users/mrossalexander/Desktop/PEcAn_Allometries/Ross_allometries/Allom.ABIES.2.Rdata")
allometries[["abies.sp"]] <- mc[[3]][sample(which(mc[[3]][,"mu1"]>=0), size=500, replace=T),]
summary(allometries)
summary(allometries$abies.sp)
#save the list as ______ to draw from later when we convert diameter reconstructions into biomass
save(allometries, file="allometries_list.Rdata")
