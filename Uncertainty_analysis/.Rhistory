#--------------------------------------------------
for(i in 1:nrow(allometries[[1]])){
allom.temp <- g.filled.diam
allom.temp[,] <- NA
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
# Note: we'll have to make this a bit fancier in the future for species with mu0==0
#   allom.temp[,cols] <- allom.eq(mu0= -3.5185,
#                          mu1 = 2.6909,
#                         #DBH = seq(from=30, to=1, length=nrow(g.filled.diam)))
#                          DBH = g.filled.diam[,cols])
# test <- allom.eq(mu0=ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"]),
#                               mu1 =ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"]),
#                               DBH = g.filled.diam[,cols])
# mu0 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"])
# mu1 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"])
mu0=allometries[[j]][i,"Bg0"]
mu1=allometries[[j]][i,"Bg1"]
allom.temp[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
# summing to the plot level
allom.temp[is.na(allom.temp)] <- 0
# biomass loop for summing trees to plots
# We're doing the unit conversions here; we had calculated density in stems/ha, but Christy wants to look at Biomass in kg/m2, so we're putting everything in kg/m2 here
for(p in 1:length(sites)){
cols <- which(substr(names(allom.temp), 1, 3)==sites[p]) #%in% trees.use[trees.use$PlotID==sites[p], "TreeID"])
if(substr(sites[p],1,1)=="V"){
bm.array[,p,i] <- rowMeans(allom.temp[,cols])*ross.density.site[ross.density.site$PlotID==paste(sites[p]), "Density.Total..stems.m2."] #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
#bm.array[,p,i] <- rowMeans(allom.temp[,cols])*plot.data[plot.data$PlotID==paste(plots[p]), "density.m2"] #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
} else {
temp <- allom.temp[,cols]
for(n in names(temp)){ # Convert biomass/tree to biomass/ha
temp[,n] <- temp[,n] * tree.data[tree.data$TreeID==t,"Density..stems.ha."]/10000
}
bm.array[,p,i] <- rowSums(temp) #sum biomass/ha
}
}
}
#--------------------------------------------------
#bm.array[,,1]
summary(bm.array[,,1])
### OUTSIDE of all LOOPs (iteration + species + plots)
# You should now have a 3-dimensional array with plots as columns, years as rows, and iterations as layers
site.mean <- apply(bm.array[,,], c(1,2), mean) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
site.ci <- apply(bm.array[,,], c(1,2), quantile, c(0.025, 0.975)) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
# site.se <- apply(bm.array[,,], c(1,2), se)
site.mean <- as.data.frame(site.mean)
#names(site.mean)<- sites
site.lbound <- data.frame(site.ci[1,,])
names(site.lbound) <- paste(sites, "LB", sep=".")
site.ubound <- data.frame(site.ci[2,,])
names(site.ubound) <- paste(sites, "UB", sep=".")
# site.ci <-as.data.frame(site.ci)
# names(site.ci)<- c(paste(plots, "sd", sep="."))
# site.se <-as.data.frame(site.se)
# names(site.se)<- c(paste(plots, "se", sep="."))
site.valles <- as.data.frame(c(site.mean, site.lbound, site.ubound))
row.names(site.valles) <- row.names(site.mean)
summary(site.valles)
head(site.valles)
save(site.valles, file="valles_bm_recon_site.Rdata")
#save(biom.valles, file="biom.valles_cum.csv")
site.valles.stack <- stack(site.valles[1:2])
names(site.valles.stack) <- c("site.Mean", "SiteID")
site.valles.stack$Year <- as.numeric(paste(row.names(site.valles)))
#site.valles.stack$Plot <- as.factor(substr(site.valles.stack$PlotID, 3,3))
site.valles.stack$Site.name <- as.factor(substr(site.valles.stack$SiteID, 1,3))
summary(site.valles.stack)
site.valles.stack.lb <- stack(site.valles[3:4])
names(site.valles.stack.lb) <- c("site.LB", "SiteID")
site.valles.stack.ub <- stack(site.valles[5:6])
names(site.valles.stack.ub) <- c("site.UB", "SiteID")
site.valles.stack$site.LB <- site.valles.stack.lb[,1]
site.valles.stack$site.UB <- site.valles.stack.ub[,1]
summary(site.valles.stack)
summary(site.valles.stack)
save(site.valles.stack, file="valles_bm_recon_site_stack.Rdata")
load("valles_bm_recon_stack.Rdata")
library(ggplot2)
ggplot(data=site.valles.stack[site.valles.stack$Year<2012 ,])  + facet_grid(SiteID~.) +
# plotting total site basal area
geom_ribbon(aes(x=Year, ymin=site.LB, ymax=site.UB, fill=SiteID), alpha=0.5) +
geom_line(aes(x=Year, y=site.Mean, color=SiteID)) +
ggtitle("Valles Caldera mean Densities")
###################################################################################################################
# We need to look at the spread in the density fluctuations, and not the allometric equations as previously shown
####################################################################################################################
################################################################################
# All Trees BM estimates
################################################################################
# load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.
g.filled.diam <- read.csv("GapFilling_DBHrecon_ALL.csv", header=T, row.names=1)
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
summary(g.filled.diam)
dim(g.filled.diam)
# read in tree data
tree.data <- read.csv("TreeData.csv", header=T)
summary(tree.data)
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]
summary(trees.use)
#quick plot
#spag.plot(g.filled.diam)
plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
summary(plot.data)
# ross.density <- read.csv("raw input files/ross_density.csv", header=T)
#
# ross.density.site <- ross.density[substr(ross.density$PlotID, 1, 1)=="V",]
#
# # sites <- unique(site.density$PlotID)
# sites <- unique(ross.density.site$PlotID)
##########################################################################
# Allometric Equations
##########################################################################
#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations
library(car)
# Getting rid of POTR for now for conceptual figure purposes
#trees.use <- trees.use[!(trees.use$Species=="POTR"),]
summary(trees.use)
unique(trees.use$Species)
trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'; 'POTR'='potr'")
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
load("allometries_list.Rdata")
# will want to do general equations and pft level equations as well, but later
# log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics
#allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
# dbh <- 1:50
# test <- allom.eq(mu0= -3.5185,
#                  mu1 = 2.6909,
#                  DBH = dbh)
#
# plot(test*.09 ~ dbh)
allom.temp <- g.filled.diam
allom.temp[,] <- NA
# dbh=0 causes problems, so we're going to make those NA
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam)
dim(g.filled.diam)
bm.all.array <- g.filled.diam
bm.all.array[,] <- NA
row.names(bm.all.array) <- row.names(g.filled.diam)  #CRR Added
summary(bm.all.array)
dim(bm.all.array)
#--------------------------------------------------
#
#
#--------------------------------------------------
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
mu0=mean(allometries[[j]][,"Bg0"])
mu1=mean(allometries[[j]][,"Bg1"])
bm.all.array[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
summary(bm.all.array)
dim(bm.all.array)
all.bm <- bm.all.array
for(p in 1:length(plots)){
cols <- which(names(bm.all.array) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
all.bm[,cols] <- bm.all.array[,cols]*plot.data[plot.data$PlotID==paste(plots[p]), "Density.Total..stems.ha."]/10000 #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
}
dim(all.bm)
summary(all.bm)
all.vlf <- all.bm[,substr(names(all.bm), 1, 3)=="VLF"]
dim(all.vlf)
all.vuf <- all.bm[,substr(names(all.bm), 1, 3)=="VUF"]
dim(all.vuf)
vlf.sample.mean <-apply(all.vlf[,], 1, mean, na.rm=T)
vlf.sample.ci <- apply(all.vlf[,], 1, quantile, c(0.025, 0.975), na.rm=T)
summary(vlf.sample.ci)
vuf.sample.mean <-apply(all.vuf, 1, mean, na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
vuf.sample.ci<- apply(all.vuf, 1, quantile, c(0.025, 0.975), na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
vlf.sample.mean <- as.data.frame(vlf.sample.mean)
names(vlf.sample.mean)<- "VLF"
vlf.sample.lbound <- data.frame(vlf.sample.ci[1,])
names(vlf.sample.lbound) <- paste("VLF", "LB", sep=".")
vlf.sample.ubound <- data.frame(vlf.sample.ci[2,])
names(vlf.sample.ubound) <- paste("VLF", "UB", sep=".")
vuf.sample.mean <- as.data.frame(vuf.sample.mean)
names(vuf.sample.mean)<- "VUF"
vuf.sample.lbound <- data.frame(vuf.sample.ci[1,])
names(vuf.sample.lbound) <- paste("VUF", "LB", sep=".")
vuf.sample.ubound <- data.frame(vuf.sample.ci[2,])
names(vuf.sample.ubound) <- paste("VUF", "UB", sep=".")
all.valles.sample <- as.data.frame(c(vuf.sample.mean, vuf.sample.lbound, vuf.sample.ubound, vlf.sample.mean, vlf.sample.lbound, vlf.sample.ubound))
row.names(all.valles.sample) <- row.names(all.bm)
summary(all.valles.sample)
head(all.valles.sample)
all.valles.sample.stack <- stack(all.valles.sample[c(1,4)])
names(all.valles.sample.stack) <- c("all.Mean.sample", "SiteID")
all.valles.sample.stack$Year <- as.numeric(paste(row.names(all.valles.sample)))
summary(all.valles.sample.stack)
all.valles.sample.stack.lb <- stack(all.valles.sample[c(2,5)])
names(all.valles.sample.stack.lb) <- c("all.sample.LB", "SiteID")
head(all.valles.sample.stack.lb)
all.valles.sample.stack.ub <- stack(all.valles.sample[c(3,6)])
names(all.valles.sample.stack.ub) <- c("all.sample.UB", "SiteID")
all.valles.sample.stack$all.sample.LB <- all.valles.sample.stack.lb[,1]
all.valles.sample.stack$all.sample.UB <- all.valles.sample.stack.ub[,1]
summary(all.valles.sample.stack)
summary(all.valles.sample.stack)
save(all.valles.sample.stack, file="allTrees_valles_sample_stack.Rdata")
ggplot(data=all.valles.sample.stack[all.valles.sample.stack$Year<2012,])  + facet_grid(SiteID ~.) +
# plotting total site basal area
geom_ribbon(aes(x=Year, ymin=all.sample.LB, ymax=all.sample.UB, fill=SiteID), alpha=0.5) +
geom_line(aes(x=Year, y=all.Mean.sample, color=SiteID))+
labs(title= "All Trees BM sample", x="Year", y="Bm sample. (kg/m2)")
ggplot(data=valles.inc.stack[valles.inc.stack$Year<2012,])  + facet_grid(SiteID ~.) +
# plotting total site basal area
geom_ribbon(aes(x=Year, ymin=inc.LB, ymax=inc.UB, fill=group), alpha=0.5) +
geom_line(aes(x=Year, y=Mean.inc, color=group))+
labs(title= "Comparison BM inc", x="Year", y="Bm inc. (kg/m2)")
library(car)
library(dplR)
library(ggplot2)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
################################################################################
# assessing the differences between dated and undated series
################################################################################
load("site_density.Rdata") #loakds in the mean of Marcy and Ross densities
summary(site.density)
# load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.
g.filled.diam <- read.csv("GapFilling_DBHrecon_ALL.csv", header=T, row.names=1)
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
summary(g.filled.diam)
# read in tree data
tree.data <- read.csv("TreeData.csv", header=T)
summary(tree.data)
#trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" | substr(tree.data$PlotID, 1, 2)=="MM",]
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" & tree.data$Dated=="Y",]
trees.use <- trees.use[!is.na(trees.use$TreeID),]
head(trees.use)
dim(trees.use)
summary(trees.use[substr(trees.use$PlotID, 1, 2)=="VU",])
summary(trees.use[substr(trees.use$PlotID, 1, 2)=="VL",])
#making g.filled.diam the same length as tree.data
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V" & names(g.filled.diam) %in% trees.use$TreeID]
dim(g.filled.diam)
summary(trees.use)
#quick plot
#spag.plot(g.filled.diam)
# load("site_density.Rdata")
# summary(site.density)
ross.density <- read.csv("raw input files/ross_density.csv", header=T)
ross.density.site <- ross.density[substr(ross.density$PlotID, 1, 1)=="V",]
# sites <- unique(site.density$PlotID)
sites <- unique(ross.density.site$PlotID)
plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
summary(plot.data)
##########################################################################
# Allometric Equations
##########################################################################
#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations
library(car)
load("allometries_list.Rdata")
# Getting rid of POTR for now for conceptual figure purposes
#trees.use <- trees.use[!(trees.use$Species=="POTR"),]
summary(trees.use)
unique(trees.use$Species)
trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'; 'POTR' = 'potr'")
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
# will want to do general equations and pft level equations as well, but later
# log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics
#allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
allom.temp <- g.filled.diam
allom.temp[,] <- NA
# dbh=0 causes problems, so we're going to make those NA
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam)
dim(g.filled.diam)
bm.dated.array <- g.filled.diam
bm.dated.array[,] <- NA
row.names(bm.dated.array) <- row.names(g.filled.diam)  #CRR Added
summary(bm.dated.array)
dim(bm.dated.array)
#--------------------------------------------------
#
#
#--------------------------------------------------
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
mu0=mean(allometries[[j]][,"Bg0"])
mu1=mean(allometries[[j]][,"Bg1"])
bm.dated.array[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
summary(bm.dated.array)
dim(bm.dated.array)
dated.bm<-bm.dated.array
for(p in 1:length(sites)){
cols <- which(substr(names(bm.dated.array), 1, 3)==sites[p]) #%in% trees.use[trees.use$PlotID==sites[p], "TreeID"])
dated.bm[,cols] <- bm.dated.array[,cols]*ross.density.site[ross.density.site$PlotID==paste(sites[p]), "Density.Total..stems.m2."] #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
}
dim(dated.bm)
#dated.bm <- bm.dated.array[,] * ifelse(names(bm.dated.array) %in% trees.use[substr(trees.use$TreeID, 1, 3)== "VLF", "TreeID"], site.density$density.m2[site.density$PlotID=="VLF"], site.density$density.m2[site.density$PlotID=="VUF"])
min(dated.bm, na.rm=T)
summary(dated.bm)
dated.increment <- dated.bm
dated.increment[1:3,] <- NA
summary(dated.increment)
dim(dated.increment)
for(j in 1:ncol(dated.increment)){
# inserting oldest biomass
dated.increment[nrow(dated.increment),j] <- dated.bm[nrow(dated.increment),j]
for(i in (nrow(dated.increment)-1):1){
dated.increment[i,j] <- ifelse(!is.na(dated.bm[i,j]) & !is.na(dated.bm[i+1,j]), dated.bm[i,j] - dated.bm[i+1,j],NA) # subtracting the previous year's growth from DBH to get that year's DBH
}
}
dated.increment[1:3,] <- NA
min(dated.increment, na.rm=T)
head(dated.increment)
dim(dated.increment)
dated.vlf <- dated.increment[,names(dated.increment) %in% trees.use[substr(trees.use$TreeID,1,3)== "VLF", "TreeID"]]
dated.vuf <- dated.increment[,names(dated.increment) %in% trees.use[substr(trees.use$TreeID,1,3)== "VUF", "TreeID"]]
dated.vlf.inc <-apply(dated.vlf, 1, mean, na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
dated.vlf.inc.ci <- apply(dated.vlf, 1, quantile, c(0.025, 0.975), na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
dated.vuf.inc <-apply(dated.vuf, 1, mean, na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
dated.vuf.inc.ci <- apply(dated.vuf, 1, quantile, c(0.025, 0.975), na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
dated.vlf.inc <- as.data.frame(dated.vlf.inc)
dated.vlf.lbound <- data.frame(dated.vlf.inc.ci[1,])
names(dated.vlf.inc)<- "VLF"
names(dated.vlf.lbound) <- paste("VLF", "LB", sep=".")
dated.vlf.ubound <- data.frame(dated.vlf.inc.ci[2,])
names(dated.vlf.ubound) <- paste("VLF", "UB", sep=".")
head(dated.vlf.ubound)
dated.vuf.inc <- as.data.frame(dated.vuf.inc)
names(dated.vuf.inc)<- "VUF"
dated.vuf.lbound <- data.frame(dated.vuf.inc.ci[1,])
names(dated.vuf.lbound) <- paste("VUF", "LB", sep=".")
dated.vuf.ubound <- data.frame(dated.vuf.inc.ci[2,])
names(dated.vuf.ubound) <- paste("VUF", "UB", sep=".")
head(dated.vuf.ubound)
dated.valles.inc <- as.data.frame(c(dated.vuf.inc, dated.vuf.lbound, dated.vuf.ubound, dated.vlf.inc, dated.vlf.lbound, dated.vlf.ubound))
row.names(dated.valles.inc) <- row.names(dated.increment)
summary(dated.valles.inc)
head(dated.valles.inc)
dated.valles.inc.stack <- stack(dated.valles.inc[c(1,4)])
names(dated.valles.inc.stack) <- c("dated.Mean.inc", "SiteID")
dated.valles.inc.stack$Year <- as.numeric(paste(row.names(dated.valles.inc)))
summary(dated.valles.inc.stack)
dated.valles.inc.stack.lb <- stack(dated.valles.inc[c(2,5)])
names(dated.valles.inc.stack.lb) <- c("dated.inc.LB", "SiteID")
head(dated.valles.inc.stack.lb)
dated.valles.inc.stack.ub <- stack(dated.valles.inc[c(3,6)])
names(dated.valles.inc.stack.ub) <- c("dated.inc.UB", "SiteID")
dated.valles.inc.stack$dated.inc.LB <- dated.valles.inc.stack.lb[,1]
dated.valles.inc.stack$dated.inc.UB <- dated.valles.inc.stack.ub[,1]
summary(dated.valles.inc.stack)
summary(dated.valles.inc.stack)
save(dated.valles.inc.stack, file="dated_valles_inc_stack.Rdata")
ggplot(data=dated.valles.inc.stack[dated.valles.inc.stack$Year<2012,])  + facet_grid(SiteID ~.) +
# plotting total site basal area
geom_ribbon(aes(x=Year, ymin=dated.inc.LB, ymax=dated.inc.UB), alpha=0.5) +
geom_line(aes(x=Year, y=dated.Mean.inc))+
labs(title= "dated BM inc", x="Year", y="Bm inc. (kg/m2)")
################################################################################
# All Trees BM estimates
################################################################################
# load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.
g.filled.diam <- read.csv("GapFilling_DBHrecon_ALL.csv", header=T, row.names=1)
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
summary(g.filled.diam)
dim(g.filled.diam)
# read in tree data
tree.data <- read.csv("TreeData.csv", header=T)
summary(tree.data)
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]
summary(trees.use)
#quick plot
#spag.plot(g.filled.diam)
plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
summary(plot.data)
ross.density <- read.csv("raw input files/ross_density.csv", header=T)
ross.density.site <- ross.density[substr(ross.density$PlotID, 1, 1)=="V",]
# sites <- unique(site.density$PlotID)
sites <- unique(ross.density.site$PlotID)
##########################################################################
# Allometric Equations
##########################################################################
#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations
library(car)
# Getting rid of POTR for now for conceptual figure purposes
#trees.use <- trees.use[!(trees.use$Species=="POTR"),]
summary(trees.use)
unique(trees.use$Species)
trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'; 'POTR'='potr'")
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
load("allometries_list.Rdata")
# will want to do general equations and pft level equations as well, but later
# log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics
#allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
# dbh <- 1:50
# test <- allom.eq(mu0= -3.5185,
#                  mu1 = 2.6909,
#                  DBH = dbh)
#
# plot(test*.09 ~ dbh)
allom.temp <- g.filled.diam
allom.temp[,] <- NA
# dbh=0 causes problems, so we're going to make those NA
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam)
dim(g.filled.diam)
bm.all.array <- g.filled.diam
bm.all.array[,] <- NA
row.names(bm.all.array) <- row.names(g.filled.diam)  #CRR Added
summary(bm.all.array)
dim(bm.all.array)
#--------------------------------------------------
#
#
#--------------------------------------------------
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
mu0=mean(allometries[[j]][,"Bg0"])
mu1=mean(allometries[[j]][,"Bg1"])
bm.all.array[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
summary(bm.all.array)
dim(bm.all.array)
all.bm <- bm.all.array
for(p in 1:length(sites)){
cols <- which(substr(names(bm.all.array), 1, 3)==sites[p]) #%in% trees.use[trees.use$PlotID==sites[p], "TreeID"])
all.bm[,cols] <- bm.all.array[,cols]*ross.density.site[ross.density.site$PlotID==paste(sites[p]), "Density.Total..stems.m2."] #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
}
dim(all.bm)
#all.bm <- bm.all.array[,] * ifelse(names(bm.all.array) %in% trees.use[substr(trees.use$TreeID, 1,3)== "VLF", "TreeID"], site.density$density.m2[site.density$PlotID=="VLF"], site.density$density.m2[site.density$PlotID=="VUF"])
summary(all.bm)
all.increment <- all.bm
all.increment[,] <- NA
# subtracting time t from t+1 to get the BM increment
dim(all.increment)
for(j in 1:ncol(all.increment)){
# inserting oldest biomass
all.increment[nrow(all.increment),j] <- all.bm[nrow(all.increment),j]
for(i in (nrow(all.increment)-1):1){
all.increment[i,j] <- ifelse(!is.na(all.bm[i,j]) & !is.na(all.bm[i+1,j]), all.bm[i,j] - all.bm[i+1,j],NA) # subtracting the previous year's growth from DBH to get that year's DBH
}
}
all.increment[1:3,] <- NA
min(all.increment, na.rm=T)
head(all.increment)
all.vlf <- all.increment[,names(all.increment) %in% trees.use[substr(trees.use$TreeID, 1, 3 )== "VLF", "TreeID"]]
all.vuf <- all.increment[,names(all.increment) %in% trees.use[substr(trees.use$TreeID, 1, 3 )== "VUF", "TreeID"]]
all.vlf.inc <-apply(all.vlf, 1, mean, na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
all.vlf.inc.ci <- apply(all.vlf, 1, quantile, c(0.025, 0.975), na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
all.vuf.inc <-apply(all.vuf, 1, mean, na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
all.vuf.inc.ci <- apply(all.vuf, 1, quantile, c(0.025, 0.975), na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
all.vlf.inc <- as.data.frame(all.vlf.inc)
all.vlf.lbound <- data.frame(all.vlf.inc.ci[1,])
names(all.vlf.inc)<- "VLF"
names(all.vlf.lbound) <- paste("VLF", "LB", sep=".")
all.vlf.ubound <- data.frame(all.vlf.inc.ci[2,])
names(all.vlf.ubound) <- paste("VLF", "UB", sep=".")
all.vuf.inc <- as.data.frame(all.vuf.inc)
names(all.vuf.inc)<- "VUF"
all.vuf.lbound <- data.frame(all.vuf.inc.ci[1,])
names(all.vuf.lbound) <- paste("VUF", "LB", sep=".")
all.vuf.ubound <- data.frame(all.vuf.inc.ci[2,])
names(all.vuf.ubound) <- paste("VUF", "UB", sep=".")
all.valles.inc <- as.data.frame(c(all.vuf.inc, all.vuf.lbound, all.vuf.ubound, all.vlf.inc, all.vlf.lbound, all.vlf.ubound))
row.names(all.valles.inc) <- row.names(all.increment)
summary(all.valles.inc)
head(all.valles.inc)
all.valles.inc.stack <- stack(all.valles.inc[c(1,4)])
names(all.valles.inc.stack) <- c("all.Mean.inc", "SiteID")
all.valles.inc.stack$Year <- as.numeric(paste(row.names(all.valles.inc)))
summary(all.valles.inc.stack)
all.valles.inc.stack.lb <- stack(all.valles.inc[c(2,5)])
names(all.valles.inc.stack.lb) <- c("all.inc.LB", "SiteID")
head(all.valles.inc.stack.lb)
all.valles.inc.stack.ub <- stack(all.valles.inc[c(3,6)])
names(all.valles.inc.stack.ub) <- c("all.inc.UB", "SiteID")
all.valles.inc.stack$all.inc.LB <- all.valles.inc.stack.lb[,1]
all.valles.inc.stack$all.inc.UB <- all.valles.inc.stack.ub[,1]
summary(all.valles.inc.stack)
summary(all.valles.inc.stack)
save(all.valles.inc.stack, file="allTrees_valles_inc_stack.Rdata")
ggplot(data=all.valles.inc.stack[all.valles.inc.stack$Year<2012,])  + facet_grid(SiteID ~.) +
# plotting total site basal area
geom_ribbon(aes(x=Year, ymin=all.inc.LB, ymax=all.inc.UB), alpha=0.5) +
geom_line(aes(x=Year, y=all.Mean.inc))+
labs(title= "All Trees BM inc", x="Year", y="Bm inc. (kg/m2)")
##########################################################################
# combining Dated and All to look at the difference between the BM inc
##########################################################################
all.valles.inc.stack$group <- as.factor("all")
names(all.valles.inc.stack)<- c("Mean.inc", "SiteID", "Year","inc.LB", "inc.UB", "group")
dated.valles.inc.stack$group <- as.factor("dated")
names(dated.valles.inc.stack)<- c("Mean.inc", "SiteID", "Year","inc.LB", "inc.UB", "group")
valles.inc.stack <- rbind(all.valles.inc.stack, dated.valles.inc.stack)
summary(valles.inc.stack)
ggplot(data=valles.inc.stack[valles.inc.stack$Year<2012,])  + facet_grid(SiteID ~.) +
# plotting total site basal area
geom_ribbon(aes(x=Year, ymin=inc.LB, ymax=inc.UB, fill=group), alpha=0.5) +
geom_line(aes(x=Year, y=Mean.inc, color=group))+
labs(title= "Comparison BM inc", x="Year", y="Bm inc. (kg/m2)")
save(valles.inc.stack, file="dated_v_all_valles.inc.stack.Rdata")
