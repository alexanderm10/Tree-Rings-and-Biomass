#------------------------------
ring.data <- ring.data[!(ring.data$TreeID==i & ring.data$Year<yr.fill),]
#------------------------------
}
summary(ring.data)
dim(ring.data)
ring.data <- read.csv("TreeRWL_AllSites_stacked.csv")
ring.data$Tree <- as.factor(ring.data$Tree)
summary(ring.data)
# Tree Data
tree.data <- read.csv("TreeData.csv")
summary(tree.data)
# Site Data (for year cored)
Site.data <- read.csv("raw input files/DOE_plus_valles.csv", na.strings="")
Site.data$Year.sample <- as.numeric(substr(Site.data$date.sample,7,10))
summary(Site.data)
# merging in the year sampled into the tree data & calculating age
tree.data <- merge(tree.data, Site.data[,c("PlotID", "Year.sample")], all.x=T, all.y=F)
tree.data$PlotID
tree.data$Age <- tree.data$Year.sample - tree.data$Pith
summary(tree.data)
# We're going to run 2 sets of fillin models:
# 1) Model based on only DATED trees (m1d)
# 2) Model based on both DATED and UNDATED trees (m1u)
trees.dated <- ring.data[ring.data$Dated=="Y","TreeID"]
# using the gamm allows us to fit a smoothing spline to each tree, which allows us to basically gapfill taking into account unique tree temporal trends
#	current spline parameter: shrinkage version of cubic spline with 3 knots (stiff CR spline)
#	when we fit a generalized version for missing trees, we'll have to decide what to fit it to instead of TreeID; I think probably species|plot
# m1 <- gamm(RW ~ s(Year, bs="cs", k=3) + species + DBH..cm., random=list(Site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
# ----------------------------------------------------------------
# IDEAL MODEL FORM (it won't work for many reasons)
#	-- won't predict outside range of years observed on each core
#	-- end up with singularity issues
#	-- would take FOREVER to fit even if it did work
# m1d <- gamm(RW ~ s(Year, bs="cs", k=3, by=TreeID) + species*DBH..cm.*canopy.class, random=list(Site=~1, PlotID=~1, TreeID=~1), data=trees.dated.full, na.action=na.omit)
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# The spline doesn't fit outside the range of observed values, so we need to give it a "null" guess
# As a very very rough guess right now, filling missing with the measurement from the oldest ring
# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)
# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?
# ---------------------------------------
# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)
# ---------------------------------------
# What we need: core summary data (DBH..cm., estimated pith date)
# Ignoring all the Sites we don't have and doing some exploratory graphing
tree.data2 <- tree.data[tree.data$PlotID %in% unique(ring.data$PlotID),]
summary(tree.data2)
# Need to remove species for which we have no pith estimates for the time being
Species.pith <- unique(tree.data2[!is.na(tree.data2$Pith), "Species"])
tree.data3 <- tree.data2[tree.data2$Species %in%  Species.pith,]
summary(tree.data3)
qplot(DBH..cm., Age, color=Species, data=tree.data3) + facet_wrap(~Species) +
stat_smooth(method="lm", alpha=0.5, size=1.5) +
theme_bw()
# Making a very basic linear model looking at Site-specific species-DBH..cm.-age relationships
dbh.age <- lm(Age ~ Species*DBH..cm.*Site-1, data=tree.data3)
summary(dbh.age)
summary(dbh.age)$r.squared # Note, this very basic model works pretty well!
# Using the prediction interval to get us a higher upper bound
age.pi <- predict(dbh.age, newdata=tree.data3, interval="predict")
summary(age.pi)
dim(age.pi); dim(tree.data3) # Making sure we didn't lose any rows along the way
tree.data3 <- cbind(tree.data3, age.pi)
summary(tree.data3)
# Setting the filling window to the upper p.i. limit
tree.data3$fill.year <- ifelse(is.na(tree.data3$Pith), tree.data3$Year.sample-tree.data3$upr, tree.data3$Pith)
summary(tree.data3)
# Merging this back into a data frame that contains info for all the trees we're modeling right now
tree.data.model <- merge(tree.data3, tree.data2, all.x=T, all.y=T)
summary(tree.data.model)
#---------------------
# QUESTION: what to do about the species with no pith estimates?
#	For now, I'm just going to do a species-naive fit within each plot
#---------------------
dbh.age.plot <- lm(Age ~ DBH..cm.*PlotID-1, data=tree.data.model)
summary(dbh.age.plot)
age.pi.plot <- predict(dbh.age.plot, newdata= tree.data.model, interval="predict")
summary(age.pi.plot)
dim(age.pi.plot); dim(tree.data.model)
summary(tree.data.model)
# Filling missing fill.year with one caluclated form age.pi.plot fill
tree.data.model[is.na(tree.data.model$fill.year),"fill.year"] <- tree.data.model[is.na(tree.data.model$fill.year),"Year.sample"] - age.pi.plot[which(is.na(tree.data.model$fill.year)),3]
summary(tree.data.model)
#---------------------
# ---------------------------------------
# ---------------------------------------
# ORIGINAL USAGE: Provide dummy variable
# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?
#		QUESTION: What dummy value do we want to give it?
#			For now, I'm going to do the mean of the last decade
# ---------------------------------------
# summary(ring.data)
# ring.data$RW0 <- ring.data$RW # Making a column of dummy-filled ring widths
# for(i in unique(ring.data$TreeID)){
# #------------------------------
# #year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)
# #year.min = the oldest year measured
# #rw.fill = the dummy ring width to feed the model; right now this is for the last measured decade
# #			-- (yr.min + 10) means the 10 years following year.min (
# #			-- e.g. if min year = 1950, we'll fill with the mean value from 1950:1960
# #------------------------------
# yr.fill <- tree.data.model[tree.data.model$TreeID==i,"fill.year"]
# yr.min <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])
# rw.fill <- mean(ring.data[ring.data$TreeID==i & ring.data$Year>=yr.min & ring.data$Year<=(yr.min+10), "RW"],na.rm=T)
# #------------------------------
# #------------------------------
# # The actual insertion of the dummy fil value into the fill range
# #------------------------------
# ring.data[ring.data$TreeID==i & is.na(ring.data$RW) & ring.data$Year>=yr.fill, "RW0"] <- rw.fill
# #------------------------------
# }
# summary(ring.data)
# # ---------------------------------------
# ---------------------------------------
# New Usage: delete NAs for years way outside what we think we should be fitting
# 2b) I still don't think we want to be fi
# ---------------------------------------
summary(tree.data.model)
summary(ring.data)
dim(ring.data)
for(i in unique(ring.data$TreeID)){
#------------------------------
#year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)
#------------------------------
yr.fill <- tree.data.model[tree.data.model$TreeID==i,"fill.year"]
#------------------------------
#------------------------------
# The actual insertion of the dummy fil value into the fill range
#------------------------------
ring.data <- ring.data[!(ring.data$TreeID==i & ring.data$Year<yr.fill),]
#------------------------------
}
summary(ring.data)
dim(ring.data)
summary(tree.data$Species)
library(dplR)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
#################################################################################################
# Loading up .csv file that has meta data and RWL files for ring widths
# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother
#################################################################################################
#load in core details data sheet.  Has living/dead, pith info, measurement info.
#loading the dplR to use the basal area reconstruction functions.
core.data <- read.csv("raw input files/Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)
#adding a column include which plot at the site the trees belong to
names(core.data)
core.data$plot <- substr(core.data$plot.id, 3, 3)
core.data$plot <- as.factor(core.data$plot)
summary(core.data)
#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH
tree.data <- read.csv("raw input files/tree_metadata_DOE_plus_valles.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)
#adding a column include which plot at the site the trees belong to
names(tree.data)
tree.data$plot <- substr(tree.data$PlotID, 3, 3)
tree.data$plot <- as.factor(tree.data$plot)
summary(tree.data)
#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.
#Removing NA's from the files
# NOTE: reading in a single rwl with all measured trees otherwise you're going to need to make sure to change the file paths for EVERYTHING otherwise you overwrite important files and make a lot more work for yourself
core.rw <- read.rwl("RWL/RWL_all_trees.rwl")
summary(core.rw)
#removing the extra character that tellervo adds
names(core.rw)<-substr(names(core.rw), 1, 7)
names(core.rw)
# NOTE: Unit Conversion Step
#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR)
summary(core.rw)
core.rw <- core.rw/10
summary(core.rw)
core.rw[(nrow(core.rw)-20):nrow(core.rw), 1:10]
# ----------------------------------------------------------------------------
#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!
# Separating Dead vs. Missing rings
# What we need to know:
#1) Dead trees -- fill missing years with 0
#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0
#3) Live Trees, missing part of core -- model growth
# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years
for(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer
# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone
# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)
if(!is.na(core.data[core.data$CoreID==j, "zombie"]) | core.data[core.data$CoreID==j, "live.dead"]=="DEAD"){
last.meas <- as.numeric(core.data[core.data$CoreID==j, "outer.measured"]) # last ring which was mesured
last.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)
if(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled
inner.fill <- which(row.names(core.rw)== last.meas+1)
outer.fill <- which(row.names(core.rw)==last.yr)
core.rw[inner.fill:outer.fill,j] <- 0
}
}
}
summary(core.rw[,c(1:10, (ncol(core.rw)-10):ncol(core.rw))])
# ----------------------------------------------------------------------------
##########################################################################
#AGGREGATION STEP
#taking ring widths and aggregating from the core level to the tree level
##########################################################################
# ----------------------------------------------------------------------------
# aggregate to the tree level using only dated trees where possible
trees <- unique(substr(names(core.rw), 1, 6)) # listing trees we have measurements for
tree.rw <- data.frame(array(NA, dim=c(nrow(core.rw), length(trees)))) # a blank data frame to put everything in
row.names(tree.rw) <- row.names(core.rw)  # labeling the rows with the years from our rwl
names(tree.rw)<-unique(substr(names(core.rw), 1, 6)) # labeling the columns as trees
# summary(tree.rw) # this will get really big very quickly
dim(tree.rw) # 266 trees, 112 years of data
# The Aggregation Loop
for(i in unique(trees)){
cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with
cores <- names(core.rw)[cols] # getting the name of the cores we're working with
# -----------------------
# if there's only one core, we just take that regardless of wheter it's dated or not
if(length(cols) == 1){
tree.rw[,which(trees==i)] <- core.rw[,cols]
# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")
ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")
# Finding a (best-guess) pith date for the tree
tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores, "pith.yr"]
# -----------------------
} else {
# -----------------------
# if there's more than 1 core, we need to figure out which if any were dated
use <- vector(length=length(cols))
for(x in 1:length(cols)){
ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")
}
# -----------------------
# -----------------------
# now we know which were dated, so we can use that to figure out which cores to average
if(length(use[use=="TRUE"])==1) {
# if only 1 core is dated, use only that core and call the tree dated
tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]
tree.data[tree.data$TreeID==i, "Dated"] <- "Y"
tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]
# -----------------------
} else if(length(use[use=="TRUE"])>1) {
# -----------------------
# If there's greater than one dated core, take the mean of the dated cores and call the tree dated
tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)
tree.data[tree.data$TreeID==i, "Dated"] <- "Y"
tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)
} else {
# -----------------------
# If no cores are dated, take the mean of whatever we have and call the tree undated
tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T)
tree.data[tree.data$TreeID==i, "Dated"] <- "N"
tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)
# -----------------------
}
}
}
# Note: There are some warnings, but I think it's okay
# summary(tree.rw)
min(tree.rw, na.rm=T); max(tree.rw, na.rm=T)
dim(tree.rw)
tree.rw[(nrow(tree.rw)-20):nrow(tree.rw),1:10]
# We've updated the tree.data file, so lets save our changes before we move any further
# We only added a new column and didn't change anything that was original, so it should be okay, but lets just double check before moving forward
tree.data$Dated <- as.factor(tree.data$Dated)
summary(tree.data)
# NOTE: right now you have a ridculously long name for your tree data spreadsheet, so I'm going to call it something different for my own sanity right now :-P
write.csv(tree.data, "TreeData.csv", row.names=F)
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# CRR: writing our tree RWL to a csv formatted for gap filling before we calculate BAI (bc some have missing outsides and that's bad if we're working outside-in in out calculations)
# stacking the RWL so that we have a single column of ring widths & an identifying column with TreeID
tree.stack <- stack(tree.rw)
names(tree.stack) <- c("RW", "TreeID")
tree.stack$Year <- as.numeric(row.names(tree.rw)) # adding in the years
summary(tree.stack)
# attaching all of our useful tree data
summary(tree.data)
tree.stack <- merge(tree.stack, tree.data, all.x=T, all.y=F)
summary(tree.stack)
dim(tree.stack)
summary(tree.stack$Species)
write.csv(tree.stack, "TreeRWL_AllSites_stacked.csv", row.names=F)
# importing libraries
library(dplR)
library(lattice)
# Getting Libraries
library(reshape)
library(car)
library(mgcv)
library(nlme)
library(lmeSplines)
#library(lme4)
library(splines)
library(MASS)
library(MuMIn)
library(ggplot2)
library(grid)
se <- function(x){
sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))
#################################################################################################
# STEP 1: Gap-filling measured trees
# STEP 1b: Pith-correction in measured trees (useful for stand dynamics; won't do unless you ask for it)
# STEP 2: Gap-filling missing trees
#
# BIG SELLING POINT OF THIS APPROACH: we can quantify different levels of uncertainty & variability
# Caveats: fitting the initial GAMM is very time-intensive (it may take hours with your full data) because current form fits a spline to each tree in a mixed model framework
#################################################################################################
# Previous workflow
# 1) Read in RWL, QA/QC
# 3) Aggregate to tree (factoring in whether cores were dated) level & decide if an entire tree is dated or not -- WRITE THIS AS A FILE!
# 4) Stack RWL & Merge with metadata (becomes "ring.data" or named equivalent)
# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns
ring.data <- read.csv("TreeRWL_AllSites_stacked.csv")
ring.data$Tree <- as.factor(ring.data$Tree)
summary(ring.data)
# Tree Data
tree.data <- read.csv("TreeData.csv")
summary(tree.data)
# Site Data (for year cored)
Site.data <- read.csv("raw input files/DOE_plus_valles.csv", na.strings="")
Site.data$Year.sample <- as.numeric(substr(Site.data$date.sample,7,10))
summary(Site.data)
# merging in the year sampled into the tree data & calculating age
tree.data <- merge(tree.data, Site.data[,c("PlotID", "Year.sample")], all.x=T, all.y=F)
tree.data$PlotID
tree.data$Age <- tree.data$Year.sample - tree.data$Pith
summary(tree.data)
# We're going to run 2 sets of fillin models:
# 1) Model based on only DATED trees (m1d)
# 2) Model based on both DATED and UNDATED trees (m1u)
trees.dated <- ring.data[ring.data$Dated=="Y","TreeID"]
# using the gamm allows us to fit a smoothing spline to each tree, which allows us to basically gapfill taking into account unique tree temporal trends
#	current spline parameter: shrinkage version of cubic spline with 3 knots (stiff CR spline)
#	when we fit a generalized version for missing trees, we'll have to decide what to fit it to instead of TreeID; I think probably species|plot
# m1 <- gamm(RW ~ s(Year, bs="cs", k=3) + species + DBH..cm., random=list(Site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
# ----------------------------------------------------------------
# IDEAL MODEL FORM (it won't work for many reasons)
#	-- won't predict outside range of years observed on each core
#	-- end up with singularity issues
#	-- would take FOREVER to fit even if it did work
# m1d <- gamm(RW ~ s(Year, bs="cs", k=3, by=TreeID) + species*DBH..cm.*canopy.class, random=list(Site=~1, PlotID=~1, TreeID=~1), data=trees.dated.full, na.action=na.omit)
# ----------------------------------------------------------------
# ----------------------------------------------------------------
# The spline doesn't fit outside the range of observed values, so we need to give it a "null" guess
# As a very very rough guess right now, filling missing with the measurement from the oldest ring
# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)
# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?
# ---------------------------------------
# 1) Create rough size-age relationships to give a narrow window of rings to fill (i.e. don't fill a 10 cm oak back to 1900 if our rings stop in 1980)
# ---------------------------------------
# What we need: core summary data (DBH..cm., estimated pith date)
# Ignoring all the Sites we don't have and doing some exploratory graphing
tree.data2 <- tree.data[tree.data$PlotID %in% unique(ring.data$PlotID),]
summary(tree.data2)
# Need to remove species for which we have no pith estimates for the time being
Species.pith <- unique(tree.data2[!is.na(tree.data2$Pith), "Species"])
tree.data3 <- tree.data2[tree.data2$Species %in%  Species.pith,]
summary(tree.data3)
qplot(DBH..cm., Age, color=Species, data=tree.data3) + facet_wrap(~Species) +
stat_smooth(method="lm", alpha=0.5, size=1.5) +
theme_bw()
# Making a very basic linear model looking at Site-specific species-DBH..cm.-age relationships
dbh.age <- lm(Age ~ Species*DBH..cm.*Site-1, data=tree.data3)
summary(dbh.age)
summary(dbh.age)$r.squared # Note, this very basic model works pretty well!
# Using the prediction interval to get us a higher upper bound
age.pi <- predict(dbh.age, newdata=tree.data3, interval="predict")
summary(age.pi)
dim(age.pi); dim(tree.data3) # Making sure we didn't lose any rows along the way
tree.data3 <- cbind(tree.data3, age.pi)
summary(tree.data3)
# Setting the filling window to the upper p.i. limit
tree.data3$fill.year <- ifelse(is.na(tree.data3$Pith), tree.data3$Year.sample-tree.data3$upr, tree.data3$Pith)
summary(tree.data3)
# Merging this back into a data frame that contains info for all the trees we're modeling right now
tree.data.model <- merge(tree.data3, tree.data2, all.x=T, all.y=T)
summary(tree.data.model)
summary(tree.data.model$Species)
#---------------------
# QUESTION: what to do about the species with no pith estimates?
#	For now, I'm just going to do a species-naive fit within each plot
#---------------------
dbh.age.plot <- lm(Age ~ DBH..cm.*PlotID-1, data=tree.data.model)
summary(dbh.age.plot)
age.pi.plot <- predict(dbh.age.plot, newdata= tree.data.model, interval="predict")
summary(age.pi.plot)
dim(age.pi.plot); dim(tree.data.model)
summary(tree.data.model)
# Filling missing fill.year with one caluclated form age.pi.plot fill
tree.data.model[is.na(tree.data.model$fill.year),"fill.year"] <- tree.data.model[is.na(tree.data.model$fill.year),"Year.sample"] - age.pi.plot[which(is.na(tree.data.model$fill.year)),3]
summary(tree.data.model)
#---------------------
# ---------------------------------------
# ORIGINAL USAGE: Provide dummy variable
# 2) fill the modeling window with non-0 values... perhaps mean growth from last decade or past observed trend?
#		QUESTION: What dummy value do we want to give it?
#			For now, I'm going to do the mean of the last decade
# ---------------------------------------
# summary(ring.data)
# ring.data$RW0 <- ring.data$RW # Making a column of dummy-filled ring widths
# for(i in unique(ring.data$TreeID)){
# #------------------------------
# #year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)
# #year.min = the oldest year measured
# #rw.fill = the dummy ring width to feed the model; right now this is for the last measured decade
# #			-- (yr.min + 10) means the 10 years following year.min (
# #			-- e.g. if min year = 1950, we'll fill with the mean value from 1950:1960
# #------------------------------
# yr.fill <- tree.data.model[tree.data.model$TreeID==i,"fill.year"]
# yr.min <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])
# rw.fill <- mean(ring.data[ring.data$TreeID==i & ring.data$Year>=yr.min & ring.data$Year<=(yr.min+10), "RW"],na.rm=T)
# #------------------------------
# #------------------------------
# # The actual insertion of the dummy fil value into the fill range
# #------------------------------
# ring.data[ring.data$TreeID==i & is.na(ring.data$RW) & ring.data$Year>=yr.fill, "RW0"] <- rw.fill
# #------------------------------
# }
# summary(ring.data)
# # ---------------------------------------
# ---------------------------------------
# New Usage: delete NAs for years way outside what we think we should be fitting
# 2b) I still don't think we want to be fi
# ---------------------------------------
summary(tree.data.model)
summary(ring.data)
dim(ring.data)
for(i in unique(ring.data$TreeID)){
#------------------------------
#year.fill = the oldest year to fill based on above step (prediction interval, size-species-Site relationships)
#------------------------------
yr.fill <- tree.data.model[tree.data.model$TreeID==i,"fill.year"]
#------------------------------
#------------------------------
# The actual insertion of the dummy fil value into the fill range
#------------------------------
ring.data <- ring.data[!(ring.data$TreeID==i & ring.data$Year<yr.fill),]
#------------------------------
}
summary(ring.data)
dim(ring.data)
summary(ring.data$Species)
summary(ring.data$PlotID)
# ################################################################
# ################################################################
# RUNNING THE GAMM!!
# ################################################################
# ################################################################
# A generalized additive mixed model (gamm) allows us to fit splines in a mixed model context
# we can let these splines vary by tree which essentially detrends the core
# here's we're using our dummy-filled ring widths as a response so that the spline will fit over the whole time period of interest
# NOTE: for this to work with canopy class, we'll need to figure out what to do about dead trees
# NOTE: Right now this is set up for each Site separately.  If you want to borrow strength from other Sites to help gap fill certain species, run them together
# ################################################################
# ----------------------------------------------------------------
# Gapfilling trees for which we have at least some measurements
# ----------------------------------------------------------------
# ---------------------------------------
# Morgan Monroe Forest
# ---------------------------------------
ring.data.mmf <- ring.data[substr(ring.data$PlotID,1,2)=="MM",]
ring.data.mmf <- droplevels(ring.data.mmf)
# Note: the log link with the gaussian family to prevent fitting negative values requires that you can't actually have 0 growth so we're going to make it really really small instead
ring.data.mmf$RW <- ifelse(ring.data.mmf$RW==0, 1e-6, ring.data.mmf$RW)
summary(ring.data.mmf)
gamm.mmf <- gamm(log(RW) ~ s(Year, bs="cs", k=3, by=TreeID) + DBH..cm., random=list(Species=~1, Site=~1, PlotID=~1), data= ring.data.mmf, na.action=na.omit)
# Saving the GAMM From above so we can load it without having to refit it
save(gamm.mmf, file="GapFilling_gamm_mmf_02.2015.rData")
# # This isn't a great way of doing it, but it'll let you see the splines for each of the cores
# par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)
# plot(gamm.mmf$gam)
# Making Predicted ring widths
ring.data.mmf$RW.modeled <- exp(predict(gamm.mmf, ring.data.mmf))
summary(ring.data.mmf)
write.csv(ring.data.valles, "GapFilling_MMF_Measured_Filled.csv", row.names=F)
# Graphing of the modeled rings we will use to fill the data (note this isn't truncating ones that are past where we think pith actually is)
pdf("gamm_gapfill_mmf.pdf", height=7.5, width=10)
ggplot() + facet_wrap(~Species) +
geom_path(aes(x=Year, y=RW, color=Species), data=ring.data.mmf, size=0.5) +
geom_point(aes(x=Year, y=RW.modeled), ring.data.mmf[is.na(ring.data.mmf$RW),], size=0.5) +
scale_y_continuous(limits=c(0,1.25)) +
theme_bw()
dev.off()
# ---------------------------------------
# ---------------------------------------
# Valles Caldera (Upper & Lower modeled together)
# ---------------------------------------
ring.data.valles <- ring.data[substr(ring.data$PlotID,1,2)=="VL" | substr(ring.data$PlotID,1,2)=="VU",]
ring.data.valles <- droplevels(ring.data.valles)
ring.data.valles$RW <- ifelse(ring.data.valles$RW==0, 1e-6, ring.data.valles$RW)
summary(ring.data.valles)
gamm.valles <- gamm(log(RW) ~ s(Year, bs="cs", k=3, by=TreeID) + DBH..cm., random=list(Species=~1, Site=~1, PlotID=~1), data= ring.data.valles, na.action=na.omit)
summary(ring.data.mmf)
ring.data.mmf$RW.modeled <- exp(predict(gamm.mmf, ring.data.mmf))
update.packages()
ring.data.mmf <- ring.data[substr(ring.data$PlotID,1,2)=="MM",]
ring.data.mmf <- droplevels(ring.data.mmf)
# Note: the log link with the gaussian family to prevent fitting negative values requires that you can't actually have 0 growth so we're going to make it really really small instead
ring.data.mmf$RW <- ifelse(ring.data.mmf$RW==0, 1e-6, ring.data.mmf$RW)
summary(ring.data.mmf)
min(ring.data.mmf$RW, na.rm=T)
par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)
plot(gamm.mmf$gam)
library(nlme)
gamm.mmf <- gamm(log(RW) ~ s(Year, bs="cs", k=3, by=TreeID) + DBH..cm., random=list(Species=~1, Site=~1, PlotID=~1), data= ring.data.mmf, na.action=na.omit)
# Saving the GAMM From above so we can load it without having to refit it
save(gamm.mmf, file="GapFilling_gamm_mmf_02.2015.rData")
# # This isn't a great way of doing it, but it'll let you see the splines for each of the cores
# par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)
# plot(gamm.mmf$gam)
# Making Predicted ring widths
ring.data.mmf$RW.modeled <- exp(predict(gamm.mmf, ring.data.mmf))
summary(ring.data.mmf)
write.csv(ring.data.mmf, "GapFilling_MMF_Measured_Filled.csv", row.names=F)
