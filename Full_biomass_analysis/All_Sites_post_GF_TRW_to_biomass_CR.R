#setwd("~/Dropbox/PalEON CR/Tree Rings/Tree-Rings-and-Biomass/Uncertainty_analysis")

library(dplR)
library(ggplot2)
se <- function(x){
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
# Run this script after the gap filling process scripts have been run
# For the NACP15 abstract run Tree_rw_gapfilled.csv


# load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.

g.filled.diam <- read.csv("GapFilling_DBHrecon_ALL.csv", header=T, row.names=1)
#g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
summary(g.filled.diam)

# read in tree data
tree.data <- read.csv("TreeData.csv", header=T)
summary(tree.data)
trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" | substr(tree.data$PlotID, 1, 2)=="MM",]
#trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]
summary(trees.use)

summary(trees.use[substr(trees.use$PlotID, 1, 2)=="VU",])
summary(trees.use[substr(trees.use$PlotID, 1, 2)=="VL",])

#quick plot
#spag.plot(g.filled.diam)
load("marcy_density.Rdata")

summary(marcy.density)
marcy.density$n.stems <- NULL

ross.density <- read.csv("raw input files/ross_density.csv", header=T)
ross.density.site <- ross.density[substr(ross.density$PlotID, 1,1)=="V",]

ross.density.plot <- ross.density

ross.density.plot$PlotID <- recode(ross.density.plot$PlotID, "  'MCO.5'='VUA'; 'MCO.6'='VUB'; 'PPI.5'='VLA'; 'PPI.6'='VLB'")
summary(ross.density.plot)

valles.density <- merge(marcy.density, ross.density, all.x=T, all.y=T)
summary(valles.density)

vuf.density <- valles.density[substr(valles.density$PlotID, 1, 3)== "MCO",]
vuf.site.density<- mean(vuf.density$Density.Total..stems.m2.)

vlf.density <- valles.density[substr(valles.density$PlotID, 1, 3)== "PPI",]
vlf.site.density<- mean(vlf.density$Density.Total..stems.m2.)

site.numbers <- c(vuf.site.density, vlf.site.density)
site.names <- c("VUF", "VLF")

site.density <- data.frame("PlotID" = site.names, "density.m2"=site.numbers)
summary(site.density)
save(site.density, file="site_density.Rdata")

plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
summary(plot.data)


##########################################################################
# Allometric Equations
##########################################################################


#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations
library(car)
load("allometries_list.Rdata")
summary(allometries)

# Getting rid of POTR for now for conceptual figure purposes
#trees.use <- trees.use[!(trees.use$Species=="POTR"),]
summary(trees.use)
unique(trees.use$Species)

trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'; 'POTR' = 'potr'; 
                              'ACSA' = 'acsa'; 'NYSY'= 'nysy' ; 'ASTR'='e.hard'; 'FAGR'='fagr'; 'FRAX'='fram'; 'LITU'='litu'; 
                              'POGR'='pogr'; 'QUAL'='qual'; 'QURU'='quru'; 'SAAL'='saal'; 'TIAM'='tiam'; 'ULRU'='e.hard'")
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet


# will want to do general equations and pft level equations as well, but later
# log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics

#allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}

# dbh <- 1:50
# test <- allom.eq(mu0= -3.5185,
#                  mu1 = 2.6909,
#                  DBH = dbh)
# 
# plot(test*.09 ~ dbh)

allom.temp <- g.filled.diam
allom.temp[,] <- NA

# dbh=0 causes problems, so we're going to make those NA
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam)
dim(g.filled.diam)

bm.array <- array(NA, dim=c(nrow(g.filled.diam), length(unique(trees.use$PlotID)), nrow(allometries[[1]])))
row.names(bm.array) <- row.names(g.filled.diam)  #CRR Added
dimnames(bm.array)[[2]] <- unique(trees.use$PlotID)
summary(bm.array[,,1])
#--------------------------------------------------
# INSERT i LOOP HERE to go through each iteration of randomness from MCMC
# This is one big loop that goes through each layer of the 500 iterations
#--------------------------------------------------
for(i in 1:nrow(allometries[[1]])){
  allom.temp <- g.filled.diam
  allom.temp[,] <- NA
  
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
  cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
  # Note: we'll have to make this a bit fancier in the future for species with mu0==0
#   allom.temp[,cols] <- allom.eq(mu0= -3.5185,
#                          mu1 = 2.6909,
#                         #DBH = seq(from=30, to=1, length=nrow(g.filled.diam)))
#                          DBH = g.filled.diam[,cols])
# test <- allom.eq(mu0=ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"]),
#                               mu1 =ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"]),
#                               DBH = g.filled.diam[,cols])
  # mu0 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"])
  # mu1 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"])
  mu0=allometries[[j]][i,"Bg0"]
  mu1=allometries[[j]][i,"Bg1"]
  allom.temp[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
# summing to the plot level

allom.temp[is.na(allom.temp)] <- 0

# biomass loop for summing trees to plots
# We're doing the unit conversions here; we had calculated density in stems/ha, but Christy wants to look at Biomass in kg/m2, so we're putting everything in kg/m2 here
for(p in 1:length(plots)){
  cols <- which(names(allom.temp) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
  if(substr(plots[p],1,1)=="V"){
    bm.array[,p,i] <- rowMeans(allom.temp[,cols])*plot.data[plot.data$PlotID==paste(plots[p]), "Density.Total..stems.ha."]/10000 #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
  } else {
    temp <- allom.temp[,cols]
    for(n in names(temp)){ # Convert biomass/tree to biomass/ha
      temp[,n] <- temp[,n] * tree.data[tree.data$TreeID==n,"Density..stems.ha."]/10000
      }
    bm.array[,p,i] <- rowSums(temp) #sum biomass/ha
    }
}
}
#--------------------------------------------------

#bm.array[,,1]
summary(bm.array[,,1])

# OFFENDER: VUF032; VUF026 is good
g.filled.diam[,c("VUF026","VUF032")]

### OUTSIDE of all LOOPs (iteration + species + plots)
# You should now have a 3-dimensional array with plots as columns, years as rows, and iterations as layers
biom.mean <- apply(bm.array[,,], c(1,2), mean) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
biom.ci <- apply(bm.array[,,], c(1,2), quantile, c(0.025, 0.975)) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
# biom.se <- apply(bm.array[,,], c(1,2), se)

biom.mean <- as.data.frame(biom.mean)
names(biom.mean)<- plots

biom.lbound <- data.frame(biom.ci[1,,])
names(biom.lbound) <- paste(plots, "LB", sep=".")
biom.ubound <- data.frame(biom.ci[2,,])
names(biom.ubound) <- paste(plots, "UB", sep=".")
# biom.ci <-as.data.frame(biom.ci)
# names(biom.ci)<- c(paste(plots, "sd", sep="."))
# biom.se <-as.data.frame(biom.se)
# names(biom.se)<- c(paste(plots, "se", sep="."))


biom.all <- as.data.frame(c(biom.mean, biom.lbound, biom.ubound))
row.names(biom.all) <- row.names(biom.mean)
summary(biom.all)
head(biom.all)

save(biom.all, file="allsites_bm_recon.Rdata")

ci.vu <- data.frame(Year=as.numeric(row.names(biom.all)), SiteID= "VUF",
                    Mean = rowMeans(biom.all[,c("VUA", "VUB")]),
                    LB=apply(biom.all[,c("VUA", "VUB")],1, quantile, 0.025), 
                    UB=apply(biom.all[,c("VUA", "VUB")],1, quantile, 0.975))
ci.vl <- data.frame(Year=as.numeric(row.names(biom.all)), SiteID= "VLF",
                    Mean = rowMeans(biom.all[,c("VLA", "VLB")]),
                    LB=apply(biom.all[,c("VLA", "VLB")],1, quantile, 0.025), 
                    UB=apply(biom.all[,c("VLA", "VLB")],1, quantile, 0.975))
ci.mmf <- data.frame(Year=as.numeric(row.names(biom.all)), SiteID= "MMF",
                     Mean = rowMeans(biom.all[,c("MMA", "MMB", "MMC")]),
                     LB=apply(biom.all[,c("MMA", "MMB", "MMC")],1, quantile, 0.025), 
                     UB=apply(biom.all[,c("MMA", "MMB", "MMC")],1, quantile, 0.975))


dens.uncert <- rbind(ci.vl, ci.vu, ci.mmf)
summary(dens.uncert)

ggplot(dens.uncert[dens.uncert$Year <=2011,]) + facet_grid(SiteID ~ .) +
  geom_ribbon(aes(x=Year, ymin=LB, ymax=UB, fill=SiteID), alpha=0.5) +
  geom_line(aes(x=Year, y=Mean, color=SiteID))

save(dens.uncert, file="allsites_density_uncertainty.Rdata")




#save(biom.valles.cum.dens, file="biom_valles_dum_m2.csv")

biom.all.stack <- stack(biom.all[1:7])
names(biom.all.stack) <- c("Biom.Mean", "PlotID")
biom.all.stack$Year <- as.numeric(paste(row.names(biom.all)))
biom.all.stack$Plot <- as.factor(substr(biom.all.stack$PlotID, 3,3))
biom.all.stack$Site <- as.factor(substr(biom.all.stack$PlotID, 1,2))
summary(biom.all.stack)

biom.all.stack.lb <- stack(biom.all[8:14])
names(biom.all.stack.lb) <- c("Biom.LB", "PlotID")

biom.all.stack.ub <- stack(biom.all[15:21])
names(biom.all.stack.ub) <- c("Biom.UB", "PlotID")

biom.all.stack$Biom.LB <- biom.all.stack.lb[,1]
biom.all.stack$Biom.UB <- biom.all.stack.ub[,1]
summary(biom.all.stack)

# biom.all.stack$Ribbon.max <- biom.all.stack$Biom.Mean + biom.all.stack$Biom.ci
# biom.all.stack$Ribbon.min <- biom.all.stack$Biom.Mean - biom.all.stack$Biom.ci
# biom.all.stack$Ribbon.min <- ifelse(biom.all.stack$Ribbon.min < 0, 0, biom.all.stack$Ribbon.min)
# biom.all.stack$Ribbon.max <- ifelse(biom.all.stack$Ribbon.max > 100, 100, biom.all.stack$Ribbon.max)
summary(biom.all.stack)

save(biom.all.stack, file="all_bm_recon_stack.Rdata")
load("all_bm_recon_stack.Rdata")
library(ggplot2)

ggplot(data=biom.all.stack[biom.all.stack$Year<2012 & (biom.all.stack$Site=="VL"),])  + facet_grid(Plot ~ Site) +
  # plotting total site basal area  
  geom_ribbon(aes(x=Year, ymin=Biom.LB, ymax=Biom.UB, fill=PlotID), alpha=0.5) +
  geom_line(aes(x=Year, y=Biom.Mean, color=PlotID)) +
  ggtitle("all Caldera Lower (PIPO)")

ggplot(data=biom.all.stack[biom.all.stack$Year<2012 & (biom.all.stack$Site=="VU"),])  + facet_grid(Plot ~ Site) +
#ggplot(data=biom.all.stack[biom.all.stack$Year<2012 & (biom.all.stack$PlotID=="VUB"),])  + facet_grid(Plot ~ Site) +
  # plotting total site basal area  
  geom_ribbon(aes(x=Year, ymin=Biom.LB, ymax=Biom.UB, fill=PlotID), alpha=0.5) +
  geom_line(aes(x=Year, y=Biom.Mean, color=PlotID)) +
  ggtitle("all Caldera Upper (MCON)")



# all.cum.plot<- 
#pdf("all_Biomass_19March_Christy_ChojnackyOnly.pdf", height=8.5, width=11)
ggplot(data=biom.all.stack[biom.all.stack$Year<2012,])  + facet_grid(Site ~ .) +
  # plotting total site basal area  
  geom_ribbon(aes(x=Year, ymin=Biom.LB, ymax=Biom.UB, fill=PlotID), alpha=0.5) +
  geom_line(aes(x=Year, y=Biom.Mean, color=PlotID)) 
#   theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=12), axis.text.y=element_text(color="black", size=12))+
#   scale_fill_discrete(name="Model", labels = c("nt.pipo.mean", "nt.piaz.mean", "nt.pine.spp", "nt.vcnp.mean", "nt.pine.dom.mean")))
# dev.off()


#########################################################################
# Now we want to look at the site level biomass Allometric Uncertainty
##########################################################################


#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations
library(car)
load("allometries_list.Rdata")

# Getting rid of POTR for now for conceptual figure purposes
#trees.use <- trees.use[!(trees.use$Species=="POTR"),]
summary(trees.use)
unique(trees.use$Species)

trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'; 'POTR' = 'potr'; 
                              'ACSA' = 'acsa'; 'NYSY'= 'nysy' ; 'ASTR'='e.hard'; 'FAGR'='fagr'; 'FRAX'='fram'; 'LITU'='litu'; 
                              'POGR'='pogr'; 'QUAL'='qual'; 'QURU'='quru'; 'SAAL'='saal'; 'TIAM'='tiam'; 'ULRU'='e.hard'")
summary(trees.use)
plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet

ross.density.plot

# will want to do general equations and pft level equations as well, but later
# log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics

#allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}

# dbh <- 1:50
# test <- allom.eq(mu0= -3.5185,
#                  mu1 = 2.6909,
#                  DBH = dbh)
# 
# plot(test*.09 ~ dbh)

allom.temp <- g.filled.diam
allom.temp[,] <- NA

# dbh=0 causes problems, so we're going to make those NA
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam)
dim(g.filled.diam)

bm.array <- array(NA, dim=c(nrow(g.filled.diam), ncol(g.filled.diam), nrow(allometries[[1]])))
row.names(bm.array) <- row.names(g.filled.diam)  #CRR Added
dimnames(bm.array)[[2]] <- names(g.filled.diam)
# summary(bm.array[,,1])
dim(bm.array)

#--------------------------------------------------
# INSERT i LOOP HERE to go through each iteration of randomness from MCMC
# This is one big loop that goes through each layer of the 500 iterations
#--------------------------------------------------
for(i in 1:nrow(allometries[[1]])){
  allom.temp <- g.filled.diam
  allom.temp[,] <- NA
  
  # Species loop for calculating tree biomass
  for(j in unique(trees.use$spp.allom)){
    cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
    # Note: we'll have to make this a bit fancier in the future for species with mu0==0
    #   allom.temp[,cols] <- allom.eq(mu0= -3.5185,
    #                          mu1 = 2.6909,
    #                         #DBH = seq(from=30, to=1, length=nrow(g.filled.diam)))
    #                          DBH = g.filled.diam[,cols])
    # test <- allom.eq(mu0=ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"]),
    #                               mu1 =ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"]),
    #                               DBH = g.filled.diam[,cols])
    # mu0 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu0"], allometries[[j]][i,"Bg0"])
    # mu1 = ifelse(!(allometries[[j]][i,"mu0"]==0 & allometries[[j]][i,"mu1"]==0),allometries[[j]][i,"mu1"], allometries[[j]][i,"Bg1"])
    mu0=allometries[[j]][i,"Bg0"]
    mu1=allometries[[j]][i,"Bg1"]
    allom.temp[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
  }
  # summing to the plot level
  
  allom.temp[is.na(allom.temp)] <- 0
  
  # biomass loop for summing trees to plots
  # We're doing the unit conversions here; we had calculated density in stems/ha, but Christy wants to look at Biomass in kg/m2, so we're putting everything in kg/m2 here
  for(p in 1:length(plots)){
    cols <- which(names(allom.temp) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
    dens <- ross.density.plot[ross.density.plot$PlotID==paste(plots[p]), "Density.Total..stems.m2."]
    for(c in 1:length(cols)){
      bm.array[,cols[c],i] <- allom.temp[,cols[c]]*dens #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
      
    }

      #bm.array[,p,i] <- rowMeans(allom.temp[,cols])*plot.data[plot.data$PlotID==paste(plots[p]), "density.m2"] #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
#      } #else {
#       temp <- allom.temp[,cols]
#       for(n in names(temp)){ # Convert biomass/tree to biomass/ha
#         temp[,n] <- temp[,n] * tree.data[tree.data$TreeID==t,"Density..stems.ha."]/10000
#       }
#       bm.array[,p,i] <- rowSums(temp) #sum biomass/ha
#     }
  }
}
#--------------------------------------------------
#bm.array[,,1]
summary(bm.array[,1:10,1])

# Get to site level by taking mean of trees (ignoring plots & potential pseudoreplication issues)
vlf.mean <- apply(bm.array[,substr(dimnames(bm.array)[[2]],1,3)=="VLF",], c(1,3), mean) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
dim(vlf.mean)
summary(vlf.mean[,1:10])


vuf.mean <- apply(bm.array[,substr(dimnames(bm.array)[[2]],1,3)=="VUF",], c(1,3), mean) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
dim(vuf.mean)
summary(vuf.mean[,1:10])

mmf.mean <- apply(bm.array[,substr(dimnames(bm.array)[[2]],1,2)=="MM",], c(1,3), mean)
dim(mmf.mean)
summary(mmf.mean[,1:10])


vlf.ci <- data.frame(Year=as.numeric(row.names(vlf.mean)), SiteID="VLF", Mean=rowMeans(vlf.mean), LB=apply(vlf.mean,1,quantile, 0.025), UB=apply(vlf.mean,1,quantile, 0.975))
summary(vlf.ci)

vuf.ci <- data.frame(Year=as.numeric(row.names(vuf.mean)), SiteID="VUF", Mean=rowMeans(vuf.mean), LB=apply(vuf.mean,1,quantile, 0.025), UB=apply(vuf.mean,1,quantile, 0.975))
summary(vuf.ci)

mmf.ci <- data.frame(Year=as.numeric(row.names(mmf.mean)), SiteID="MMF", Mean=rowMeans(mmf.mean), LB=apply(mmf.mean,1,quantile, 0.025), UB=apply(mmf.mean,1,quantile, 0.975))
summary(mmf.ci)

allom.uncert <- data.frame(rbind(vlf.ci, vuf.ci, mmf.ci))
summary(allom.uncert)

ggplot(allom.uncert[allom.uncert$Year<=2011,]) + facet_grid(SiteID ~.) +
  geom_ribbon(aes(x=Year, ymin=LB, ymax=UB, fill=SiteID), alpha=0.5) +
  geom_line(aes(x=Year, y=Mean, color=SiteID))

save(allom.uncert, file="allsites_allometry_uncertainty.Rdata")

# ### OUTSIDE of all LOOPs (iteration + species + plots)
# # You should now have a 3-dimensional array with plots as columns, years as rows, and iterations as layers
# site.mean <- apply(bm.array[,,], c(1,2), mean) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
# site.ci <- apply(bm.array[,,], c(1,2), quantile, c(0.025, 0.975)) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
# # site.se <- apply(bm.array[,,], c(1,2), se)
# 
# site.mean <- as.data.frame(site.mean)
# #names(site.mean)<- sites
# 
# site.lbound <- data.frame(site.ci[1,,])
# names(site.lbound) <- paste(sites, "LB", sep=".")
# site.ubound <- data.frame(site.ci[2,,])
# names(site.ubound) <- paste(sites, "UB", sep=".")
# # site.ci <-as.data.frame(site.ci)
# # names(site.ci)<- c(paste(plots, "sd", sep="."))
# # site.se <-as.data.frame(site.se)
# # names(site.se)<- c(paste(plots, "se", sep="."))
# 
# 
# site.valles <- as.data.frame(c(site.mean, site.lbound, site.ubound))
# row.names(site.valles) <- row.names(site.mean)
# summary(site.valles)
# head(site.valles)
# 
# save(site.valles, file="valles_bm_recon_site.Rdata")
# #save(biom.valles, file="biom.valles_cum.csv")
# 
# 
# site.valles.stack <- stack(site.valles[1:2])
# names(site.valles.stack) <- c("site.Mean", "SiteID")
# site.valles.stack$Year <- as.numeric(paste(row.names(site.valles)))
# #site.valles.stack$Plot <- as.factor(substr(site.valles.stack$PlotID, 3,3))
# site.valles.stack$Site.name <- as.factor(substr(site.valles.stack$SiteID, 1,3))
# summary(site.valles.stack)
# 
# site.valles.stack.lb <- stack(site.valles[3:4])
# names(site.valles.stack.lb) <- c("site.LB", "SiteID")
# 
# site.valles.stack.ub <- stack(site.valles[5:6])
# names(site.valles.stack.ub) <- c("site.UB", "SiteID")
# 
# site.valles.stack$site.LB <- site.valles.stack.lb[,1]
# site.valles.stack$site.UB <- site.valles.stack.ub[,1]
# summary(site.valles.stack)
# 
# 
# summary(site.valles.stack)
# 
# save(site.valles.stack, file="valles_bm_recon_site_stack.Rdata")
# load("valles_bm_recon_stack.Rdata")
# library(ggplot2)
# 
# ggplot(data=site.valles.stack[site.valles.stack$Year<2012 ,])  + facet_grid(SiteID~.) +
#   # plotting total site basal area  
#   geom_ribbon(aes(x=Year, ymin=site.LB, ymax=site.UB, fill=SiteID), alpha=0.5) +
#   geom_line(aes(x=Year, y=site.Mean, color=SiteID)) +
#   ggtitle("Valles Caldera mean Densities")
# 
# 
# 
# ###################################################################################################################
# # We need to look at the spread in the density fluctuations, and not the allometric equations as previously shown
# ####################################################################################################################
# 
# 
# 
# ################################################################################
# # All Trees BM estimates
# ################################################################################
# 
# 
# # load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.
# 
# g.filled.diam <- read.csv("GapFilling_DBHrecon_ALL.csv", header=T, row.names=1)
# g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
# summary(g.filled.diam)
# dim(g.filled.diam)
# # read in tree data
# tree.data <- read.csv("TreeData.csv", header=T)
# summary(tree.data)
# 
# trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V",]
# summary(trees.use)
# 
# #quick plot
# #spag.plot(g.filled.diam)
# 
# plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
# summary(plot.data)
# 
# # ross.density <- read.csv("raw input files/ross_density.csv", header=T)
# # 
# # ross.density.site <- ross.density[substr(ross.density$PlotID, 1, 1)=="V",]
# # 
# # # sites <- unique(site.density$PlotID)
# # sites <- unique(ross.density.site$PlotID)
# 
# 
# ##########################################################################
# # Allometric Equations
# ##########################################################################
# 
# 
# #Convert to biomass with the allometric equation
# #using the PECAN generated bayesian equations
# library(car)
# 
# # Getting rid of POTR for now for conceptual figure purposes
# #trees.use <- trees.use[!(trees.use$Species=="POTR"),]
# summary(trees.use)
# unique(trees.use$Species)
# 
# trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'; 'POTR'='potr'")
# summary(trees.use)
# plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
# 
# load("allometries_list.Rdata")
# # will want to do general equations and pft level equations as well, but later
# # log(AGB) = mu0 + mu1*log(DBH) --equaton form of PECAN allometrics
# 
# #allom.eq <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
# allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
# 
# # dbh <- 1:50
# # test <- allom.eq(mu0= -3.5185,
# #                  mu1 = 2.6909,
# #                  DBH = dbh)
# # 
# # plot(test*.09 ~ dbh)
# 
# allom.temp <- g.filled.diam
# allom.temp[,] <- NA
# 
# # dbh=0 causes problems, so we're going to make those NA
# g.filled.diam[g.filled.diam==0] <- 1e-6
# min(g.filled.diam, na.rm=T)
# summary(g.filled.diam)
# dim(g.filled.diam)
# 
# bm.all.array <- g.filled.diam
# bm.all.array[,] <- NA
# row.names(bm.all.array) <- row.names(g.filled.diam)  #CRR Added
# summary(bm.all.array)
# dim(bm.all.array)
# 
# #--------------------------------------------------
# # 
# # 
# #--------------------------------------------------
# 
# # Species loop for calculating tree biomass
# for(j in unique(trees.use$spp.allom)){
#   cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
#   
#   mu0=mean(allometries[[j]][,"Bg0"])
#   mu1=mean(allometries[[j]][,"Bg1"])
#   bm.all.array[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
# }
# summary(bm.all.array)
# dim(bm.all.array)
# 
# all.bm <- bm.all.array
# 
# for(p in 1:length(plots)){
#   cols <- which(names(bm.all.array) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
# 
#   all.bm[,cols] <- bm.all.array[,cols]*plot.data[plot.data$PlotID==paste(plots[p]), "Density.Total..stems.ha."]/10000 #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
#     
# }
# 
# 
# 
# dim(all.bm)
# 
# summary(all.bm)
# 
# all.vlf <- all.bm[,substr(names(all.bm), 1, 3)=="VLF"] 
# dim(all.vlf)
# 
# all.vuf <- all.bm[,substr(names(all.bm), 1, 3)=="VUF"] 
# dim(all.vuf)
# 
# vlf.sample.mean <-apply(all.vlf[,], 1, mean, na.rm=T) 
# vlf.sample.ci <- apply(all.vlf[,], 1, quantile, c(0.025, 0.975), na.rm=T) 
# 
# summary(vlf.sample.ci)
# 
# vuf.sample.mean <-apply(all.vuf, 1, mean, na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
# vuf.sample.ci<- apply(all.vuf, 1, quantile, c(0.025, 0.975), na.rm=T) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
# 
# vlf.sample.mean <- as.data.frame(vlf.sample.mean)
# names(vlf.sample.mean)<- "VLF"
# 
# vlf.sample.lbound <- data.frame(vlf.sample.ci[1,])
# names(vlf.sample.lbound) <- paste("VLF", "LB", sep=".")
# vlf.sample.ubound <- data.frame(vlf.sample.ci[2,])
# names(vlf.sample.ubound) <- paste("VLF", "UB", sep=".")
# 
# vuf.sample.mean <- as.data.frame(vuf.sample.mean)
# names(vuf.sample.mean)<- "VUF"
# 
# vuf.sample.lbound <- data.frame(vuf.sample.ci[1,])
# names(vuf.sample.lbound) <- paste("VUF", "LB", sep=".")
# vuf.sample.ubound <- data.frame(vuf.sample.ci[2,])
# names(vuf.sample.ubound) <- paste("VUF", "UB", sep=".")
# 
# 
# all.valles.sample <- as.data.frame(c(vuf.sample.mean, vuf.sample.lbound, vuf.sample.ubound, vlf.sample.mean, vlf.sample.lbound, vlf.sample.ubound))
# row.names(all.valles.sample) <- row.names(all.bm)
# summary(all.valles.sample)
# head(all.valles.sample)
# 
# 
# all.valles.sample.stack <- stack(all.valles.sample[c(1,4)])
# names(all.valles.sample.stack) <- c("all.Mean.sample", "SiteID")
# all.valles.sample.stack$Year <- as.numeric(paste(row.names(all.valles.sample)))
# summary(all.valles.sample.stack)
# 
# all.valles.sample.stack.lb <- stack(all.valles.sample[c(2,5)])
# names(all.valles.sample.stack.lb) <- c("all.sample.LB", "SiteID")
# head(all.valles.sample.stack.lb)
# 
# all.valles.sample.stack.ub <- stack(all.valles.sample[c(3,6)])
# names(all.valles.sample.stack.ub) <- c("all.sample.UB", "SiteID")
# 
# all.valles.sample.stack$all.sample.LB <- all.valles.sample.stack.lb[,1]
# all.valles.sample.stack$all.sample.UB <- all.valles.sample.stack.ub[,1]
# summary(all.valles.sample.stack)
# 
# 
# summary(all.valles.sample.stack)
# save(all.valles.sample.stack, file="allTrees_valles_sample_stack.Rdata")
# 
# ggplot(data=all.valles.sample.stack[all.valles.sample.stack$Year<2012,])  + facet_grid(SiteID ~.) +
#   # plotting total site basal area  
#   geom_ribbon(aes(x=Year, ymin=all.sample.LB, ymax=all.sample.UB, fill=SiteID), alpha=0.5) +
#   geom_line(aes(x=Year, y=all.Mean.sample, color=SiteID))+
#   labs(title= "All Trees BM sample", x="Year", y="Bm sample. (kg/m2)")
# 
# 
# 
