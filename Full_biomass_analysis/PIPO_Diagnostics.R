##########################################################################
# Set Directories, load libraries
##########################################################################
setwd("~/Dropbox/PalEON CR/Tree Rings/Tree-Rings-and-Biomass/Uncertainty_analysis")

library(dplR)
library(ggplot2)
library(car)

se <- function(x){
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}
# Run this script after the gap filling process scripts have been run
# For the NACP15 abstract run Tree_rw_gapfilled.csv


##########################################################################
# Doing the Allometry sampling (form allometry_sampling.R)
##########################################################################
allometries<- list()

load("AllomFiles/All_PIPO")




##########################################################################
# load in the diameter reconstructions generated by Christy.  These are based upon gapfilled tree ring data using the fancy model.
##########################################################################
g.filled.diam <- read.csv("gap_filled_dbh.recon.csv", header=T, row.names=1)
g.filled.diam <- g.filled.diam[,substr(names(g.filled.diam),1,1)=="V"]
summary(g.filled.diam)

# read in tree data
tree.data <- read.csv("TreeData.csv", header=T)
summary(tree.data)
#trees.use <- tree.data[substr(tree.data$PlotID, 1, 1)=="V" | substr(tree.data$PlotID, 1, 2)=="MM",]
trees.use <- tree.data[substr(tree.data$PlotID, 1, 2)=="VL",]
summary(trees.use)
trees.use$spp.allom <- recode(trees.use$Species, " 'PIEN'='picea.sp'; 'PIPO'='pipo'; 'PSME'='psme'")
#quick plot
#spag.plot(g.filled.diam)

plot.data <- read.csv("raw input files/DOE_plus_Valles.csv")
summary(plot.data)


##########################################################################
# Sampling the Allometric MCMC
##########################################################################
# Tyson Only
load("AllomFiles/TysonOnly/Allom.test.2.Rdata")
allom.tyson <- list()
allom.tyson[["pipo"]] <- mc[[3]][sample(1:nrow(mc[[3]]), size=50, replace=T),]

load("AllomFiles/TysonOnly_Eq11/Allom.test.2.Rdata")
allom.tyson11 <- list()
allom.tyson11[["pipo"]] <- mc[[3]][sample(1:nrow(mc[[3]]), size=50, replace=T),]

# Chajnacky Only
load("AllomFiles/ChajnackyOnly/Allom.test.2.Rdata")
allom.chaj <- list()
allom.chaj[["pipo"]] <- mc[[3]][sample(1:nrow(mc[[3]]), size=50, replace=T),]

# Combination of Tyson & Chajnacky
load("AllomFiles/All_PIPO/Allom.test.2.Rdata")
allom.all <- list()
allom.all[["pipo"]] <- mc[[3]][sample(1:nrow(mc[[3]]), size=50, replace=T),]



##########################################################################
# Applying the allometrics to a dummy set of dbhs
##########################################################################
dbh.test <- 1:50
allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
allom.eq.tyson <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
allom.eq.pecan4 <- function(a, b, c, d, DBH) { a + b*DBH + c*DBH^d}


temp.tyson <- array(NA, dim=c(length(1:50), nrow(allom.tyson[["pipo"]])))
temp.tyson11 <- array(NA, dim=c(length(1:50), nrow(allom.tyson11[["pipo"]])))
temp.tyson.tyson <- array(NA, dim=c(length(1:50), nrow(allom.tyson11[["pipo"]])))
temp.tyson.pecan <- array(NA, dim=c(length(1:50), nrow(allom.tyson11[["pipo"]])))
temp.chaj <- array(NA, dim=c(length(1:50), nrow(allom.chaj[["pipo"]])))
temp.chaj.chaj <- array(NA, dim=c(length(1:50), nrow(allom.chaj[["pipo"]])))
temp.all <- array(NA, dim=c(length(1:50), nrow(allom.all[["pipo"]])))

# Tyson's with Pecan equation no. 4
for(i in 1:ncol(temp.tyson)){
	mu0 = allom.tyson[["pipo"]][i,"Bg0"]
	mu1 = allom.tyson[["pipo"]][i,"Bg1"]
	temp.tyson[,i] <- allom.eq(mu0=mu0, mu1=mu1, DBH=dbh.test)
}

# Tyson's with Pecan equation no. 11
for(i in 1:ncol(temp.tyson)){
	mu0 = allom.tyson11[["pipo"]][i,"Bg0"]
	mu1 = allom.tyson11[["pipo"]][i,"Bg1"]
	temp.tyson11[,i] <- allom.eq(mu0=mu0, mu1=mu1, DBH=dbh.test)
}

# Tyson's with Tyson's Equation
for(i in 1:ncol(temp.tyson.tyson)){
	mu0 = 0.054
	mu1 = 2.651
	temp.tyson.tyson[,i] <- allom.eq.tyson(mu0=mu0, mu1=mu1, DBH=dbh.test)
}

for(i in 1:ncol(temp.tyson.pecan)){
	a=0
	b=0
	c=0.054
	d=2.651
	temp.tyson.pecan[,i] <- allom.eq.pecan4(a=a,b=b,c=c,d=d, DBH=dbh.test)
}


# Chajnacky Pecan Eq #3
for(i in 1:ncol(temp.tyson)){
	mu0 = allom.chaj[["pipo"]][i,"Bg0"]
	mu1 = allom.chaj[["pipo"]][i,"Bg1"]
	temp.chaj[,i] <- allom.eq(mu0=mu0, mu1=mu1, DBH=dbh.test)
}

# Chajnacky Chajnacky Equation
for(i in 1:ncol(temp.tyson)){
	mu0 = -3.5185
	mu1 = 2.6909
	temp.chaj.chaj[,i] <- allom.eq(mu0=mu0, mu1=mu1, DBH=dbh.test)
}


# Pecan Chajnacky #3 + Tyson #4
for(i in 1:ncol(temp.tyson)){
	mu0 = allom.all[["pipo"]][i,"Bg0"]
	mu1 = allom.all[["pipo"]][i,"Bg1"]
	temp.all[,i] <- allom.eq(mu0=mu0, mu1=mu1, DBH=dbh.test)
}

tyson.mean <- rowMeans(temp.tyson)
tyson11.mean <- rowMeans(temp.tyson11)
tyson.tyson.mean <- rowMeans(temp.tyson.tyson)
tyson.pecan.mean <- rowMeans(temp.tyson.pecan)
chaj.mean <- rowMeans(temp.chaj)
chaj.chaj.mean <- rowMeans(temp.chaj.chaj)
all.mean <- rowMeans(temp.all)

max(tyson.mean, tyson11.mean, tyson.tyson.mean, chaj.mean, all.mean)

plot(tyson.mean ~ dbh.test, col="blue", cex=1, pch=19, xlab="dbh (cm)", ylab="kg/tree", main="Allometric Equation Comparison")
	points(tyson11.mean ~ dbh.test, col="red3", cex=1, pch=19)
	points(tyson.tyson.mean ~ dbh.test, col="black", cex=1, pch=19)
	points(chaj.mean ~ dbh.test, col="darkgreen", cex=1, pch=19)
#	points(chaj.chaj.mean ~ dbh.test, col="purple", cex=1, pch=1)
	points(all.mean ~ dbh.test, col="orange3", cex=1, pch=19)
legend("topleft", legend=c("Tyson, Pecan 4", "Tyson, Pecan Eq 11", "Tyson, Tyson Eq", "Chajnacky, Pecan eq 3", "Both, Pecan Eq 3,4"), col=c("blue", "red3", "black", "darkgreen", "orange3"), pch=19)


# Just tyson optsion
plot(tyson.mean ~ dbh.test, col="blue", cex=1, pch=19, xlab="dbh (cm)", ylab="kg/tree", main="Allometric Equation Comparison -- Tyson Only")
	points(tyson11.mean ~ dbh.test, col="red3", cex=1, pch=19)
	points(tyson.tyson.mean ~ dbh.test, col="black", cex=1, pch=19)
	points(tyson.pecan.mean ~ dbh.test, col="purple", cex=1, pch=19)

##########################################################################
# Applying the MCMC Allometric Equations
##########################################################################
#Convert to biomass with the allometric equation
#using the PECAN generated bayesian equations

plots <- unique(trees.use$PlotID) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet

allom.eq <- function(mu0, mu1, DBH) { exp(mu0 + mu1 * log(DBH) )}
allom.eq.tyson <- function(mu0, mu1, DBH) { mu0 * DBH^mu1}
# dbh=0 causes problems, so we're going to make those very small
g.filled.diam[g.filled.diam==0] <- 1e-6
min(g.filled.diam, na.rm=T)
summary(g.filled.diam[,1:10])
dim(g.filled.diam)

# Blanks arrays for the final biomass by plot
# Tyson
bm.array.tyson <- array(NA, dim=c(nrow(g.filled.diam), length(unique(trees.use$PlotID)), nrow(allom.tyson[[1]])))
row.names(bm.array.tyson) <- row.names(g.filled.diam)

# Chajnacky
bm.array.chaj <- array(NA, dim=c(nrow(g.filled.diam), length(unique(trees.use$PlotID)), nrow(allom.chaj[[1]])))
row.names(bm.array.chaj) <- row.names(g.filled.diam)

# All
bm.array.all <- array(NA, dim=c(nrow(g.filled.diam), length(unique(trees.use$PlotID)), nrow(allom.all[[1]])))
row.names(bm.array.all) <- row.names(g.filled.diam)

summary(bm.array.tyson[,,1])
summary(bm.array.chaj[,,1])
summary(bm.array.all[,,1])
#--------------------------------------------------
# INSERT i LOOP HERE to go through each iteration of randomness from MCMC
# This is one big loop that goes through each layer of the 500 iterations
# Biomass gets applied at the tree level
#--------------------------------------------------
#--------------------------
# Running Tyson Only
#--------------------------
for(i in 1:nrow(allom.tyson[[1]])){
  allom.temp <- g.filled.diam
  allom.temp[,] <- NA
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
  cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
  # Note: we'll have to make this a bit fancier in the future for species with mu0==0
  mu0 = ifelse(!(allom.tyson[[j]][i,"mu0"]==0 & allom.tyson[[j]][i,"mu1"]==0), allom.tyson[[j]][i,"mu0"], allom.tyson[[j]][i,"Bg0"])
  mu1 = ifelse(!(allom.tyson[[j]][i,"mu0"]==0 & allom.tyson[[j]][i,"mu1"]==0), allom.tyson[[j]][i,"mu1"], allom.tyson[[j]][i,"Bg1"])
  allom.temp[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
# summing to the plot level

allom.temp[is.na(allom.temp)] <- 0

# biomass loop for summing trees to plots
# We're doing the unit conversions here; we had calculated density in stems/ha, but Christy wants to look at Biomass in kg/m2, so we're putting everything in kg/m2 here
for(p in 1:length(plots)){
  cols <- which(names(allom.temp) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
  if(substr(plots[p],1,1)=="V"){
    bm.array.tyson[,p,i] <- rowMeans(allom.temp[,cols])*plot.data[plot.data$PlotID==paste(plots[p]), "Density.Total..stems.ha."]/10000 #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
  } else {
    temp <- allom.temp[,cols]
    for(t in names(temp)){ # Convert biomass/tree to biomass/ha
      temp[,t] <- temp[,t] * tree.data[tree.data$TreeID==t,"Density..stems.ha."]/10000
      }
    bm.array.tyson[,p,i] <- rowSums(temp) #sum biomass/ha
    }
}
}
summary(bm.array.tyson[,,1])
#--------------------------

#--------------------------
# Running Chajnacky Only
#--------------------------
for(i in 1:nrow(allom.chaj[[1]])){
  allom.temp <- g.filled.diam
  allom.temp[,] <- NA
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
  cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
  # Note: we'll have to make this a bit fancier in the future for species with mu0==0
  mu0 = ifelse(!(allom.chaj[[j]][i,"mu0"]==0 & allom.chaj[[j]][i,"mu1"]==0), allom.chaj[[j]][i,"mu0"], allom.chaj[[j]][i,"Bg0"])
  mu1 = ifelse(!(allom.chaj[[j]][i,"mu0"]==0 & allom.chaj[[j]][i,"mu1"]==0), allom.chaj[[j]][i,"mu1"], allom.chaj[[j]][i,"Bg1"])
  allom.temp[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
# summing to the plot level

allom.temp[is.na(allom.temp)] <- 0

# biomass loop for summing trees to plots
# We're doing the unit conversions here; we had calculated density in stems/ha, but Christy wants to look at Biomass in kg/m2, so we're putting everything in kg/m2 here
for(p in 1:length(plots)){
  cols <- which(names(allom.temp) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
  if(substr(plots[p],1,1)=="V"){
    bm.array.chaj[,p,i] <- rowMeans(allom.temp[,cols])*plot.data[plot.data$PlotID==paste(plots[p]), "Density.Total..stems.ha."]/10000 #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
  } else {
    temp <- allom.temp[,cols]
    for(t in names(temp)){ # Convert biomass/tree to biomass/ha
      temp[,t] <- temp[,t] * tree.data[tree.data$TreeID==t,"Density..stems.ha."]/10000
      }
    bm.array.chaj[,p,i] <- rowSums(temp) #sum biomass/ha
    }
}
}
summary(bm.array.chaj[,,1])
#--------------------------


#--------------------------
# Running All PIPO
#--------------------------
for(i in 1:nrow(allom.all[[1]])){
  allom.temp <- g.filled.diam
  allom.temp[,] <- NA
# Species loop for calculating tree biomass
for(j in unique(trees.use$spp.allom)){
#  cols <- which(names(g.filled.diam) %in% trees.use[trees.use$spp.allom==j, "TreeID"])
  # Note: we'll have to make this a bit fancier in the future for species with mu0==0
#  mu0 = ifelse(!(allom.all[[j]][i,"mu0"]==0 & allom.all[[j]][i,"mu1"]==0), allom.all[[j]][i,"mu0"], allom.all[[j]][i,"Bg0"])
#  mu1 = ifelse(!(allom.all[[j]][i,"mu0"]==0 & allom.all[[j]][i,"mu1"]==0), allom.all[[j]][i,"mu1"], allom.all[[j]][i,"Bg1"])
#  mu0 = allom.all[[j]][i,"Bg0"]
#  mu1 = allom.all[[j]][i,"Bg1"]

  allom.temp[,cols] <- allom.eq(mu0=mu0, mu1 = mu1, DBH = g.filled.diam[,cols])
}
# summing to the plot level

allom.temp[is.na(allom.temp)] <- 0

# biomass loop for summing trees to plots
# We're doing the unit conversions here; we had calculated density in stems/ha, but Christy wants to look at Biomass in kg/m2, so we're putting everything in kg/m2 here
for(p in 1:length(plots)){
  cols <- which(names(allom.temp) %in% trees.use[trees.use$PlotID==plots[p], "TreeID"])
  if(substr(plots[p],1,1)=="V"){
    bm.array.all[,p,i] <- rowMeans(allom.temp[,cols])*plot.data[plot.data$PlotID==paste(plots[p]), "Density.Total..stems.ha."]/10000 #mean tree * trees/ha (do for Valles only bc sum of trees != plot density; different sampling method than Neil)
  } else {
    temp <- allom.temp[,cols]
    for(t in names(temp)){ # Convert biomass/tree to biomass/ha
      temp[,t] <- temp[,t] * tree.data[tree.data$TreeID==t,"Density..stems.ha."]/10000
      }
    bm.array.all[,p,i] <- rowSums(temp) #sum biomass/ha
    }
}
}
summary(bm.array.all[,,1])

# for(i in dim(allom.temp)[2]){
	# plot(allom.temp[,i,1]~g.filled.diam[,i])}
#--------------------------

#--------------------------------------------------

#bm.array[,,1]

## OFFENDER: VUF032; VUF026 is good
# g.filled.diam[,c("VUF026","VUF032")]

### OUTSIDE of all LOOPs (iteration + species + plots)
# You should now have a 3-dimensional array with plots as columns, years as rows, and iterations as layers
biom.mean <- apply(bm.array.all[,,], c(1,2), mean) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
biom.sd <- apply(bm.array.all[,,], c(1,2), sd) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
biom.se <- apply(bm.array.all[,,], c(1,2), se)

biom.mean <- as.data.frame(biom.mean)
names(biom.mean)<- plots

biom.sd <-as.data.frame(biom.sd)
names(biom.sd)<- c(paste(plots, "sd", sep="."))
biom.se <-as.data.frame(biom.se)
names(biom.se)<- c(paste(plots, "se", sep="."))


biom.valles <- as.data.frame(c(biom.mean, biom.sd, biom.se))
row.names(biom.valles) <- row.names(biom.mean)
summary(biom.valles)
head(biom.valles)

#save(biom.valles, file="biom.valles_cum.csv")

#---------------------------------------------------------------------
# This we did in a loop above to make it mroe flexible for the future
# (and we did it right this time)
#---------------------------------------------------------------------
# biom.valles.cum.dens <- biom.valles
# 
# biom.valles.cum.dens$VLA <- biom.valles.cum.dens$VLA / 144/1000
# biom.valles.cum.dens$VLA.sd <- biom.valles.cum.dens$VLA.sd /144/1000
# biom.valles.cum.dens$VLA.se <- biom.valles.cum.dens$VLA.se /144/1000
# 
# biom.valles.cum.dens$VLB <- biom.valles.cum.dens$VLB /624/1000
# biom.valles.cum.dens$VLB.sd <- biom.valles.cum.dens$VLB.sd /624/1000
# biom.valles.cum.dens$VLB.se <- biom.valles.cum.dens$VLB.se /624/1000
# 
# biom.valles.cum.dens$VUA <- biom.valles.cum.dens$VUA /576/1000
# biom.valles.cum.dens$VUA.sd <- biom.valles.cum.dens$VUA.sd /576/1000
# biom.valles.cum.dens$VUA.se <- biom.valles.cum.dens$VUA.se /576/1000
# 
# biom.valles.cum.dens$VUB <- biom.valles.cum.dens$VUB /576/1000
# biom.valles.cum.dens$VUB.sd <- biom.valles.cum.dens$VUB.sd /576/1000
# biom.valles.cum.dens$VUB.se <- biom.valles.cum.dens$VUB.se /576/1000
# 
# summary(biom.valles.cum.dens)
# biom.valles.cum.dens$year <- as.factor(row.names(biom.valles.cum.dens))
# head(biom.valles.cum.dens)

# now we have biomass per m^2 for each plot with SD
#---------------------------------------------------------------------

#save(biom.valles.cum.dens, file="biom_valles_dum_m2.csv")

biom.valles.stack <- stack(biom.valles[1:2])
names(biom.valles.stack) <- c("Biom.Mean", "PlotID")
biom.valles.stack$Year <- as.numeric(paste(row.names(biom.valles)))
biom.valles.stack$Plot <- as.factor(substr(biom.valles.stack$PlotID, 3,3))
biom.valles.stack$Site <- as.factor(substr(biom.valles.stack$PlotID, 1,2))
summary(biom.valles.stack)

biom.valles.stack.sd <- stack(biom.valles[3:4])
names(biom.valles.stack.sd) <- c("Biom.SD", "PlotID")

biom.valles.stack.se <- stack(biom.valles[5:6])
names(biom.valles.stack.se) <- c("Biom.SE", "PlotID")

biom.valles.stack$Biom.SD <- biom.valles.stack.sd[,1]
biom.valles.stack$Biom.SE <- biom.valles.stack.se[,1]
summary(biom.valles.stack)

biom.valles.stack$Ribbon.max <- biom.valles.stack$Biom.Mean + biom.valles.stack$Biom.SD
biom.valles.stack$Ribbon.min <- biom.valles.stack$Biom.Mean - biom.valles.stack$Biom.SD
# biom.valles.stack$Ribbon.min <- ifelse(biom.valles.stack$Ribbon.min < 0, 0, biom.valles.stack$Ribbon.min)
# biom.valles.stack$Ribbon.max <- ifelse(biom.valles.stack$Ribbon.max > 100, 100, biom.valles.stack$Ribbon.max)
summary(biom.valles.stack)

ggplot(data=biom.valles.stack[biom.valles.stack$Year<2012 & (biom.valles.stack$Site=="VL"),])  + facet_grid(Plot ~ Site) +
  # plotting total site basal area  
  geom_ribbon(aes(x=Year, ymin=Biom.Mean-Biom.SD, ymax=Biom.Mean+Biom.SD, fill=PlotID), alpha=0.5) +
  geom_line(aes(x=Year, y=Biom.Mean, color=PlotID)) 

# valles.cum.plot<- 
ggplot(data=biom.valles.stack[biom.valles.stack$Year<2012,])  + facet_grid(Plot ~ Site) +
  # plotting total site basal area  
  geom_ribbon(aes(x=Year, ymin=Ribbon.min, ymax=Ribbon.max, fill=PlotID), alpha=0.5) +
  geom_line(aes(x=Year, y=Biom.Mean, color=PlotID)) +
   scale_y_continuous(limits=c(0,1000)) #+
#   theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=12), axis.text.y=element_text(color="black", size=12))+
#   scale_fill_discrete(name="Model", labels = c("nt.pipo.mean", "nt.piaz.mean", "nt.pine.spp", "nt.vcnp.mean", "nt.pine.dom.mean")))


# need to get the biomass increment of each year for the plots 
# get the increment from the 3D array previously made

bm.array
bm.increment <- bm.array
bm.increment[1:3,,] <- NA
dim(bm.array)[3]
for(j in 1:dim(bm.increment)[3]){
  # inserting oldest biomass
  bm.increment[nrow(bm.increment),,j] <- bm.array[nrow(bm.increment),,j]
  for(i in (nrow(bm.increment)-1):1){
    bm.increment[i,,j] <- ifelse(!is.na(bm.array[i,,j]) & !is.na(bm.array[i+1,,j]),bm.array[i,,j] - bm.array[i+1,,j],NA) # subtracting the previous year's growth from DBH to get that year's DBH
  }
}
bm.increment[1:3,,] <- NA
min(bm.increment, na.rm=T)
head(bm.increment)


biom.inc.mean <- apply(bm.increment[,,], c(1,2), mean) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running
biom.inc.sd <- apply(bm.increment[,,], c(1,2), sd) # bm.array==the array you're working with, 3 = do the funciton to the layers (3rd dim), mean = the function you're running

biom.inc.mean <- as.data.frame(biom.inc.mean)
names(biom.inc.mean)<- c("VLA", "VLB", "VUA", "VUB")
summary(biom.inc.mean)

biom.inc.sd <-as.data.frame(biom.inc.sd)
names(biom.inc.sd)<- c("VLA.sd", "VLB.sd", "VUA.sd", "VUB.sd")
summary(biom.inc.sd)

biom.inc.valles <- as.data.frame(c(biom.inc.mean, biom.inc.sd))
row.names(biom.inc.valles) <- row.names(biom.inc.mean)
summary(biom.inc.valles)
head(biom.inc.valles)

save(biom.inc.valles, file="biom.valles_inc.csv")

biom.valles.inc.dens <- biom.inc.valles

biom.valles.inc.dens$VLA <- biom.valles.inc.dens$VLA /144/1000 #*0.59
biom.valles.inc.dens$VLA.sd <- biom.valles.inc.dens$VLA.sd /144/1000

biom.valles.inc.dens$VLB <- biom.valles.inc.dens$VLB /624/1000 # *0.09
biom.valles.inc.dens$VLB.sd <- biom.valles.inc.dens$VLB.sd /624/1000

biom.valles.inc.dens$VUA <- biom.valles.inc.dens$VUA /576/1000 #0.11
biom.valles.inc.dens$VUA.sd <- biom.valles.inc.dens$VUA.sd /576/1000

biom.valles.inc.dens$VUB <- biom.valles.inc.dens$VUB /576/1000 #0.19
biom.valles.inc.dens$VUB.sd <- biom.valles.inc.dens$VUB.sd /576/1000
summary(biom.valles.inc.dens)

#now in kilograms of biomass increment per plot
save(biom.valles.inc.dens, file="valles_bm_inc_m2.csv")



# Expository graphs for valles caldera
valles.plot<- ggplot()  +
  # plotting total site basal area
  
  geom_ribbon(data=vlf.year, aes(x=year, ymin=nt.pipo.mean - 1.96*nt.pipo.sd, ymax=nt.pipo.mean + 1.96*nt.pipo.sd), alpha=0.15, fill="red")+
  geom_ribbon(data=vlf.year, aes(x=year, ymin=nt.piaz.mean - 1.96*nt.piaz.sd, ymax=nt.piaz.mean + 1.96*nt.piaz.sd), alpha=0.15, fill="orange")+
  geom_ribbon(data=vlf.year, aes(x=year, ymin=nt.pine.spp.mean - 1.96*nt.pine.spp.sd, ymax=nt.pine.spp.mean + 1.96*nt.pine.spp.sd), alpha=0.15, fill="green")+
  #geom_ribbon(data=vlf.year, aes(x=year, ymin=nt.vcnp.mean - 1.96*nt.vcnp.sd, ymax=nt.vcnp.mean + 1.96*nt.vcnp.sd), alpha=0.15, fill="purple")+
  geom_ribbon(data=vlf.year, aes(x=year, ymin=nt.pine.dom.mean - 1.96*nt.pine.dom.sd, ymax=nt.pine.dom.mean + 1.96*nt.pine.dom.sd), alpha=0.15, fill="blue")+
  
  geom_line(data=vlf.year,  aes(x=year, y=nt.pipo.mean), size=1.5, colour="red") +
  geom_line(data= vlf.year, aes(x=year, y=nt.piaz.mean), size=1.5, colour="orange") +
  geom_line(data= vlf.year, aes(x=year, y=nt.pine.spp.mean), size=1.5,colour="green") +
  #geom_line(data= vlf.year, aes(x=year, y=nt.vcnp.mean), size=1.5,colour="purple") +
  geom_line(data= vlf.year, aes(x=year, y=nt.pine.dom.mean), size=1.5,colour="blue") +
  geom_line(data= vlf.bm.avg.gf, aes(x=year, y=jenkins.pine), size=1.5,colour="black") +
  





# names(tree.data)
# 
# #need to incorporate the density into things
# jenkins.bm.density <- data.frame(array(NA, dim=c(nrow(mmf.jenkins.recon), ncol(mmf.jenkins.recon))))
# row.names(jenkins.bm.density) <- row.names(mmf.jenkins.recon)  #CRR Added
# names(jenkins.bm.density)<- names(mmf.jenkins.recon)
# 
# for(i in unique(names(mmf.jenkins.recon))){
#   jenkins.bm.density[,i] <- mmf.jenkins.recon[,i]*tree.data[tree.data$TreeID==i,"dens.stem.ha"]
# }
# summary(jenkins.bm.density)
# 
# ##########################################################################
# #we are now in kg of biomass per Ha
# ##########################################################################
# jenkins.bm.density.meter <- jenkins.bm.density/10000
# summary(jenkins.bm.density.meter)
# 
# ##########################################################################
# #now we are in kg of biomass per meter square meter
# ##########################################################################
# #need to get biomass increment for each tree before we do anything
# trees<- unique(names(jenkins.bm.density.meter))
# jenkins.tree.inc.meter <- data.frame(array(NA, dim=c(nrow(jenkins.bm.density.meter), length(trees))))
# row.names(jenkins.tree.inc.meter) <- row.names(jenkins.bm.density.meter)
# names(jenkins.tree.inc.meter) <- trees
# 
# for(j in seq_along(jenkins.tree.inc.meter)){
#   # inserting oldest biomass
#   jenkins.plot.bm.inc[nrow(jenkins.plot.bm.inc),j] <- NA
#   for(i in (length(jenkins.tree.inc.meter[,j])-1):1){
#     jenkins.tree.inc.meter[i,j] <- jenkins.bm.density.meter[i,j] - jenkins.bm.density.meter[i+1,j] # subtracting the previous year's growth from DBH to get that year's DBH
#   }
# }
# summary(jenkins.tree.inc.meter)
# 
# plot(jenkins.tree.inc.meter[,1]~row.names(jenkins.tree.inc.meter), type="l")
# 
# ##########################################################################
# # jenkins.tree.inc.meter is the biomass increment for individual trees in kgC/m^2
# ##########################################################################
# 
# #now need to aggregate the biomass per tree up to the plot level
# # Dr. Rollinson Fix:
# plots <- unique(substr(names(jenkins.bm.density.meter), 1, 3)) # You had the right idea, but it was throwing errors because you were trying to evaluate plots you haven't gotten to yet
# jenkins.plot.meter <- data.frame(array(NA, dim=c(nrow(jenkins.bm.density.meter), length(plots))))
# row.names(jenkins.plot.meter) <- row.names(jenkins.bm.density.meter)  #CRR Added
# names(jenkins.plot.meter) <- plots
# 
# for(i in unique(plots)){
#   cols <- which(substr(names(jenkins.bm.density.meter),1,3)==i)
#   ifelse(length(cols) > 1, jenkins.plot.meter[,which(plots==i)] <- rowSums(jenkins.bm.density.meter[,cols], na.rm=T), jenkins.plot.meter[,which(plots==i)] <- jenkins.bm.density.meter[,cols])
# }
# summary(jenkins.plot.meter)
# head(jenkins.plot.meter)
# 
# write.csv(jenkins.plot.meter, "MMF_plot_BM_cum.csv")
# 
# plot(jenkins.plot.meter$MMA~row.names(jenkins.plot.meter), type="l", col="red")
# par(new = T)
# plot(jenkins.plot.meter$MMB~row.names(jenkins.plot.meter), type="l", col="Green", ylim=range(jenkins.plot.meter$MMA))
# par(new=T)
# plot(jenkins.plot.meter$MMC~row.names(jenkins.plot.meter), type="l", col="Blue",ylim=range(jenkins.plot.meter$MMA))
# 
# 
# ##########################################################################
# # Adding up the plots to get a site level biomass load
# # Need to streamline this so that when we add more sites it can be automatic
# ##########################################################################
# # names(tree.data)
# # sites<- unique(tree.data$site)
# # jenkins.site.meter <- data.frame(array(NA, dim=c(nrow(jenkins.plot.meter), length(sites))))
# # row.names(jenkins.site.meter) <- row.names(jenkins.plot.meter)
# # names(jenkins.site.meter) <- sites
# # summary(jenkins.site.meter)
#  
# 
# jenkins.site.meter <- data.frame(array(NA, dim=c(nrow(jenkins.plot.meter), 2)))
# names(jenkins.site.meter) <- c("MMF", "MMF.SD")
# row.names(jenkins.site.meter) <- row.names(jenkins.plot.meter)
# 
# jenkins.site.meter$MMF <- rowMeans(jenkins.plot.meter)
# jenkins.site.meter$MMF.SD <- apply(jenkins.plot.meter, 1, sd)
# summary(jenkins.site.meter)
# head(jenkins.site.meter)
# write.csv(jenkins.site.meter, "MMF_site_BM_cum.csv")
# ##########################################################################
# # Now need to get the Biomass increment for the years for the plots then go to the site
# ##########################################################################
# jenkins.plot.bm.inc <- data.frame(array(NA, dim=c(nrow(jenkins.plot.meter), length(jenkins.plot.meter))))
# names(jenkins.plot.bm.inc) <- names(jenkins.plot.meter)
# row.names(jenkins.plot.bm.inc) <- row.names(jenkins.plot.meter)
# summary(jenkins.plot.bm.inc)
# 
# for(j in seq_along(jenkins.plot.bm.inc)){
#   # inserting oldest biomass
#   jenkins.plot.bm.inc[nrow(jenkins.plot.bm.inc),j] <- NA
#   for(i in (length(jenkins.plot.bm.inc[,j])-1):1){
#     jenkins.plot.bm.inc[i,j] <- jenkins.plot.meter[i,j] - jenkins.plot.meter[i+1,j] # subtracting the previous year's growth from DBH to get that year's DBH
#   }
# }
# head(jenkins.plot.bm.inc)
# summary(jenkins.plot.bm.inc)
# write.csv(jenkins.plot.bm.inc, "MMF_plot_BM_inc.csv")
# 
# plot(jenkins.plot.bm.inc$MMA~row.names(jenkins.plot.bm.inc), type="l", col="red", ylim=c(0,1))
# par(new = T)
# plot(jenkins.plot.bm.inc$MMB~row.names(jenkins.plot.bm.inc), type="l", col="Green",ylim=c(0,1))
# par(new=T)
# plot(jenkins.plot.bm.inc$MMC~row.names(jenkins.plot.bm.inc), type="l", col="Blue",ylim=c(0,1))
# 
# ##########################################################################
# # We have now an BM increment for each plot
# # Now need to get the Biomass increment for the site as a whole
# ##########################################################################
# 
# jenkins.site.bm.inc <- data.frame(array(NA, dim=c(nrow(jenkins.plot.bm.inc), 2)))
# names(jenkins.site.bm.inc) <- names(jenkins.site.meter)
# row.names(jenkins.site.bm.inc) <- row.names(jenkins.site.meter)
# summary(jenkins.site.bm.inc)
# jenkins.site.bm.inc$MMF <- rowMeans(jenkins.plot.bm.inc) 
# jenkins.site.bm.inc$MMF.SD <- apply(jenkins.plot.bm.inc, 1, sd)
# summary(jenkins.site.bm.inc)
# head(jenkins.site.bm.inc)
# 
# 
# plot(jenkins.plot.bm.inc$MMA~row.names(jenkins.plot.bm.inc), type="l", col="red", ylim=c(0,1))
# par(new = T)
# plot(jenkins.plot.bm.inc$MMB~row.names(jenkins.plot.bm.inc), type="l", col="Green",ylim=c(0,1))
# par(new=T)
# plot(jenkins.plot.bm.inc$MMC~row.names(jenkins.plot.bm.inc), type="l", col="Blue",ylim=c(0,1))
# par(new=T)
# plot(jenkins.site.bm.inc$MMF~row.names(jenkins.site.bm.inc), type="l", lwd=3, ylim=c(0,1))
# 
# write.csv(jenkins.site.bm.inc, "MMF_site_BM_inc.csv")
# 
# 
# ##########################################################################
# # Going to aggregate the biomass to the species level
# ##########################################################################
# 
# #now need to aggregate the biomass per tree up to the plot level
# # Dr. Rollinson Fix:
# summary(tree.deets)
# spp <- unique(tree.deets$SPP)
# spp.plot <- unique(tree.deets$plot)
# 
# tree.deets[1:10,]; jenkins.bm.density.meter[1:10, 1:10]
# summary(spp)
# 
# # Making a 3-D array that's years x species x plots
# jenkins.spp.meter <- array(NA, dim=c(nrow(jenkins.bm.density.meter), length(spp), length(spp.plot)))
# row.names(jenkins.spp.meter) <- row.names(jenkins.bm.density.meter)  #CRR Added
# #names(jenkins.spp.meter) <- spp # Skipping this for now because I don't remember how to do names of 3-D arrays
# dim(jenkins.spp.meter)
# 
# 
# for(i in 1:length(spp.plot)){
#   for(j in 1:length(spp)){ # dim #2!
#     cols <- which(tree.deets$SPP==spp[j] & tree.deets$plot==spp.plot[i])
#     if(length(cols) > 1){ jenkins.spp.meter[,j,i] <- rowSums(jenkins.bm.density.meter[,cols], na.rm=T)
#     } else if (length(cols) == 1) { jenkins.spp.meter[,j,i] <- jenkins.bm.density.meter[,cols] 
#     } else jenkins.spp.meter[,j,i] <- NA
#   }
# }
# dim(jenkins.spp.meter)
# summary(jenkins.spp.meter[,,1])
# summary(jenkins.spp.meter[,,2])
# summary(jenkins.spp.meter[,,3])
# head(jenkins.spp.meter)
# 
# test.a <- jenkins.spp.meter[,,1:2]
# summary(test.a)
# 
# # test <- data.frame(array(NA, dim=c(nrow(jenkins.bm.density.meter), length(spp))))
# # names(test) <- spp
# # row.names(test) <- row.names(jenkins.bm.density.meter)
# # summary(test)
# # dim(test)
# 
# site.spp.bm.cum <- apply(jenkins.spp.meter, c(1:2), FUN=mean, na.rm=T)
# site.spp.bm.cum <- data.frame(site.spp.bm.cum); names(site.spp.bm.cum) <- spp
# summary(site.spp.bm.cum)
# summary(jenkins.site.meter)
# head(jenkins.spp.meter)
# 
# site.spp.bm.cum.SD <- apply(jenkins.spp.meter, c(1:2), FUN=sd, na.rm=T)
# site.spp.bm.cum.sd <- data.frame(site.spp.bm.cum2); names(site.spp.bm.cum2) <- spp
# summary(site.spp.bm.cum.SD)
# summary(jenkins.site.meter)
# head(jenkins.spp.meter)
# write.csv(site.spp.bm.cum[order(row.names(site.spp.bm.cum), decreasing=F),order(names(site.spp.bm.cum))], "MMF_bm_spp_cum.csv")
# 
# # Now need toget an increment for each species, just like we did for the whole site
# 
# summary(tree.deets)
# spp <- unique(tree.deets$SPP)
# spp.plot <- unique(tree.deets$plot)
# 
# tree.deets[1:10,]; jenkins.bm.density.meter[1:10, 1:10]
# summary(spp)
# 
# # Making a 3-D array that's years x species x plots
# jenkins.spp.meter.inc <- array(NA, dim=c(nrow(jenkins.tree.inc.meter), length(spp), length(spp.plot)))
# row.names(jenkins.spp.meter.inc) <- row.names(jenkins.tree.inc.meter)  #CRR Added
# #names(jenkins.spp.meter) <- spp # Skipping this for now because I don't remember how to do names of 3-D arrays
# dim(jenkins.spp.meter.inc)
# 
# 
# for(i in 1:length(spp.plot)){
#   for(j in 1:length(spp)){ # dim #2!
#     cols <- which(tree.deets$SPP==spp[j] & tree.deets$plot==spp.plot[i])
#     if(length(cols) > 1){ jenkins.spp.meter.inc[,j,i] <- rowSums(jenkins.tree.inc.meter[,cols], na.rm=T)
#     } else if (length(cols) == 1) { jenkins.spp.meter.inc[,j,i] <- jenkins.tree.inc.meter[,cols] 
#     } else jenkins.spp.meter.inc[,j,i] <- NA
#   }
# }
# dim(jenkins.spp.meter.inc)
# summary(jenkins.spp.meter.inc[,,1])
# summary(jenkins.spp.meter.inc[,,2])
# summary(jenkins.spp.meter.inc[,,3])
# head(jenkins.spp.meter.inc)
# 
# test.a <- jenkins.spp.meter.inc[,,1:2]
# summary(test.a)
# 
# # test <- data.frame(array(NA, dim=c(nrow(jenkins.bm.density.meter), length(spp))))
# # names(test) <- spp
# # row.names(test) <- row.names(jenkins.bm.density.meter)
# # summary(test)
# # dim(test)
# 
# site.spp.bm.inc <- apply(jenkins.spp.meter.inc, c(1:2), FUN=mean, na.rm=T)
# site.spp.bm.inc <- data.frame(site.spp.bm.inc); names(site.spp.bm.inc) <- spp
# summary(site.spp.bm.inc)
# summary(jenkins.site.meter)
# summary(site.spp.bm.cum)
# head(site.spp.bm.inc)
# head(site.spp.bm.cum)
# 
# plot(site.spp.bm.inc[,1]~row.names(site.spp.bm.inc), type="l")
# 
# write.csv(site.spp.bm.inc[order(row.names(site.spp.bm.inc), decreasing=F),order(names(site.spp.bm.inc))], "MMF_bm_spp_inc.csv")
# #Swizzle! Things are looking good.  we are now in kg of biomass per meter squared at the plot level.